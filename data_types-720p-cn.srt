0
00:00:00,000 --> 00:00:02,420
[音乐响起]

1
00:00:05,189 --> 00:00:05,980
发言者：好的。

2
00:00:05,980 --> 00:00:08,540
让我们来谈谈 C 语言的另一个独特之处、

3
00:00:08,540 --> 00:00:10,010
即数据类型和变量。

4
00:00:10,010 --> 00:00:12,340
当我说 C 的独特性时，我的意思其实只是指在以下情况下、

5
00:00:12,340 --> 00:00:14,470
如果你已经做了很长时间的程序员、

6
00:00:14,470 --> 00:00:16,270
您可能从未使用过数据类型

7
00:00:16,270 --> 00:00:18,470
如果您使用过现代编程语言，您就会知道。

8
00:00:18,470 --> 00:00:20,432
PHP 和 JavaScript 等现代语言、

9
00:00:20,432 --> 00:00:22,640
我们稍后还将在课程中看到这一点、

10
00:00:22,640 --> 00:00:25,550
您实际上不必指定变量的数据类型

11
00:00:25,550 --> 00:00:26,270
当您使用它时。

12
00:00:26,270 --> 00:00:28,067
你只需声明并开始使用它。

13
00:00:28,067 --> 00:00:29,900
如果是整数，它就知道是整数。

14
00:00:29,900 --> 00:00:31,960
如果它是一个角色，它就知道它是一个角色。

15
00:00:31,960 --> 00:00:35,320
如果是单词，它就知道是所谓的字符串。

16
00:00:35,320 --> 00:00:37,300
但在 C 语言中，由于它是一种更古老的语言，我们需要

17
00:00:37,300 --> 00:00:39,420
来指定每个变量的数据类型

18
00:00:39,420 --> 00:00:42,990
我们在第一次使用该变量时创建的。

19
00:00:42,990 --> 00:00:45,030
因此，C 语言内置了一些数据类型。

20
00:00:45,030 --> 00:00:46,972
让我们来了解其中的一些。

21
00:00:46,972 --> 00:00:50,180
之后，我们还将讨论一些数据类型

22
00:00:50,180 --> 00:00:54,450
我们已经为您编写了这些内容，因此您可以在 CS50 中使用它们。

23
00:00:54,450 --> 00:00:56,130
第一个是 int。

24
00:00:56,130 --> 00:00:59,110
int 数据类型用于存储整数值的变量。

25
00:00:59,110 --> 00:01:03,210
因此，1、2、3，负 1、2、3，以此类推。

26
00:01:03,210 --> 00:01:05,960
整数，这是您在测验中应该牢记的、

27
00:01:05,960 --> 00:01:09,590
总是占用 4 个字节的内存，即 32 位。

28
00:01:09,590 --> 00:01:11,620
一个字节有八个比特。

29
00:01:11,620 --> 00:01:14,470
因此，这意味着整数可以存储的数值范围是

30
00:01:14,470 --> 00:01:19,130
受到 32 位信息量的限制。

31
00:01:19,130 --> 00:01:21,850
现在看来，那是很久以前的决定了

32
00:01:21,850 --> 00:01:24,310
我们将把 32 位的范围分割开来

33
00:01:24,310 --> 00:01:26,650
分为负整数和正整数、

34
00:01:26,650 --> 00:01:28,390
各占半数。

35
00:01:28,390 --> 00:01:32,230
因此，我们用整数表示的数值范围从负 2

36
00:01:32,230 --> 00:01:36,520
的 31 次方到 2 的 31 次方减 1、

37
00:01:36,520 --> 00:01:38,190
因为你还需要一个 0 的位置。

38
00:01:38,190 --> 00:01:41,650
&gt;&gt; 因此，在一个 int 中可能容纳的值中，基本上有一半是负值、

39
00:01:41,650 --> 00:01:42,610
一半为阳性。

40
00:01:42,610 --> 00:01:47,270
这里大概是负 20 亿到正 20 亿之间。

41
00:01:47,270 --> 00:01:50,207
大概几亿吧。

42
00:01:50,207 --> 00:01:52,290
这就是一个整数变量所能容纳的内容。

43
00:01:52,290 --> 00:01:55,490
现在，我们还有一种叫做无符号整数的东西。

44
00:01:55,490 --> 00:01:59,220
现在，无符号 int 并不是一种独立的变量类型。

45
00:01:59,220 --> 00:02:01,590
相反，无符号是一种限定符。

46
00:02:01,590 --> 00:02:04,990
它稍微修改了整数的数据类型。

47
00:02:04,990 --> 00:02:07,850
&gt;&gt;在这种情况下，无符号意味着--您还可以

48
00:02:07,850 --> 00:02:11,530
使用无符号的其他数据类型，整数并不是唯一的数据类型。

49
00:02:11,530 --> 00:02:15,310
它实际上是将正值范围扩大了一倍

50
00:02:15,310 --> 00:02:19,350
整数所能承担的运算量，其代价是不再允许

51
00:02:19,350 --> 00:02:21,140
让你承担负值。

52
00:02:21,140 --> 00:02:25,400
因此，如果您知道的数字将高于 20 亿，但低于

53
00:02:25,400 --> 00:02:31,280
比如说，比 40 亿--也就是 2 的 32 次方--还要多。

54
00:02:31,280 --> 00:02:33,330
如果您想使用无符号 int

55
00:02:33,330 --> 00:02:35,050
知道自己的价值永远不会是负数。

56
00:02:35,050 --> 00:02:37,216
&gt;&gt;您偶尔会用到无符号变量

57
00:02:37,216 --> 00:02:39,460
这就是我在这里提到它的原因。

58
00:02:39,460 --> 00:02:43,830
但同样，用无符号整数可以表示的数值范围是

59
00:02:43,830 --> 00:02:48,240
至于 t 的常规整数，是 0 到 2 的 32 次方减 1、

60
00:02:48,240 --> 00:02:50,840
或约 0 至 40 亿。

61
00:02:50,840 --> 00:02:53,730
因此，您可以有效地将正向范围扩大了一倍、

62
00:02:53,730 --> 00:02:56,270
但你已经放弃了所有负值。

63
00:02:56,270 --> 00:03:00,040
&gt;&gt;旁白：无符号并不是唯一的限定符

64
00:03:00,040 --> 00:03:01,790
我们可能会看到变量数据类型。

65
00:03:01,790 --> 00:03:05,779
也有叫做短、长、常的东西。

66
00:03:05,779 --> 00:03:07,820
我们稍后会在课程中看到。

67
00:03:07,820 --> 00:03:10,830
无论长短，我们可能都不会。

68
00:03:10,830 --> 00:03:12,830
&gt;&gt;但要知道，还有其他的限制条件。

69
00:03:12,830 --> 00:03:14,080
Unsigned 并非唯一。

70
00:03:14,080 --> 00:03:16,596
但这是我们现在要讨论的唯一一个问题。

71
00:03:16,596 --> 00:03:17,310
那好吧

72
00:03:17,310 --> 00:03:18,393
因此，我们已经介绍了整数。

73
00:03:18,393 --> 00:03:19,200
下一步是什么？

74
00:03:19,200 --> 00:03:20,130
&gt;&gt; 字符。

75
00:03:20,130 --> 00:03:23,620
因此，chars 用于存储单字符的变量。

76
00:03:23,620 --> 00:03:24,850
Char 是字符的简称。

77
00:03:24,850 --> 00:03:27,870
有时你可能会听到有人把它念成汽车。

78
00:03:27,870 --> 00:03:32,020
因此，字符总是占用一个字节的内存，也就是 8 位。

79
00:03:32,020 --> 00:03:35,700
因此，这意味着它们只能适应负 2 范围内的数值。

80
00:03:35,700 --> 00:03:42,430
的七次方，即负 128，到 2 的七次方减 1，即 127。

81
00:03:42,430 --> 00:03:45,710
多亏了 ASCII，人们很早就确定了一种方法

82
00:03:45,710 --> 00:03:50,805
将 0 至 127 之间的正数映射为各种字符

83
00:03:50,805 --> 00:03:52,182
这些都存在于我们的键盘上。

84
00:03:52,182 --> 00:03:54,640
因此，正如我们稍后在课程中将看到的那样，你可能会

85
00:03:54,640 --> 00:03:57,700
例如，大写字母 A

86
00:03:57,700 --> 00:04:00,732
大写字母 A- 映射到数字 65。

87
00:04:00,732 --> 00:04:02,940
原因就在于，这就是它的本质。

88
00:04:02,940 --> 00:04:05,490
由 ASCII 标准指定。

89
00:04:05,490 --> 00:04:07,850
小写 A 是 97。

90
00:04:07,850 --> 00:04:11,900
实际键入字符时的字符 0，而不是

91
00:04:11,900 --> 00:04:13,532
代表数字 0，是 48。

92
00:04:13,532 --> 00:04:15,240
你会在学习的过程中学到一些东西。

93
00:04:15,240 --> 00:04:17,990
在 CS50 中，你肯定会需要它们。

94
00:04:20,450 --> 00:04:23,390
下一个主要数据类型是浮点数。

95
00:04:23,390 --> 00:04:26,100
因此，浮点数也被称为实数。

96
00:04:26,100 --> 00:04:28,850
它们基本上就是带有小数点的数字。

97
00:04:28,850 --> 00:04:33,360
像整数一样的浮点数值也是

98
00:04:33,360 --> 00:04:36,090
包含在 4 字节内存中。

99
00:04:36,090 --> 00:04:37,580
这里没有图表。

100
00:04:37,580 --> 00:04:40,890
没有数字线，因为要描述浮点数的范围

101
00:04:40,890 --> 00:04:44,550
并不十分清楚或直观。

102
00:04:44,550 --> 00:04:47,350
&gt;&gt;&gt;您只需使用 32 位即可。

103
00:04:47,350 --> 00:04:49,730
如果你有一个像圆周率这样的数字，它有

104
00:04:49,730 --> 00:04:55,510
整数部分 3，浮点部分或小数部分 0.14159、

105
00:04:55,510 --> 00:04:58,735
等等，你需要能够代表所有这些--

106
00:04:58,735 --> 00:05:02,420
整数部分和小数部分。

107
00:05:02,420 --> 00:05:04,550
你认为这意味着什么？

108
00:05:04,550 --> 00:05:08,180
有一点是，如果小数部分越来越长、

109
00:05:08,180 --> 00:05:10,660
如果我有一个非常大的整数部分，我可能不会

110
00:05:10,660 --> 00:05:13,090
能够对小数部分进行同样精确的计算。

111
00:05:13,090 --> 00:05:15,280
这就是浮筒的局限性。

112
00:05:15,280 --> 00:05:17,229
&gt;&gt;浮点有精度问题。

113
00:05:17,229 --> 00:05:19,270
我们只有 32 位可用，因此只能

114
00:05:19,270 --> 00:05:22,510
我们的小数部分要如此精确。

115
00:05:22,510 --> 00:05:27,300
小数部分不一定精确到 100 或 200 位、

116
00:05:27,300 --> 00:05:29,710
因为我们只有 32 位可用。

117
00:05:29,710 --> 00:05:31,590
这就是浮动的局限性。

118
00:05:31,590 --> 00:05:33,590
&gt;&gt;幸运的是，现在还有一种数据类型叫做

119
00:05:33,590 --> 00:05:36,530
双倍，在一定程度上解决了这个问题。

120
00:05:36,530 --> 00:05:39,980
双倍数和浮点数一样，也用于存储实数或浮点数。

121
00:05:39,980 --> 00:05:40,840
价值观

122
00:05:40,840 --> 00:05:44,340
区别在于，双倍是双精度的。

123
00:05:44,340 --> 00:05:48,177
它们可容纳 64 位数据或 8 个字节。

124
00:05:48,177 --> 00:05:49,010
这是什么意思？

125
00:05:49,010 --> 00:05:51,801
这意味着我们可以更精确地使用小数点。

126
00:05:51,801 --> 00:05:54,830
而不是用浮筒把 pi 装到七个地方、

127
00:05:54,830 --> 00:05:56,710
我们也许可以把它放到 30 个地方。

128
00:05:56,710 --> 00:05:59,824
如果这一点很重要，您可能需要使用 double 而不是 float。

129
00:05:59,824 --> 00:06:01,740
基本上，如果您正在处理任何事情，其中

130
00:06:01,740 --> 00:06:06,540
拥有很长的小数位数和很高的精度非常重要、

131
00:06:06,540 --> 00:06:08,630
你可能需要使用双 overfloat。

132
00:06:08,630 --> 00:06:11,250
对于 CS50 中的大部分工作来说，浮点运算就足够了。

133
00:06:11,250 --> 00:06:15,340
但要知道，双倍值的存在可以在一定程度上解决精确度问题。

134
00:06:15,340 --> 00:06:20,980
通过为你的数字提供额外的 32 位来解决这个问题。

135
00:06:20,980 --> 00:06:23,650
这不是一种数据类型。

136
00:06:23,650 --> 00:06:24,390
这是一种类型。

137
00:06:24,390 --> 00:06:25,340
这就是所谓的 "无效"。

138
00:06:25,340 --> 00:06:27,506
我在这里谈论它，是因为我们可能已经

139
00:06:27,506 --> 00:06:29,520
在 CS50 中已经见过几次了。

140
00:06:29,520 --> 00:06:32,020
你可能想知道这到底是怎么回事。

141
00:06:32,020 --> 00:06:33,390
所以 void 是一种类型。

142
00:06:33,390 --> 00:06:34,097
它确实存在。

143
00:06:34,097 --> 00:06:35,180
但它不是一种数据类型。

144
00:06:35,180 --> 00:06:39,350
&gt;&gt;我们不能创建 void 类型的变量并为其赋值。

145
00:06:39,350 --> 00:06:42,519
但例如，函数可以有 void 返回类型。

146
00:06:42,519 --> 00:06:45,060
基本上，如果你看到一个返回类型为 void 的函数、

147
00:06:45,060 --> 00:06:46,970
表示不返回值。

148
00:06:46,970 --> 00:06:49,440
你能想到我们迄今为止使用过的常用函数吗？

149
00:06:49,440 --> 00:06:52,780
在 CS50 中没有返回值？

150
00:06:52,780 --> 00:06:54,700
&gt;&gt; Printf 是一个。

151
00:06:54,700 --> 00:06:56,820
Printf 实际上不会返回任何内容。

152
00:06:56,820 --> 00:06:59,850
它会在屏幕上打印一些内容，基本上是

153
00:06:59,850 --> 00:07:01,650
printf 的副作用。

154
00:07:01,650 --> 00:07:03,620
但它不会给你带来价值回报。

155
00:07:03,620 --> 00:07:08,419
您不会捕获结果并将其存储到某个变量中，以便以后使用。

156
00:07:08,419 --> 00:07:10,710
它只需在屏幕上打印一些内容，然后就大功告成了。

157
00:07:10,710 --> 00:07:14,360
所以我们说 printf 是一个 void 函数。

158
00:07:14,360 --> 00:07:16,450
它什么也不返回。

159
00:07:16,450 --> 00:07:18,580
&gt;&gt;函数的周长列表也可以是无效的。

160
00:07:18,580 --> 00:07:21,410
你在 CS50 中也经常看到这种情况。

161
00:07:21,410 --> 00:07:22,300
Int main void.

162
00:07:22,300 --> 00:07:23,260
有印象吗？

163
00:07:24,080 --> 00:07:27,220
基本上，这意味着 main 不需要任何参数。

164
00:07:27,220 --> 00:07:29,520
没有参数传递给 main。

165
00:07:29,520 --> 00:07:32,780
稍后，我们将看到向 main 传递参数的方法、

166
00:07:32,780 --> 00:07:36,189
但到目前为止，我们看到的都是 int main void。

167
00:07:36,189 --> 00:07:37,730
梅因就是不接受任何辩解。

168
00:07:37,730 --> 00:07:40,236
因此，我们用 "无效 "来说明这一点。

169
00:07:40,236 --> 00:07:42,110
我们只是非常明确地告诉大家一个事实

170
00:07:42,110 --> 00:07:44,430
它不接受任何争论。

171
00:07:44,430 --> 00:07:47,160
因此，现在只需说明，基本上无效。

172
00:07:47,160 --> 00:07:50,789
应该只是作为一个占位符，让你什么都不用想。

173
00:07:50,789 --> 00:07:52,080
它其实什么也没做。

174
00:07:52,080 --> 00:07:53,550
这里没有返回值。

175
00:07:53,550 --> 00:07:54,770
这里没有参数。

176
00:07:54,770 --> 00:07:55,709
它是无效的。

177
00:07:55,709 --> 00:07:57,250
比这还要复杂一些。

178
00:07:57,250 --> 00:08:00,640
不过，这应该足以应付课程的大部分时间。

179
00:08:00,640 --> 00:08:05,010
希望你们现在对 "无效 "有了一些概念。

180
00:08:05,010 --> 00:08:08,460
&gt;&gt;&gt;因此，这就是 C 语言内置的五种类型。

181
00:08:08,460 --> 00:08:10,670
但在 CS50 中，我们还有一个图书馆。

182
00:08:10,670 --> 00:08:13,550
您可以将 CS50.h 包括在内。

183
00:08:13,550 --> 00:08:15,930
它将为您提供另外两种类型

184
00:08:15,930 --> 00:08:18,280
你可能会在作业中用到、

185
00:08:18,280 --> 00:08:21,210
或只是一般的编程工作。

186
00:08:21,210 --> 00:08:23,030
其中第一个是 bool。

187
00:08:23,030 --> 00:08:26,780
因此，变量使用布尔数据类型 bool

188
00:08:26,780 --> 00:08:28,114
将存储一个布尔值。

189
00:08:28,114 --> 00:08:29,863
如果您以前听说过这个词，那么您

190
00:08:29,863 --> 00:08:31,960
可能知道布尔值只能

191
00:08:31,960 --> 00:08:34,440
持有两个不同的值。

192
00:08:34,440 --> 00:08:35,872
真与假

193
00:08:35,871 --> 00:08:37,580
现在看来，这是非常基本的，对吗？

194
00:08:37,580 --> 00:08:40,496
令人惊讶的是，C 语言中并不存在这种内置功能。

195
00:08:40,496 --> 00:08:42,640
当然，在许多现代语言中，布尔

196
00:08:42,640 --> 00:08:45,390
是一种标准的默认数据类型。

197
00:08:45,390 --> 00:08:47,192
但在 C 语言中，它们其实不是。

198
00:08:47,192 --> 00:08:48,400
但我们已经为您创建了它。

199
00:08:48,400 --> 00:08:51,910
因此，如果您需要创建一个类型为 bool 的变量、

200
00:08:51,910 --> 00:08:55,230
只需确保在程序开头 #include CS50.h、

201
00:08:55,230 --> 00:08:57,800
就可以创建 bool 类型的变量。

202
00:08:57,800 --> 00:09:02,095
&gt;&gt; 如果忘记 #include CS50.h，并开始使用布尔类型变量、

203
00:09:02,095 --> 00:09:04,970
在编译程序时可能会遇到一些问题。

204
00:09:04,970 --> 00:09:06,490
所以，你要多加留意。

205
00:09:06,490 --> 00:09:11,180
也许你只需将 CS50.h 包括在内，就能解决这些问题。

206
00:09:11,180 --> 00:09:14,590
&gt;&gt;我们在 CS50 库中为您提供的其他主要数据类型

207
00:09:14,590 --> 00:09:15,670
是字符串。

208
00:09:15,670 --> 00:09:17,130
那么什么是字符串呢？

209
00:09:17,130 --> 00:09:18,520
字符串其实就是文字。

210
00:09:18,520 --> 00:09:20,000
它们是人物的集合。

211
00:09:20,000 --> 00:09:20,640
它们是文字。

212
00:09:20,640 --> 00:09:21,390
它们是句子。

213
00:09:21,390 --> 00:09:22,480
它们是段落。

214
00:09:22,480 --> 00:09:25,850
甚至可能是整本书。

215
00:09:25,850 --> 00:09:29,690
&gt;&gt;从很短到很长的一系列字符。

216
00:09:29,690 --> 00:09:34,310
例如，如果需要使用字符串来存储一个单词、

217
00:09:34,310 --> 00:09:37,609
只需确保在程序开头包含 CS50.h

218
00:09:37,609 --> 00:09:38,900
因此可以使用字符串类型。

219
00:09:38,900 --> 00:09:43,910
然后就可以创建数据类型为字符串的变量。

220
00:09:43,910 --> 00:09:46,160
在稍后的课程中，我们还将看到，这是

221
00:09:46,160 --> 00:09:47,752
也不是故事的全部。

222
00:09:47,752 --> 00:09:49,460
我们会遇到一种叫做结构的东西、

223
00:09:49,460 --> 00:09:54,249
可以将整数和字符串组合成一个单元。

224
00:09:54,249 --> 00:09:56,290
我们可以将其用于某些目的，这些目的可能是

225
00:09:56,290 --> 00:09:57,750
在以后的课程中会派上用场。

226
00:09:57,750 --> 00:09:59,500
&gt;&gt;我们还将学习定义的类型、

227
00:09:59,500 --> 00:10:01,720
可以创建自己的数据类型。

228
00:10:01,720 --> 00:10:03,060
我们暂时不需要担心这个问题。

229
00:10:03,060 --> 00:10:04,550
但你要知道，那是地平线上的事情、

230
00:10:04,550 --> 00:10:07,633
这整个类型的事情比我告诉你的要多得多。

231
00:10:07,633 --> 00:10:08,133
现在

232
00:10:08,133 --> 00:10:10,591
现在，我们已经对基本数据有了一些了解

233
00:10:10,591 --> 00:10:14,230
类型和 CS50 数据类型，让我们来谈谈如何使用变量

234
00:10:14,230 --> 00:10:18,530
并在程序中使用这些数据类型创建它们。

235
00:10:18,530 --> 00:10:22,670
如果要创建一个变量，只需做两件事。

236
00:10:22,670 --> 00:10:24,147
&gt;&gt;&gt;首先，你需要给它一个类型。

237
00:10:24,147 --> 00:10:26,230
你需要做的第二件事就是给它取个名字。

238
00:10:26,230 --> 00:10:28,740
完成后，在该行末尾加上分号、

239
00:10:28,740 --> 00:10:29,830
你已经创建了一个变量。

240
00:10:29,830 --> 00:10:32,370
&gt;&gt;这里有两个例子。

241
00:10:32,370 --> 00:10:35,744
Int number; char letter;.

242
00:10:35,744 --> 00:10:36,660
我在这里做了什么？

243
00:10:36,660 --> 00:10:38,110
我创建了两个变量。

244
00:10:38,110 --> 00:10:40,190
&gt;&gt;首先，变量的名称是数字。

245
00:10:40,190 --> 00:10:44,830
而 number 可以保存整数类型的值，因为它的类型是 int。

246
00:10:44,830 --> 00:10:48,040
字母是另一个可以保存字符的变量

247
00:10:48,040 --> 00:10:50,240
因为其数据类型为 char。

248
00:10:50,240 --> 00:10:51,772
&gt;&gt;很简单，对吗？

249
00:10:51,772 --> 00:10:53,480
如果您遇到以下情况

250
00:10:53,480 --> 00:10:56,250
您需要创建多个相同类型的变量、

251
00:10:56,250 --> 00:10:58,740
您只需指定一次类型名称。

252
00:10:58,740 --> 00:11:01,600
然后根据需要尽可能多地列出该类型的变量。

253
00:11:01,600 --> 00:11:04,230
例如，我可以在第三行代码中这样做、

254
00:11:04,230 --> 00:11:07,420
say int height;, new line.

255
00:11:07,420 --> 00:11:08,291
Int width;.

256
00:11:08,291 --> 00:11:09,290
这样也行得通。

257
00:11:09,290 --> 00:11:12,039
我仍然会得到两个名为 height 和 width 的变量，其中每个变量

258
00:11:12,039 --> 00:11:12,730
是一个整数。

259
00:11:12,730 --> 00:11:16,970
但我可以用 C 语言语法将其合并为一行。

260
00:11:16,970 --> 00:11:20,230
Int height, width; 这是同一件事。

261
00:11:20,230 --> 00:11:23,900
我创建了两个变量，一个叫高度，一个叫宽度，这两个变量都是

262
00:11:23,900 --> 00:11:26,730
能保存整数类型的值。

263
00:11:26,730 --> 00:11:30,920
&gt;&gt;在这里，我可以同时创建三个浮点数值。

264
00:11:30,920 --> 00:11:33,350
我也许可以创建一个名为 2 的平方根的变量 --

265
00:11:33,350 --> 00:11:35,766
最终可能会保存浮点数

266
00:11:35,766 --> 00:11:39,222
即 2 的平方根--3 的平方根和圆周率。

267
00:11:39,222 --> 00:11:41,180
我本可以分三行来做这件事。

268
00:11:41,180 --> 00:11:47,690
浮点数平方根 2；浮点数平方根 3；浮点数 pi；这样也行得通。

269
00:11:47,690 --> 00:11:50,590
&gt;&gt;但同样，我可以将其合并为一行代码。

270
00:11:50,590 --> 00:11:54,050
让事情变得更简短，不那么笨重。

271
00:11:54,050 --> 00:11:57,259
&gt;&gt;&gt;一般来说，只有在需要时声明变量才是好的设计。

272
00:11:57,259 --> 00:11:59,050
我们还将进一步讨论这个问题

273
00:11:59,050 --> 00:12:00,945
我们将在课程的稍后部分讨论范围问题。

274
00:12:00,945 --> 00:12:03,320
因此，不一定需要创建所有变量

275
00:12:03,320 --> 00:12:05,990
在计划开始时，有些人可能会这样做、

276
00:12:05,990 --> 00:12:08,700
多年前，这无疑是一种非常普遍的编码做法

277
00:12:08,700 --> 00:12:11,700
在使用 C 语言时，您可能只是想在

278
00:12:11,700 --> 00:12:13,140
你需要它。

279
00:12:13,140 --> 00:12:13,640
好吧

280
00:12:13,640 --> 00:12:15,150
因此，我们创建了变量。

281
00:12:15,150 --> 00:12:16,790
我们如何使用它们？

282
00:12:16,790 --> 00:12:18,650
声明变量后，我们不需要

283
00:12:18,650 --> 00:12:21,237
来指定该变量的数据类型。

284
00:12:21,237 --> 00:12:24,070
事实上，如果你这样做，可能会产生一些奇怪的后果

285
00:12:24,070 --> 00:12:25,490
我们暂且一笔带过。

286
00:12:25,490 --> 00:12:27,365
但可以肯定的是，奇怪的事情正在发生

287
00:12:27,365 --> 00:12:30,740
如果你无意中重新声明了同名变量

288
00:12:30,740 --> 00:12:32,210
一遍又一遍。

289
00:12:32,210 --> 00:12:33,882
因此，我这里有四行代码。

290
00:12:33,882 --> 00:12:36,090
我有几点意见，仅供参考

291
00:12:36,090 --> 00:12:37,840
每一行发生了什么，只是为了帮助

292
00:12:37,840 --> 00:12:40,520
你就会知道发生了什么。

293
00:12:40,520 --> 00:12:41,520
所以 int number;.

294
00:12:41,520 --> 00:12:42,520
你之前也看到了。

295
00:12:42,520 --> 00:12:44,000
这是一个变量声明。

296
00:12:44,000 --> 00:12:46,670
&gt;&gt;我现在创建了一个名为 "数字 "的变量。

297
00:12:46,670 --> 00:12:48,970
能够保存整数类型的值。

298
00:12:48,970 --> 00:12:50,210
我已经宣布了。

299
00:12:50,210 --> 00:12:53,770
&gt;&gt;下一行我将为数字赋值。

300
00:12:53,770 --> 00:12:54,992
数字等于 17。

301
00:12:54,992 --> 00:12:55,950
那里发生了什么？

302
00:12:55,950 --> 00:12:58,880
我将数字 17 放入变量中。

303
00:12:58,880 --> 00:13:02,760
因此，如果我稍后打印出数字的内容、

304
00:13:02,760 --> 00:13:04,030
他们会告诉我是17号

305
00:13:04,030 --> 00:13:07,030
因此，我声明了一个变量，然后进行了赋值。

306
00:13:07,030 --> 00:13:10,570
&gt;&gt;我们可以用字母;再次重复这个过程。

307
00:13:10,570 --> 00:13:11,640
这是一个宣言。

308
00:13:11,640 --> 00:13:14,010
字母等于大写字母 H，这是一项任务。

309
00:13:14,010 --> 00:13:16,030
也很简单明了。

310
00:13:16,030 --> 00:13:18,319
这个过程可能看起来有点傻。

311
00:13:18,319 --> 00:13:20,110
为什么我们只用两行代码就能做到这一点？

312
00:13:20,110 --> 00:13:21,401
有没有更好的办法？

313
00:13:21,401 --> 00:13:22,250
事实上，是有的。

314
00:13:22,250 --> 00:13:24,375
有时你可能会看到这种情况，称为初始化。

315
00:13:24,375 --> 00:13:28,446
就是在声明变量的同时赋值。

316
00:13:28,446 --> 00:13:30,320
这其实是一件很常见的事情。

317
00:13:30,320 --> 00:13:32,870
创建变量时，通常希望它有一些基本值。

318
00:13:32,870 --> 00:13:34,330
哪怕是 0 什么的。

319
00:13:34,330 --> 00:13:36,180
你只需给它一个值。

320
00:13:36,180 --> 00:13:38,360
您可以初始化变量。

321
00:13:38,360 --> 00:13:42,320
Int 数等于 17 与上面的前两行代码相同。

322
00:13:42,320 --> 00:13:46,829
字符字母等于 h 与上述第三行和第四行代码相同。

323
00:13:46,829 --> 00:13:49,620
当我们声明和分配时，最重要的一点是

324
00:13:49,620 --> 00:13:51,740
变量后，请注意

325
00:13:51,740 --> 00:13:53,700
我不会再使用这种数据类型了。

326
00:13:53,700 --> 00:13:57,916
例如，我并不是说第二行代码中的 int 数字等于 17。

327
00:13:57,916 --> 00:13:59,290
我只是说数字等于 17。

328
00:13:59,290 --> 00:14:02,537
&gt;&gt;&gt;同样，在已声明变量后重新声明它可能会导致

329
00:14:02,537 --> 00:14:03,620
到一些奇怪的后果。

330
00:14:03,620 --> 00:14:05,950
所以一定要小心。

331
00:14:05,950 --> 00:14:06,660
我是道格-劳埃德

332
00:14:06,660 --> 00:14:08,870
这是 CS50。

