0
00:00:00,000 --> 00:00:02,988
[开始播放]

1
00:00:02,988 --> 00:00:05,976
[音乐响起]

2
00:00:05,976 --> 00:01:13,350


3
00:01:13,350 --> 00:01:16,090
戴维-J-马兰：好的，这是 CS50。

4
00:01:16,090 --> 00:01:19,090
这是第一周，我们继续编程、

5
00:01:19,090 --> 00:01:22,420
但我们用不同的语言来做，因为回顾上一次，我们

6
00:01:22,420 --> 00:01:25,060
重点是这种名为 Scratch 的图形语言。

7
00:01:25,060 --> 00:01:28,360
但我们使用 Scratch，不仅是因为它好玩，而且容易上手、

8
00:01:28,360 --> 00:01:31,750
而是因为它能让我们在这里探讨很多这些概念、

9
00:01:31,750 --> 00:01:35,810
即函数、条件式、布尔表达式、循环、变量、

10
00:01:35,810 --> 00:01:36,410
以及更多。

11
00:01:36,410 --> 00:01:41,050
因此，即使今天的语法，当我们过渡到这种新语言时

12
00:01:41,050 --> 00:01:44,980
叫 C，感觉有点隐晦，一开始可能有点吓人、

13
00:01:44,980 --> 00:01:48,040
你不太明白这些符号的全部含义

14
00:01:48,040 --> 00:01:51,310
超越语法本身，认识到思想归根结底是

15
00:01:51,310 --> 00:01:52,670
会是一样的。

16
00:01:52,670 --> 00:01:55,870
事实上，随着我们从上周的

17
00:01:55,870 --> 00:02:00,017
本周，他编写了一个 "Hello World "程序，看起来有点像这样、

18
00:02:00,017 --> 00:02:02,350
当然，现在看起来会更隐晦一些。

19
00:02:02,350 --> 00:02:04,350
看起来会有点像这样。

20
00:02:04,350 --> 00:02:06,370
现在，即使你不能完全分辨出

21
00:02:06,370 --> 00:02:08,479
代码中各种符号的含义、

22
00:02:08,479 --> 00:02:10,120
原来，归根结底是

23
00:02:10,120 --> 00:02:11,578
的确会如你所愿。

24
00:02:11,578 --> 00:02:14,170
屏幕上只会显示 "你好，世界"、

25
00:02:14,170 --> 00:02:15,370
就像我们在 Scratch 中做的那样。

26
00:02:15,370 --> 00:02:19,610
因此，让我们先来应用一些术语来解释这些代币。

27
00:02:19,610 --> 00:02:22,332
因此，我们将要看到的，也就是我们今后要写的、

28
00:02:22,332 --> 00:02:24,040
我们将开始调用源代码。

29
00:02:24,040 --> 00:02:27,908
人类程序员编写的代码从此被称为源代码。

30
00:02:27,908 --> 00:02:29,200
是否是 Scratch 并不重要。

31
00:02:29,200 --> 00:02:32,370
就算是 C 语言也没关系，就算是 Python 也没关系。

32
00:02:32,370 --> 00:02:34,120
源代码是真正

33
00:02:34,120 --> 00:02:37,330
作为人类程序员的你和我最终将写出什么。

34
00:02:37,330 --> 00:02:42,190
当然，事实证明，计算机并不理解源代码。

35
00:02:42,190 --> 00:02:46,200
计算机本身不理解 Scratch 和拼图，也不理解 C 代码

36
00:02:46,200 --> 00:02:47,200
就像我们即将看到的那样

37
00:02:47,200 --> 00:02:49,870
他们只懂这个，我们上周称之为什么？

38
00:02:49,870 --> 00:02:50,650
听众：零和一

39
00:02:50,650 --> 00:02:51,525
是的。

40
00:02:51,525 --> 00:02:53,080
所以这是二进制，0 和 1。

41
00:02:53,080 --> 00:02:56,470
但实际上，它只是用二进制表示的信息。

42
00:02:56,470 --> 00:03:00,370
事实上，现在的技术术语是指 0 和 1 的模式

43
00:03:00,370 --> 00:03:04,810
计算机不仅懂得如何将其解释为字母或数字、

44
00:03:04,810 --> 00:03:09,520
或颜色，或图像，或更多，但知道如何执行，以及从今以后

45
00:03:09,520 --> 00:03:12,880
将被称为机器码，以便与源代码形成对比。

46
00:03:12,880 --> 00:03:15,160
因此，你和我，人类，编写源代码、

47
00:03:15,160 --> 00:03:18,860
计算机最终只能理解机器码。

48
00:03:18,860 --> 00:03:21,940
尽管我们不会详细讨论到底是什么模式

49
00:03:21,940 --> 00:03:27,010
你会发现，在这种 "零 "的模式中

50
00:03:27,010 --> 00:03:28,600
和一，就会有数字。

51
00:03:28,600 --> 00:03:29,530
会有信的。

52
00:03:29,530 --> 00:03:32,200
但也会有指示，因为计算机

53
00:03:32,200 --> 00:03:35,140
非常擅长做事情--加法、减法、搬东西

54
00:03:35,140 --> 00:03:36,430
进出内存

55
00:03:36,430 --> 00:03:40,720
可以说，Mac、PC 和世界上的其他电脑

56
00:03:40,720 --> 00:03:44,740
作为一个社会，我们刚刚决定了某些零和一的模式

57
00:03:44,740 --> 00:03:48,220
是指在操作方面也是如此，所以不仅仅是数据、

58
00:03:48,220 --> 00:03:49,200
但有说明。

59
00:03:49,200 --> 00:03:50,950
但这些模式并不是我们

60
00:03:50,950 --> 00:03:52,575
要在这样的课堂上重点讲解。

61
00:03:52,575 --> 00:03:55,450
我们将重点关注更高层次的软件方面、

62
00:03:55,450 --> 00:03:58,910
只是假设我们需要以某种方式输出机器代码。

63
00:03:58,910 --> 00:04:02,050
那么，事实证明，这个问题我们

64
00:04:02,050 --> 00:04:04,300
必须解决从源代码到机器代码的问题

65
00:04:04,300 --> 00:04:07,120
实际上与上次的范式相同。

66
00:04:07,120 --> 00:04:11,230
但在这种情况下，一方面输入的将是源代码。

67
00:04:11,230 --> 00:04:13,750
这就是你我理想中的写作，以便我们

68
00:04:13,750 --> 00:04:15,430
不用写 0 和 1。

69
00:04:15,430 --> 00:04:18,140
但我们需要以某种方式输出机器码

70
00:04:18,140 --> 00:04:19,990
因为您的 Mac、PC 和手机

71
00:04:19,990 --> 00:04:21,730
是真正会理解的。

72
00:04:21,730 --> 00:04:25,390
原来，生活中有一些特殊的程序，它们的目的是

73
00:04:25,390 --> 00:04:28,690
进行这样的转换--将您的源代码转换为

74
00:04:28,690 --> 00:04:32,320
我写的是我们的手机和电脑能理解的机器代码。

75
00:04:32,320 --> 00:04:36,050
这种程序被称为编译器。

76
00:04:36,050 --> 00:04:39,400
因此，今天我们将向您介绍另一款软件。

77
00:04:39,400 --> 00:04:40,810
它们有多种形式。

78
00:04:40,810 --> 00:04:45,580
我们将在这里使用一个常用的程序，它允许您转换 C 语言的源代码

79
00:04:45,580 --> 00:04:48,805
以 0 和 1 的形式转换为机器码。

80
00:04:48,805 --> 00:04:50,680
在使用 Scratch 时，你不必这样做。

81
00:04:50,680 --> 00:04:53,513
在 Scratch 的世界里，这就像点击绿旗一样简单

82
00:04:53,513 --> 00:04:57,280
因为从根本上说，麻省理工学院做了所有繁重的工作，找出了

83
00:04:57,280 --> 00:05:00,760
如何将这些图形拼图转换为底层机器代码。

84
00:05:00,760 --> 00:05:04,420
但从今天开始，当我们开始学习编程和计算机科学时

85
00:05:04,420 --> 00:05:06,550
好了，现在权力移交给你了。

86
00:05:06,550 --> 00:05:09,340
现在就看你如何完成这种转换了。

87
00:05:09,340 --> 00:05:12,160
但值得庆幸的是，这些编译器的存在

88
00:05:12,160 --> 00:05:14,320
也就是说，你和我都不需要编程

89
00:05:14,320 --> 00:05:17,500
就像我们的祖先曾经做过的那样，使用机器代码、

90
00:05:17,500 --> 00:05:19,973
无论是虚拟还是实体打卡机、

91
00:05:19,973 --> 00:05:21,640
就像有洞的纸片。

92
00:05:21,640 --> 00:05:25,810
你和我可以专注于我们的键盘。

93
00:05:25,810 --> 00:05:29,370
但今天，这不仅仅是编写代码的问题。

94
00:05:29,370 --> 00:05:31,120
这最终将取决于今天

95
00:05:31,120 --> 00:05:32,930
写出好的代码。

96
00:05:32,930 --> 00:05:35,180
这种东西不是一朝一夕就能学会的。

97
00:05:35,180 --> 00:05:35,870
这需要时间。

98
00:05:35,870 --> 00:05:36,620
这需要练习。

99
00:05:36,620 --> 00:05:38,650
就像写文章一样

100
00:05:38,650 --> 00:05:41,050
这可能需要时间、实践和反复推敲。

101
00:05:41,050 --> 00:05:44,020
但在 CS50 这样的编程课上，我们

102
00:05:44,020 --> 00:05:48,820
我们希望按照这三个轴来评估代码的质量、

103
00:05:48,820 --> 00:05:49,360
一般来说

104
00:05:49,360 --> 00:05:51,040
首先，它是否正确？

105
00:05:51,040 --> 00:05:52,810
代码是否做了它应该做的事情？

106
00:05:52,810 --> 00:05:54,460
毕竟，如果不这样做，那又有什么意义呢？

107
00:05:54,460 --> 00:05:55,835
写这本书的初衷？

108
00:05:55,835 --> 00:05:59,350
因此，不言而喻，您希望自己编写的代码是正确的。

109
00:05:59,350 --> 00:06:00,820
但显然并非总是如此。

110
00:06:00,820 --> 00:06:03,340
同样，无论何时，您的 Mac、PC 或手机都会崩溃、

111
00:06:03,340 --> 00:06:05,560
某个人写的 buggy --

112
00:06:05,560 --> 00:06:07,030
是有错误的代码。

113
00:06:07,030 --> 00:06:10,060
但代码的正确性将是首要目标。

114
00:06:10,060 --> 00:06:13,930
但还有一个更主观的目标，那就是时间，一个设计的问题。

115
00:06:13,930 --> 00:06:16,030
上周，我们看到了一点这样的情况

116
00:06:16,030 --> 00:06:19,510
当我提出我们可以更好地设计划痕程序时、

117
00:06:19,510 --> 00:06:22,510
也许可以使用循环，而不只是复制和粘贴

118
00:06:22,510 --> 00:06:24,170
一次又一次地重复同样的区块。

119
00:06:24,170 --> 00:06:26,080
因此，设计更加主观。

120
00:06:26,080 --> 00:06:29,830
这更像是一门学问，两个人最终可能会

121
00:06:29,830 --> 00:06:32,882
对于哪个版本的程序设计得更好，存在不同意见。

122
00:06:32,882 --> 00:06:35,840
但是，我们将在未来几周内为您提供构建模块和原则

123
00:06:35,840 --> 00:06:37,840
以便您能更好地了解自己

124
00:06:37,840 --> 00:06:40,090
如果你自己的代码设计得很好的话。

125
00:06:40,090 --> 00:06:41,530
这又有什么价值呢？

126
00:06:41,530 --> 00:06:44,980
代码设计得越好，运行速度往往就越快、

127
00:06:44,980 --> 00:06:47,438
您或同事就越能维护它

128
00:06:47,438 --> 00:06:49,438
如果你在现实世界中与他人合作。

129
00:06:49,438 --> 00:06:50,900
因此，好的设计是一件好事。

130
00:06:50,900 --> 00:06:54,490
它可以帮助你传达自己的想法，就像在典型的英语作文中一样。

131
00:06:54,490 --> 00:06:57,523
最后，我们将从本周开始讨论风格问题。

132
00:06:57,523 --> 00:06:59,690
这其实只是代码的美学问题。

133
00:06:59,690 --> 00:07:04,720
事实证明，计算机往往不会在意你的实际代码有多草率、

134
00:07:04,720 --> 00:07:08,920
在代码的世界里，你并不真正需要

135
00:07:08,920 --> 00:07:10,750
以漂亮的方式缩进东西。

136
00:07:10,750 --> 00:07:13,150
在文章中不需要像这样分页。

137
00:07:13,150 --> 00:07:16,390
计算机一般不会在意，但人类会在意。

138
00:07:16,390 --> 00:07:17,817
助教是这样做的。

139
00:07:17,817 --> 00:07:19,900
第二天，当你只是想

140
00:07:19,900 --> 00:07:21,560
以了解代码的作用。

141
00:07:21,560 --> 00:07:24,520
因此，我们最后将重点关注代码的风格和美感

142
00:07:24,520 --> 00:07:25,520
你正在写的东西。

143
00:07:25,520 --> 00:07:27,280
那么，我们要在哪里编写代码呢？

144
00:07:27,280 --> 00:07:28,940
我们要在哪里编译代码？

145
00:07:28,940 --> 00:07:32,770
因此，对于这门课来说，不仅是 C 语言，还有我们以后使用的其他语言

146
00:07:32,770 --> 00:07:35,140
中，我们将使用一个自由文本

147
00:07:35,140 --> 00:07:39,280
该编辑器是一个名为 Visual Studio Code（又名 VS Code）的程序。

148
00:07:39,280 --> 00:07:43,450
如今，它超级流行，不仅适用于 C 语言，也适用于 C++ 和 Python、

149
00:07:43,450 --> 00:07:45,970
和 Java 以及其他语言。

150
00:07:45,970 --> 00:07:49,270
它是一个文本编辑器，可以编辑文本。

151
00:07:49,270 --> 00:07:52,150
这就是代码的全部内容。

152
00:07:52,150 --> 00:07:54,907
现在，严格来说，你可以在纸上/笔上写代码。

153
00:07:54,907 --> 00:07:56,740
事实上，在高中时，如果你选了一门课、

154
00:07:56,740 --> 00:07:59,532
你可能已经做过一次或多次这样的课堂练习。

155
00:07:59,532 --> 00:08:02,532
当然，你不能把它写在纸上，但你可以把它写出来。

156
00:08:02,532 --> 00:08:04,570
您可以使用 Microsoft Word 等软件、

157
00:08:04,570 --> 00:08:07,240
或 Notepad.exe，或 Mac 上的 Text Edit。

158
00:08:07,240 --> 00:08:09,340
但这些计划都不是真正为了

159
00:08:09,340 --> 00:08:12,190
以最适合您的方式格式化代码、

160
00:08:12,190 --> 00:08:15,250
它们也不是为了让你编译和运行代码而设计的。

161
00:08:15,250 --> 00:08:19,120
因此，VS Code 将成为一个工具，您可以通过它完成所有这些工作。

162
00:08:19,120 --> 00:08:22,240
等等--编写代码、编译代码、运行代码。

163
00:08:22,240 --> 00:08:25,630
这样，你们就不必与愚蠢的技术支持人员搏斗了

164
00:08:25,630 --> 00:08:29,110
在课程开始时，安装该软件会让人头疼，而且

165
00:08:29,110 --> 00:08:33,070
在您的 Mac 或 PC 上，我们将使用云端版本的 VS Code

166
00:08:33,070 --> 00:08:34,780
在 code.cs50.io.

167
00:08:34,780 --> 00:08:36,580
这将是完全相同的工具。

168
00:08:36,580 --> 00:08:38,860
我们的目标是在学期结束前

169
00:08:38,860 --> 00:08:43,240
将您从云环境迁移到您自己的 Mac 和 PC 上

170
00:08:43,240 --> 00:08:46,090
这样，即使 CS50 是你唯一的一门 CS 课程，你也能轻松上完、

171
00:08:46,090 --> 00:08:50,290
在课后使用

172
00:08:50,290 --> 00:08:54,010
甚至不是 CS50 特有的东西，而是一个事实上的行业

173
00:08:54,010 --> 00:08:55,760
标准，至少在一段时间内是这样。

174
00:08:55,760 --> 00:08:59,020
那么，VS Code 程序在 Mac 上会是什么样子呢？

175
00:08:59,020 --> 00:09:00,990
个人电脑，还是最初的浏览器？

176
00:09:00,990 --> 00:09:02,990
看起来会有点像这样。

177
00:09:02,990 --> 00:09:05,657
屏幕上会有几个不同的区域。

178
00:09:05,657 --> 00:09:07,450
图中的代码正是我

179
00:09:07,450 --> 00:09:10,335
继续提议使用 C 语言编写最简单的程序。

180
00:09:10,335 --> 00:09:12,460
屏幕上的这些不同区域是什么？

181
00:09:12,460 --> 00:09:15,440
那么，这里基本上有这四个。

182
00:09:15,440 --> 00:09:19,660
首先，顶部会突出显示一个或多个选项卡，其中

183
00:09:19,660 --> 00:09:21,160
你要真正写代码。

184
00:09:21,160 --> 00:09:23,230
就像在 Google 文档或 Microsoft Word 中一样、

185
00:09:23,230 --> 00:09:24,940
你可以打开带有文件的标签页。

186
00:09:24,940 --> 00:09:28,330
同样，在 VS Code 或任何编程环境中也是如此。

187
00:09:28,330 --> 00:09:30,830
现在一般都有某种标签。

188
00:09:30,830 --> 00:09:34,480
这将是一个标签页，其中包含一个名为 hello.c 的文件。

189
00:09:34,480 --> 00:09:38,020
这将是我们马上要写的第一个文件。

190
00:09:38,020 --> 00:09:40,720
不过，下面将是一个界面，你们中的许多人

191
00:09:40,720 --> 00:09:41,920
可能不知道。

192
00:09:41,920 --> 00:09:44,170
这就是所谓的终端窗口。

193
00:09:44,170 --> 00:09:47,920
而终端窗口提供的一般称为命令行

194
00:09:47,920 --> 00:09:49,720
界面，或 CLI。

195
00:09:49,720 --> 00:09:53,680
这与图形用户界面（GUI）形成鲜明对比。

196
00:09:53,680 --> 00:09:57,760
现在，你我每天都在使用手机和电脑上的图形用户界面。

197
00:09:57,760 --> 00:10:01,420
图形用户界面是图形化的，包括菜单、按钮和图标。

198
00:10:01,420 --> 00:10:04,060
您一般使用手指或触控板

199
00:10:04,060 --> 00:10:06,380
或鼠标之类的东西进行交互。

200
00:10:06,380 --> 00:10:08,410
但事实证明，许多程序员--他们

201
00:10:08,410 --> 00:10:11,770
大多数程序员，至少随着时间的推移，会更喜欢这种说法、

202
00:10:11,770 --> 00:10:14,620
不是图形用户界面，而是 CLI，即命令行界面

203
00:10:14,620 --> 00:10:20,650
在这里，你只需通过键盘就能完成所有复杂的操作。

204
00:10:20,650 --> 00:10:21,250
为什么？

205
00:10:21,250 --> 00:10:24,610
事实证明，大多数计算机都内置了更多的功能

206
00:10:24,610 --> 00:10:26,260
如果您可以用键盘访问它们。

207
00:10:26,260 --> 00:10:29,530
事实证明，我们大多数人的打字速度都比你的点击速度快。

208
00:10:29,530 --> 00:10:32,330
因此，随着时间的推移，最终会提高效率。

209
00:10:32,330 --> 00:10:35,140
那么，假以时日，您是否能自如地使用这个终端呢？

210
00:10:35,140 --> 00:10:39,370
窗口来做一些事情，比如编译你的代码或使你的程序

211
00:10:39,370 --> 00:10:40,390
以及运行它。

212
00:10:40,390 --> 00:10:43,810
因此，你最初不会养成只双击图标的习惯

213
00:10:43,810 --> 00:10:45,800
就像我们在典型的现实世界中一样。

214
00:10:45,800 --> 00:10:47,890
你要按照程序员的方式来做。

215
00:10:47,890 --> 00:10:51,820
但这并不排斥添加图标、点击性等。

216
00:10:51,820 --> 00:10:53,950
在 VS 代码的左侧，有

217
00:10:53,950 --> 00:10:56,920
将是一个有点熟悉的文件资源管理器、

218
00:10:56,920 --> 00:11:00,040
某种分层树形结构，就像在 Mac 或 PC 上，你可以

219
00:11:00,040 --> 00:11:02,110
查看账户中的所有文件。

220
00:11:02,110 --> 00:11:04,390
例如，这里展示的只是 hello.c、

221
00:11:04,390 --> 00:11:06,140
稍后我将亲自制作。

222
00:11:06,140 --> 00:11:09,343
左侧远处是所谓的 "活动栏"、

223
00:11:09,343 --> 00:11:12,260
在这里，你会看到很多传统的菜单和按钮。

224
00:11:12,260 --> 00:11:16,250
因此，VS Code 本身同时提供了图形用户界面和 CLI。

225
00:11:16,250 --> 00:11:19,958
但它是在 CLI、终端窗口、屏幕底部区域内运行的

226
00:11:19,958 --> 00:11:22,250
我们实际上要键入的大部分命令。

227
00:11:22,250 --> 00:11:25,417
一般来说，在课堂上，我会隐藏所有图形化的东西。

228
00:11:25,417 --> 00:11:28,380
只是兴趣不大而已。

229
00:11:28,380 --> 00:11:30,710
说到这里，让我换个话题

230
00:11:30,710 --> 00:11:32,878
到 VS Code 的实时版本。

231
00:11:32,878 --> 00:11:34,670
我确实把它藏在了 "活动栏 "里。

232
00:11:34,670 --> 00:11:36,470
我确实隐藏了文件资源管理器。

233
00:11:36,470 --> 00:11:39,380
因此，为了便于查看，我这里有一个非常大的区域

234
00:11:39,380 --> 00:11:42,840
用于编写代码，底部是一个非常大的终端窗口。

235
00:11:42,840 --> 00:11:45,260
你会看到终端窗口中有一个美元符号。

236
00:11:45,260 --> 00:11:47,160
这并不意味着任何形式的货币。

237
00:11:47,160 --> 00:11:51,230
这只是表示类型命令的标准符号。

238
00:11:51,230 --> 00:11:53,480
因此，事实上只有美元符号和光标

239
00:11:53,480 --> 00:11:55,490
这意味着，我最终要在这里输入命令。

240
00:11:55,490 --> 00:11:58,020
但首先，我要实际创建一些代码。

241
00:11:58,020 --> 00:12:02,900
那么，我如何使用 VS Code 编程呢？

242
00:12:02,900 --> 00:12:07,160
或在这个基于云的环境中，你会得到设置的问题集 1 --

243
00:12:07,160 --> 00:12:08,870
如何编写我的第一份文件？

244
00:12:08,870 --> 00:12:10,610
那么，也许最简单的方法就是这样。

245
00:12:10,610 --> 00:12:14,090
按字面意思运行命令代码，然后运行文件名

246
00:12:14,090 --> 00:12:15,200
你想创建的

247
00:12:15,200 --> 00:12:18,838
请注意，我特意用小写的 .c 结尾。

248
00:12:18,838 --> 00:12:21,380
请注意，我特意将整个文件名用小写字母标出。

249
00:12:21,380 --> 00:12:22,672
而这些只是惯例。

250
00:12:22,672 --> 00:12:24,140
你可以用大写字母 "H"。

251
00:12:24,140 --> 00:12:27,260
你可以用大写的 C，但千万别这么做。

252
00:12:27,260 --> 00:12:30,260
遵循最佳做法，以便与大多数人的做法保持一致

253
00:12:30,260 --> 00:12:31,100
其他的人也会这么做。

254
00:12:31,100 --> 00:12:33,770
当我按下回车键时，得到的只是一个空标签、

255
00:12:33,770 --> 00:12:35,540
就像刚才的截图一样。

256
00:12:35,540 --> 00:12:40,100
在这个选项卡中，我可以用 C 语言编写我的第一个程序。

257
00:12:40,100 --> 00:12:42,620
遗憾的是，它不像 Scratch 那样方便用户使用

258
00:12:42,620 --> 00:12:45,992
在这里，你只需拖放几块拼图，"嘣 "的一声，拼图就完成了。

259
00:12:45,992 --> 00:12:47,450
因此，我打算这样做是为了记忆。

260
00:12:47,450 --> 00:12:49,970
但随着时间的推移，您也会逐渐熟悉这一点。

261
00:12:49,970 --> 00:12:53,720
我将包含名为 stdio.h 的内容。

262
00:12:53,720 --> 00:12:57,230
我将输入 int main，括号内为 void。

263
00:12:57,230 --> 00:13:01,190
在新的一行中，我要插入一些我们称之为大括号的东西。

264
00:13:01,190 --> 00:13:03,830
然后输入 printf，再输入一些

265
00:13:03,830 --> 00:13:09,200
括号，然后是引号、hello、逗号、world，然后是反斜杠，然后是

266
00:13:09,200 --> 00:13:12,800
小写 n，然后是引号，然后是分号

267
00:13:12,800 --> 00:13:14,280
在线路的最末端。

268
00:13:14,280 --> 00:13:19,010
因此，我所做的就是凭记忆重新创建第一个程序。

269
00:13:19,010 --> 00:13:21,710
稍后，我们将阐明其中大部分的作用。

270
00:13:21,710 --> 00:13:23,857
但现在，我们还是先实际运行一下吧。

271
00:13:23,857 --> 00:13:26,690
就像我上周第一次点击绿旗一样、

272
00:13:26,690 --> 00:13:29,840
让我们编译并运行这个程序。

273
00:13:29,840 --> 00:13:33,967
如果这是你的 Mac 或 PC，而谷歌、微软或其他人

274
00:13:33,967 --> 00:13:36,050
在故事的这个阶段，他已经制作了软件、

275
00:13:36,050 --> 00:13:37,408
我们会双击一个图标。

276
00:13:37,408 --> 00:13:38,450
但我们现在还做不到。

277
00:13:38,450 --> 00:13:39,930
这仍然是源代码。

278
00:13:39,930 --> 00:13:42,380
因此，我要在终端窗口中点击下一步。

279
00:13:42,380 --> 00:13:45,650
请注意，我在第一个美元符号下面还有第二个美元符号，它只是

280
00:13:45,650 --> 00:13:47,880
表示它已准备好接受第二条指令。

281
00:13:47,880 --> 00:13:53,000
现在，通过该命令将程序编译为实际程序

282
00:13:53,000 --> 00:13:56,990
从源代码到机器代码的转换过程非常简单。

283
00:13:56,990 --> 00:13:59,360
然后是我要制作的程序名称。

284
00:13:59,360 --> 00:14:03,710
略有微妙之处--我特意省略了 .c，因为我的程序

285
00:14:03,710 --> 00:14:05,870
我只想打个招呼。

286
00:14:05,870 --> 00:14:07,400
不要编写 make hello.c。

287
00:14:07,400 --> 00:14:08,780
就写 "你好 "吧。

288
00:14:08,780 --> 00:14:13,040
而这个程序 make 本质上就是我们的编译器。

289
00:14:13,040 --> 00:14:15,560
从技术上讲，它是一个程序，可以自动

290
00:14:15,560 --> 00:14:17,580
为我编译程序。

291
00:14:17,580 --> 00:14:20,180
但它会看到我输入了 "你好 "这个词。

292
00:14:20,180 --> 00:14:25,100
它会自动查找硬盘上名为 hello.c 的文件

293
00:14:25,100 --> 00:14:30,690
并将其从 C 语言源代码转换为 0 和 1 的机器代码。

294
00:14:30,690 --> 00:14:37,170
因此，如果我没有打错字，Enter 似乎什么也没发生。

295
00:14:37,170 --> 00:14:38,210
这是一件好事。

296
00:14:38,210 --> 00:14:41,862
如果屏幕上什么都没有输出，几乎总是说明你做得很好。

297
00:14:41,862 --> 00:14:43,070
你没有犯任何错误。

298
00:14:43,070 --> 00:14:43,880
你没被骂

299
00:14:43,880 --> 00:14:45,000
没有错误信息。

300
00:14:45,000 --> 00:14:46,590
所以，这其实是件好事。

301
00:14:46,590 --> 00:14:47,942
现在如何运行该程序？

302
00:14:47,942 --> 00:14:50,150
请注意，我有第三个美元符号，它只是

303
00:14:50,150 --> 00:14:52,110
这意味着我已经准备好接受第三个命令了。

304
00:14:52,110 --> 00:14:55,400
现在我要继续运行 ./hello。

305
00:14:55,400 --> 00:14:58,798
这确实有点奇怪，因为你必须使用点斜线。

306
00:14:58,798 --> 00:15:00,590
但现在，请相信这是

307
00:15:00,590 --> 00:15:04,610
如何在当前文件夹中运行名为 hello 的程序？

308
00:15:04,610 --> 00:15:07,730
的当前目录中。

309
00:15:07,730 --> 00:15:10,430
好吧，我再次祈祷，点击回车键。

310
00:15:10,430 --> 00:15:12,110
就这样

311
00:15:12,110 --> 00:15:15,950
我的第一个 C 语言程序：hello, world。

312
00:15:15,950 --> 00:15:20,480
现在，让我继续揭示我提出的文件资源管理器

313
00:15:20,480 --> 00:15:21,292
早先就存在。

314
00:15:21,292 --> 00:15:23,750
我将使用键盘快捷键来显示。

315
00:15:23,750 --> 00:15:27,000
一般情况下，我把它关闭，因为我并不需要不断地了解

316
00:15:27,000 --> 00:15:28,250
文件在我的账户中。

317
00:15:28,250 --> 00:15:31,820
但你现在会在文件资源管理器中看到与 Mac 或 PC 类似的功能

318
00:15:31,820 --> 00:15:35,270
但图形上有些不同，这是我的文件 hello.c。

319
00:15:35,270 --> 00:15:37,520
高亮显示是因为我打开了那个选项卡。

320
00:15:37,520 --> 00:15:40,970
但现在这里还有第二个文件，名字就叫 "你好"。

321
00:15:40,970 --> 00:15:42,690
这就是我的节目名称。

322
00:15:42,690 --> 00:15:46,100
因此，如果你使用的是 Mac 或 PC，最好双击那个东西。

323
00:15:46,100 --> 00:15:48,162
在命令行环境中无法做到这一点。

324
00:15:48,162 --> 00:15:49,370
你必须把它放下来

325
00:15:49,370 --> 00:15:50,453
但这就是我们所做的一切。

326
00:15:50,453 --> 00:15:53,750
我们创建了一个名为 hello.c 的文件，然后我的编译器

327
00:15:53,750 --> 00:15:56,240
由此制作了程序。

328
00:15:56,240 --> 00:16:00,080
请允许我暂停一下，看看是否有任何问题，因为这是

329
00:16:00,080 --> 00:16:01,970
很多神奇的短语。

330
00:16:01,970 --> 00:16:04,450
是吗？

331
00:16:04,450 --> 00:16:04,950
是啊

332
00:16:04,950 --> 00:16:08,390
所以，如果你正在关注，正在家里玩耍

333
00:16:08,390 --> 00:16:10,890
如果您收到了某种错误信息，今天的部分工作是

334
00:16:10,890 --> 00:16:13,950
我会故意诱发一些错误信息。

335
00:16:13,950 --> 00:16:17,070
现在，请允许我建议，如果你真的像我一样做了、

336
00:16:17,070 --> 00:16:19,320
你一定是哪里打错了。

337
00:16:19,320 --> 00:16:23,790
请注意，它确实是标准 io -- stdio.h。

338
00:16:23,790 --> 00:16:25,890
也许你输入的是 studio.h？

339
00:16:25,890 --> 00:16:30,600
好吧，超级常见的错误，我可以骂你。

340
00:16:30,600 --> 00:16:32,280
它不是 studio.h。

341
00:16:32,280 --> 00:16:34,560
是 stdio.h--太常见了。

342
00:16:34,560 --> 00:16:37,658
但这恰恰代表了那种令人头痛的愚蠢行为

343
00:16:37,658 --> 00:16:40,200
你本周会遇到的，可能几周内都会遇到、

344
00:16:40,200 --> 00:16:41,730
老实说，大概有几年了。

345
00:16:41,730 --> 00:16:45,180
但随着时间的推移，你开始看清这些愚蠢的错误、

346
00:16:45,180 --> 00:16:47,610
而且越来越容易，因为电脑

347
00:16:47,610 --> 00:16:49,110
会如此规范。

348
00:16:49,110 --> 00:16:50,950
它只会做你让它做的事。

349
00:16:50,950 --> 00:16:54,223
如果你说因为它在口头上听起来像 studio.h、

350
00:16:54,223 --> 00:16:55,890
它不会知道文件是什么。

351
00:16:55,890 --> 00:16:58,182
所以，事实上，谢谢你这么早就发现了这一点。

352
00:16:58,182 --> 00:16:59,740
这种情况超级常见。

353
00:16:59,740 --> 00:17:00,240
是吗？

354
00:17:00,240 --> 00:17:02,540
听众：你为什么有两个你好文件？

355
00:17:02,540 --> 00:17:03,799
为什么我要打招呼？

356
00:17:03,799 --> 00:17:04,400
是的是的

357
00:17:04,400 --> 00:17:06,400
那我为什么要打招呼？

358
00:17:06,400 --> 00:17:09,170
一个是我作为人类创建的名为 hello.c 的程序、

359
00:17:09,170 --> 00:17:10,520
照片就在这里。

360
00:17:10,520 --> 00:17:15,890
但当我运行 make hello 时，这个过程编译了我的源代码

361
00:17:15,890 --> 00:17:17,040
转化为机器码。

362
00:17:17,040 --> 00:17:20,240
因此，第二个名为 hello 的文件就是

363
00:17:20,240 --> 00:17:25,700
包含服务器实际能理解的所有 0 和 1。

364
00:17:25,700 --> 00:17:27,200
好吧，有问题吗？

365
00:17:27,200 --> 00:17:29,710
我不知道进入哈啰[听不清]

366
00:17:29,710 --> 00:17:31,960
戴维-J-马兰：如果你试着点击 "你好 "文件、

367
00:17:31,960 --> 00:17:34,270
在此环境中，您将看到 VS 代码、

368
00:17:34,270 --> 00:17:36,580
引号/非引号, 编辑器中不显示文件

369
00:17:36,580 --> 00:17:38,230
因为它要么是二进制

370
00:17:38,230 --> 00:17:41,437
又名 0 和 1，或使用不支持的文本编码。

371
00:17:41,437 --> 00:17:42,520
在这种情况下，它是二进制的。

372
00:17:42,520 --> 00:17:43,660
是 0 和 1。

373
00:17:43,660 --> 00:17:47,680
现在，你可以使用软件来查看这些 0 和 1。

374
00:17:47,680 --> 00:17:50,320
对大多数人来说，这不会有什么智力启迪。

375
00:17:50,320 --> 00:17:53,165
因此，VS Code 只能选择完全不向你显示它。

376
00:17:53,165 --> 00:17:56,290
因此，这也是一个常见的错误，即点击了一个你不想要的文件。

377
00:17:56,290 --> 00:18:00,190
但我们确实可以编辑源代码。

378
00:18:00,190 --> 00:18:01,900
好了，我已经编写了这个程序。

379
00:18:01,900 --> 00:18:04,780
它似乎神奇地起了作用，至少费了些力气

380
00:18:04,780 --> 00:18:06,700
如果你每个按键都正确的话。

381
00:18:06,700 --> 00:18:08,440
到底发生了什么事？

382
00:18:08,440 --> 00:18:09,460
效果如何？

383
00:18:09,460 --> 00:18:13,180
那么，首先请注意，即使我没有强调的东西

384
00:18:13,180 --> 00:18:17,740
或为菜单选择按钮时，请注意它已用颜色编码。

385
00:18:17,740 --> 00:18:20,980
然而，我并没有用谷歌文档的方式来突出重点、

386
00:18:20,980 --> 00:18:22,510
当然是改变颜色。

387
00:18:22,510 --> 00:18:25,960
事实证明，VS Code 和大多数编程环境

388
00:18:25,960 --> 00:18:29,600
现在，语法高亮功能会自动帮你完成。

389
00:18:29,600 --> 00:18:33,850
因此，语法高亮就是典型文本编辑器的这一功能

390
00:18:33,850 --> 00:18:36,760
现在，它可以分析你输入的代码。

391
00:18:36,760 --> 00:18:40,000
当它注意到某些类型的按键时、

392
00:18:40,000 --> 00:18:43,900
代表函数、条件、循环或变量的东西 --

393
00:18:43,900 --> 00:18:47,570
上周的很多词汇--它只是以不同的方式强调了这些词汇

394
00:18:47,570 --> 00:18:48,070
给你

395
00:18:48,070 --> 00:18:51,430
例如，我们很快就会看到的主线，在这里是紫色的。

396
00:18:51,430 --> 00:18:53,890
Int 和 void 以及 include 均为红色。

397
00:18:53,890 --> 00:18:55,630
你好，世界是蓝色的。

398
00:18:55,630 --> 00:18:57,390
我的括号是绿色的。

399
00:18:57,390 --> 00:18:59,290
这也完全因程序员而异。

400
00:18:59,290 --> 00:19:02,995
事实上，如果您确实想在问题集 1 中更改这些颜色

401
00:19:02,995 --> 00:19:04,870
您可以为自己的环境查看

402
00:19:04,870 --> 00:19:07,190
通过齿轮图标进行 VS 代码设置。

403
00:19:07,190 --> 00:19:09,820
您可以更换不同的颜色主题。

404
00:19:09,820 --> 00:19:13,480
语法高亮并不像 Scratch 中那样有特定的颜色方案。

405
00:19:13,480 --> 00:19:16,485
一般来说，每个人都有自己的喜好。

406
00:19:16,485 --> 00:19:18,610
但这里发生的只是这种观念

407
00:19:18,610 --> 00:19:20,830
语法高亮

408
00:19:20,830 --> 00:19:25,510
那么，在我运行代码（而不是编写代码）之前，代码中还发生了什么？

409
00:19:25,510 --> 00:19:28,790
如果我把所有的颜色都去掉，看起来就有点像这样了。

410
00:19:28,790 --> 00:19:30,550
为了便于讨论，请允许我继续说下去

411
00:19:30,550 --> 00:19:32,500
让它的颜色更像 Scratch。

412
00:19:32,500 --> 00:19:34,690
回想一下，我们的第一个 Scratch 程序

413
00:19:34,690 --> 00:19:39,670
屏幕上显示的 "你好，世界 "图标上有一面绿色的旗帜。

414
00:19:39,670 --> 00:19:45,070
拼图，大致为橙色，下面是一个紫色的方块。

415
00:19:45,070 --> 00:19:48,820
因此，如果我们把时间倒回到上周，这是 C 版、

416
00:19:48,820 --> 00:19:50,950
这是 Scratch 中的同一个程序。

417
00:19:50,950 --> 00:19:53,090
但现在的情况却完全一样。

418
00:19:53,090 --> 00:19:55,060
所以，如果你回想上周，你已经

419
00:19:55,060 --> 00:19:58,600
有一些功能，比如紫色的 say 功能、

420
00:19:58,600 --> 00:20:01,270
可以接受一个或多个参数，例如输入

421
00:20:01,270 --> 00:20:03,190
影响屏幕上显示的内容。

422
00:20:03,190 --> 00:20:05,230
然后，回忆一下，功能有时会

423
00:20:05,230 --> 00:20:08,480
有副作用，比如屏幕上会出现语音气泡。

424
00:20:08,480 --> 00:20:11,260
因此，上周当我们使用 "说 "字块时，我们

425
00:20:11,260 --> 00:20:13,840
传入的参数是：hello, world（你好，世界在左边）、

426
00:20:13,840 --> 00:20:17,915
我们在屏幕上看到了 "你好，世界 "的视觉效果

427
00:20:17,915 --> 00:20:18,790
在语泡中。

428
00:20:18,790 --> 00:20:23,230
这正是 VS 代码中发生的事情，但文字上要丰富得多。

429
00:20:23,230 --> 00:20:25,900
让我们再仔细看看代码本身。

430
00:20:25,900 --> 00:20:29,020
让我挥挥手，相当于当

431
00:20:29,020 --> 00:20:32,890
绿旗点击了我的部分代码，让我们只关注

432
00:20:32,890 --> 00:20:38,350
上的 say 块和 C 语言中的相应函数。

433
00:20:38,350 --> 00:20:41,770
因此，如果我想通过这个步骤转换

434
00:20:41,770 --> 00:20:44,830
上周，我们在 "说阻挡 "到 "C "的过程中做到了这一点、

435
00:20:44,830 --> 00:20:47,645
我会首先使用打印功能--虽然这实际上是

436
00:20:47,645 --> 00:20:48,520
有点像白色谎言。

437
00:20:48,520 --> 00:20:50,440
实际上是 printf 函数。

438
00:20:50,440 --> 00:20:52,030
Printf 表示格式化。

439
00:20:52,030 --> 00:20:55,360
它只是一个允许你在屏幕上格式化文本的功能。

440
00:20:55,360 --> 00:20:58,570
C 语言中没有 say 函数，只有 printf 函数。

441
00:20:58,570 --> 00:21:02,650
多年前，麻省理工学院的做法是，他们将历史上存在的东西

442
00:21:02,650 --> 00:21:05,290
和 printf 一样，他们为更广泛的受众简化了它

443
00:21:05,290 --> 00:21:08,050
只需将其称为 "本质上说 "即可。

444
00:21:08,050 --> 00:21:13,450
但请注意，现在如果我想将左边的 Scratch 代码转换为 C 代码

445
00:21:13,450 --> 00:21:16,250
没错，形状是一样的。

446
00:21:16,250 --> 00:21:18,940
因此，麻省理工学院特意使用了这个白色的椭圆形、

447
00:21:18,940 --> 00:21:23,510
如果只是因为它让人联想到也有括号的话。

448
00:21:23,510 --> 00:21:26,770
因此，在右侧，如果我想传递一个参数或输入

449
00:21:26,770 --> 00:21:31,240
在 printf 函数中，我使用了开括号和关括号。

450
00:21:31,240 --> 00:21:33,700
然后，我在括号里输入以下内容

451
00:21:33,700 --> 00:21:35,600
我想在屏幕上打印的内容是什么？

452
00:21:35,600 --> 00:21:37,460
这里是 "你好，逗号，世界"。

453
00:21:37,460 --> 00:21:39,310
但请注意，我特意留出了一些空间

454
00:21:39,310 --> 00:21:42,160
因为在 C 语言的世界里，你需要多敲几下键盘。

455
00:21:42,160 --> 00:21:44,590
任何时候，只要您键入文字

456
00:21:44,590 --> 00:21:49,150
用计算机科学术语来说，也就是一串文本--

457
00:21:49,150 --> 00:21:52,100
你需要引述它，这里是用双引号。

458
00:21:52,100 --> 00:21:54,520
左边双引号，右边双引号。

459
00:21:54,520 --> 00:21:57,730
请注意，我还将加入一些略带神秘色彩的符号

460
00:21:57,730 --> 00:22:01,660
这里也是--反斜杠 n，我刚才也打了字，也口头说了、

461
00:22:01,660 --> 00:22:05,480
最后还有一个麻烦的结尾，那就是分号。

462
00:22:05,480 --> 00:22:08,890
这就是我们从 Scratch 开始的原因。

463
00:22:08,890 --> 00:22:10,960
这样，拖放就可以了。

464
00:22:10,960 --> 00:22:14,680
在 C 语言中，printf、括号、双引号、文本

465
00:22:14,680 --> 00:22:16,630
你想要的，反斜杠 n，末尾分号。

466
00:22:16,630 --> 00:22:18,970
语法开销太大了。

467
00:22:18,970 --> 00:22:21,290
但归根结底，这只是一种功能。

468
00:22:21,290 --> 00:22:25,180
你会习惯括号和引号这些麻烦的东西、

469
00:22:25,180 --> 00:22:27,130
分号等。

470
00:22:27,130 --> 00:22:31,810
但事情很容易出错，也很容易犯错误、

471
00:22:31,810 --> 00:22:33,380
即使有这样的代码行。

472
00:22:33,380 --> 00:22:34,190
那就让我来吧。

473
00:22:34,190 --> 00:22:37,070
让我回到 VS 代码，那里有完全相同的代码。

474
00:22:37,070 --> 00:22:40,910
请注意，第 5 行正是这一行代码。

475
00:22:40,910 --> 00:22:42,910
因此，这就相当于 "说 "字块。

476
00:22:42,910 --> 00:22:46,090
让我们考虑一下，在早期甚至现在，我可能会犯哪些错误

477
00:22:46,090 --> 00:22:49,930
20 年后，在了解到这一点后，这在一般情况下是很常见的。

478
00:22:49,930 --> 00:22:52,180
假如我忘了那里的分号。

479
00:22:52,180 --> 00:22:53,380
太简单了

480
00:22:53,380 --> 00:22:54,910
你最终会做到这一点。

481
00:22:54,910 --> 00:22:57,970
让我们看看现在回到终端窗口会发生什么情况

482
00:22:57,970 --> 00:22:59,920
并尝试重新编译我的代码。

483
00:22:59,920 --> 00:23:02,590
为了保持整洁，我要清空屏幕。

484
00:23:02,590 --> 00:23:05,170
但这只是为了讲课，这样我们就可以只关注

485
00:23:05,170 --> 00:23:06,460
上的最新命令。

486
00:23:06,460 --> 00:23:09,940
不过，我现在要去重新做一次 "你好"。

487
00:23:09,940 --> 00:23:13,690
这将确保我的程序被重新编译。

488
00:23:13,690 --> 00:23:14,950
而这是一个手动过程。

489
00:23:14,950 --> 00:23:16,060
我修改了代码。

490
00:23:16,060 --> 00:23:18,670
硬盘上的 0 和 1 没有变化。

491
00:23:18,670 --> 00:23:21,980
我需要重新编译，以输出最新的机器代码。

492
00:23:21,980 --> 00:23:22,580
那么，我们开始吧。

493
00:23:22,580 --> 00:23:24,830
我按下回车键，像以前一样祈祷。

494
00:23:24,830 --> 00:23:29,320
但我还是不小心把分号去掉了。

495
00:23:29,320 --> 00:23:29,980
我的天啊

496
00:23:29,980 --> 00:23:33,700
现在的错误行数比实际代码行数还多。

497
00:23:33,700 --> 00:23:35,770
这也需要一些时间来适应。

498
00:23:35,770 --> 00:23:38,590
我们使用的程序不一定是由我们编写的

499
00:23:38,590 --> 00:23:40,480
考虑到最不舒服的观众

500
00:23:40,480 --> 00:23:42,760
但实际上，当年的专业程序员。

501
00:23:42,760 --> 00:23:46,000
但是，通过实践，通过经验，通过错误、

502
00:23:46,000 --> 00:23:47,750
你也会开始注意到这里的模式。

503
00:23:47,750 --> 00:23:49,090
这就是我输入的内容。

504
00:23:49,090 --> 00:23:51,220
在手势提示后打招呼。

505
00:23:51,220 --> 00:23:57,010
现在我被骂的内容如下：hello.c、冒号、5、冒号、29。

506
00:23:57,010 --> 00:23:58,420
那是什么意思？

507
00:23:58,420 --> 00:24:03,460
我在第 5 行的第 29 个字符上弄错了。

508
00:24:03,460 --> 00:24:05,740
一般来说，特定的字符并不那么有用

509
00:24:05,740 --> 00:24:07,448
除非你真的想把它算出来。

510
00:24:07,448 --> 00:24:08,630
但第 5 行是一个很好的线索。

511
00:24:08,630 --> 00:24:09,130
为什么？

512
00:24:09,130 --> 00:24:11,660
这说明我在第 5 行的某个地方出了差错。

513
00:24:11,660 --> 00:24:12,160
好的

514
00:24:12,160 --> 00:24:13,360
那么，错误出在哪里呢？

515
00:24:13,360 --> 00:24:16,242
希望在表达式后加上分号。

516
00:24:16,242 --> 00:24:17,950
这个错误其实很明显

517
00:24:17,950 --> 00:24:20,103
现在我看到它，才意识到，哦，等等。

518
00:24:20,103 --> 00:24:21,520
好了，这是我的一行代码。

519
00:24:21,520 --> 00:24:26,890
这里可以说是 ASCII 艺术的一种--用文字代表图形。

520
00:24:26,890 --> 00:24:30,550
它要我在这行末尾的分号处加上绿色。

521
00:24:30,550 --> 00:24:32,470
生成 1 个错误，内置

522
00:24:32,470 --> 00:24:33,850
所以有些深奥的东西。

523
00:24:33,850 --> 00:24:36,340
但我的程序无法编译。

524
00:24:36,340 --> 00:24:39,470
当您看到这样的错误时，说明它没有工作。

525
00:24:39,470 --> 00:24:40,360
有什么解决办法？

526
00:24:40,360 --> 00:24:45,470
显然，解决方法就是回到这里，在这里加上分号。

527
00:24:45,470 --> 00:24:48,760
现在，如果我用 make hello 重新编译代码--

528
00:24:48,760 --> 00:24:52,060
我现在还不会清除屏幕，只是想让你们看看区别--现在

529
00:24:52,060 --> 00:24:52,990
就这样成功了。

530
00:24:52,990 --> 00:24:55,550
所以，我们又回到了从前。

531
00:24:55,550 --> 00:24:57,910
好吧，让我在这里停一下，问一下是否有

532
00:24:57,910 --> 00:25:02,240
对我刚才所做的有任何疑问。

533
00:25:02,240 --> 00:25:04,460
这些错误信息最初会变得很频繁。

534
00:25:04,460 --> 00:25:04,960
是吗？

535
00:25:04,960 --> 00:25:08,848
听众：那么，你是需要在行后加上分号，还是只需要其中的一部分？

536
00:25:08,848 --> 00:25:10,390
大卫-J-马兰：问得好。

537
00:25:10,390 --> 00:25:12,960
您是需要在每一行后面都加上分号，还是只需要在某些行后面加上分号？

538
00:25:12,960 --> 00:25:14,022
原来，只是一些。

539
00:25:14,022 --> 00:25:16,980
这是你在实践中、在示范中学习到的东西

540
00:25:16,980 --> 00:25:18,240
和今天的例子。

541
00:25:18,240 --> 00:25:22,810
一般来说，可以在语句后加上分号。

542
00:25:22,810 --> 00:25:25,230
这就是这行代码的专业术语。

543
00:25:25,230 --> 00:25:25,950
这是一个声明。

544
00:25:25,950 --> 00:25:29,230
把它想象成相当于英语句子的代码。

545
00:25:29,230 --> 00:25:32,820
因此，代码中的分号相当于英语中的句号

546
00:25:32,820 --> 00:25:34,830
当你想完这个问题时。

547
00:25:34,830 --> 00:25:37,650
在其他地方，"现在 "不需要分号。

548
00:25:37,650 --> 00:25:39,750
我们还会看到你把它们放在其他地方的例子。

549
00:25:39,750 --> 00:25:42,780
但通常是在一行代码的末尾

550
00:25:42,780 --> 00:25:46,980
而不是纯粹的语法，比如大括号。

551
00:25:46,980 --> 00:25:51,600
关于我刚刚纠正并给自己造成的错误的其他问题？

552
00:25:51,600 --> 00:25:52,230
是吗？

553
00:25:52,230 --> 00:25:55,170
听众：[听不清]

554
00:25:55,170 --> 00:25:56,170
戴维-J-马兰：正确。

555
00:25:56,170 --> 00:25:58,950
因此，第 5 行最有可能出错。

556
00:25:58,950 --> 00:26:02,250
字符 29 表示 29 个字符。

557
00:26:02,250 --> 00:26:04,800
在这种情况下，它实际上是在给我一个建议。

558
00:26:04,800 --> 00:26:07,420
编译器并不总是知道如何给我建议、

559
00:26:07,420 --> 00:26:09,750
尤其是当我把代码写得一团糟的时候。

560
00:26:09,750 --> 00:26:13,260
但通常情况下，它会尽力给你这样的答案。

561
00:26:13,260 --> 00:26:14,170
是吗？

562
00:26:14,170 --> 00:26:16,930
听众：你怎么会先写下 hello.c 代码？

563
00:26:16,930 --> 00:26:21,140
戴维-J-马兰：啊，那我怎么会第一次输入代码，空格，hello.c、

564
00:26:21,140 --> 00:26:22,940
现在我却在输入 "你好"？

565
00:26:22,940 --> 00:26:24,180
两个不同的过程。

566
00:26:24,180 --> 00:26:27,350
因此，当我输入代码时，空格，hello.c，即

567
00:26:27,350 --> 00:26:31,280
这是因为我想打开 VS Code 并创建一个名为 hello.c 的新文件。

568
00:26:31,280 --> 00:26:34,910
这就像在 Mac 或 PC 上打开 "文件"、"新建 "一样。

569
00:26:34,910 --> 00:26:38,690
此后，一旦文件存在并在此处实际打开 --

570
00:26:38,690 --> 00:26:41,900
而且会自动保存，你不需要一直按 Command-S 或 Control-S 键。

571
00:26:41,900 --> 00:26:42,560
时间

572
00:26:42,560 --> 00:26:46,110
现在我可以用 make hello 一次又一次地编译它。

573
00:26:46,110 --> 00:26:50,570
因此，从理论上讲，我应该永远不需要键入代码、空格、hello.c

574
00:26:50,570 --> 00:26:54,020
除非我想创建一个名为相同内容的全新文件。

575
00:26:54,020 --> 00:26:57,200
好吧，那么这里的另一段语法呢？

576
00:26:57,200 --> 00:26:58,790
让我清空一下终端窗口。

577
00:26:58,790 --> 00:27:01,280
您也可以按 Control-L 键来扔掉所有东西

578
00:27:01,280 --> 00:27:03,380
只是为了美观。

579
00:27:03,380 --> 00:27:06,470
假设我省略了这一连串的符号

580
00:27:06,470 --> 00:27:09,680
是，反斜杠 n，因为我第一眼看上去并不确定

581
00:27:09,680 --> 00:27:11,460
为什么会有这个东西？

582
00:27:11,460 --> 00:27:13,310
是否有人想猜测，尤其是

583
00:27:13,310 --> 00:27:18,110
如果你以前从未编程，如果我重新编译，现在可能会发生什么？

584
00:27:18,110 --> 00:27:20,450
并重新运行这一版本的程序？

585
00:27:20,450 --> 00:27:25,130
我保留了分号，但去掉了反斜线 n。

586
00:27:25,130 --> 00:27:28,390
有什么直觉吗？

587
00:27:28,390 --> 00:27:29,920
好吧

588
00:27:29,920 --> 00:27:32,470
听众：下一个美元符号是否会出现

589
00:27:32,470 --> 00:27:34,190
在你的 "你好，世界 "之后，直接说 "你好"？

590
00:27:34,190 --> 00:27:35,190
戴维-J-马兰：会的。

591
00:27:35,190 --> 00:27:38,740
下一个美元符号将出现在 "你好，世界 "之后。

592
00:27:38,740 --> 00:27:40,564
但你为什么会这么想？

593
00:27:40,564 --> 00:27:43,010
听众：因为反斜杠 n 会产生新行？

594
00:27:43,010 --> 00:27:44,010
戴维-J-马兰：没错。

595
00:27:44,010 --> 00:27:46,050
反斜线 n 实际上是一个特殊序列

596
00:27:46,050 --> 00:27:48,060
创建新行的符号。

597
00:27:48,060 --> 00:27:52,710
因此，就你的观点而言，如果我重新编译这个程序，让 hello, Enter--

598
00:27:52,710 --> 00:27:55,420
没有语法错误，所以这次编译成功了。

599
00:27:55,420 --> 00:27:57,180
因此不需要反斜杠 n。

600
00:27:57,180 --> 00:27:58,800
你确实需要分号。

601
00:27:58,800 --> 00:28:02,730
但是，如果没有反斜杠 n，请看我使用 ./hello 时会出现什么情况

602
00:28:02,730 --> 00:28:03,510
这次

603
00:28:03,510 --> 00:28:07,230
现在，我确实看到了 "你好"、"逗号"、"世界"，然后是一个奇怪的美元符号。

604
00:28:07,230 --> 00:28:08,460
这仍然是一个提示。

605
00:28:08,460 --> 00:28:12,270
我仍然可以输入命令，比如清除，一切都会被清理干净。

606
00:28:12,270 --> 00:28:13,710
但这看起来有点傻。

607
00:28:13,710 --> 00:28:18,240
如果我在这里用 ./hello 再运行一次，用户体验就会大打折扣。

608
00:28:18,240 --> 00:28:20,740
按照惯例，当您运行完程序后、

609
00:28:20,740 --> 00:28:22,950
最好是清理一下，将光标移动到

610
00:28:22,950 --> 00:28:24,460
到用户的下一行。

611
00:28:24,460 --> 00:28:27,540
因此，反斜杠 n 只是一个特殊符号、

612
00:28:27,540 --> 00:28:32,640
也就是 C 知道的转义序列

613
00:28:32,640 --> 00:28:34,980
表示将光标移到下一行。

614
00:28:34,980 --> 00:28:39,640
在其他语言中，Python 也使用同样的符号。

615
00:28:39,640 --> 00:28:44,850
现在，如果我回到这里的代码，例如

616
00:28:44,850 --> 00:28:47,220
我尝试用不同的方式来做这件事。

617
00:28:47,220 --> 00:28:49,020
假设我不加反斜线 n。

618
00:28:49,020 --> 00:28:52,860
我只是像正常人在谷歌文档或微软 Word 中一样按下回车键。

619
00:28:52,860 --> 00:28:55,107
让我继续尝试编译这个程序。

620
00:28:55,107 --> 00:28:56,940
你会希望这样做能奏效，对吗？

621
00:28:56,940 --> 00:29:00,210
你会希望打印出 "你好，世界"，然后是一行空行

622
00:29:00,210 --> 00:29:02,220
因为我把光标移到了下一行。

623
00:29:02,220 --> 00:29:02,790
但是没有。

624
00:29:02,790 --> 00:29:07,290
如果我运行 make hello now 并尝试编译，C 语言并不喜欢这样。

625
00:29:07,290 --> 00:29:09,690
现在我得到了一个不同的错误，还是在第 5 行、

626
00:29:09,690 --> 00:29:12,240
这次从字符 12 开始 --

627
00:29:12,240 --> 00:29:15,810
错误，缺少结束符双引号，然后

628
00:29:15,810 --> 00:29:17,070
其他一些深奥的东西。

629
00:29:17,070 --> 00:29:19,530
然后这听起来不妙--这次是致命错误、

630
00:29:19,530 --> 00:29:21,900
出错太多，立即停止。

631
00:29:21,900 --> 00:29:23,470
所以我真的搞砸了。

632
00:29:23,470 --> 00:29:25,320
那么，为什么我不能这样做呢？

633
00:29:25,320 --> 00:29:26,190
只是因为

634
00:29:26,190 --> 00:29:29,730
设计 C 语言的人类认为，如果你有一串文本、

635
00:29:29,730 --> 00:29:31,380
必须保持在同一条线上。

636
00:29:31,380 --> 00:29:32,760
它可能会变得很长。

637
00:29:32,760 --> 00:29:36,150
它可以软包，也就是说，不需要按回车键。

638
00:29:36,150 --> 00:29:38,220
但你不能按回车键来创建新行。

639
00:29:38,220 --> 00:29:42,870
如果您有意换行，则必须使用反斜线 n

640
00:29:42,870 --> 00:29:43,958
转义字符。

641
00:29:43,958 --> 00:29:45,250
所以，让我来做这件事吧。

642
00:29:45,250 --> 00:29:46,710
让我把它放回去。

643
00:29:46,710 --> 00:29:48,720
让我回到终端窗口。

644
00:29:48,720 --> 00:29:50,080
我再清理一下屏幕。

645
00:29:50,080 --> 00:29:54,090
现在，让我继续 make hello，重新编译到该版本-- ./hello。

646
00:29:54,090 --> 00:29:54,900
就这样

647
00:29:54,900 --> 00:29:57,780
你好，我们又开始工作了。

648
00:29:57,780 --> 00:30:00,300
好了，现在让我们从其他方面来分析一下

649
00:30:00,300 --> 00:30:03,870
的代码，因为要让我们说 "你好"，需要做很多事情、

650
00:30:03,870 --> 00:30:04,920
屏幕上的世界。

651
00:30:04,920 --> 00:30:07,740
今天，我们基本上要忽略这一点-- int

652
00:30:07,740 --> 00:30:10,145
main(void) 和这些大括号。

653
00:30:10,145 --> 00:30:12,520
至于为什么会有这个问题，我们很快就会说到。

654
00:30:12,520 --> 00:30:15,870
但现在只需想想 int main(void) 和这些大括号

655
00:30:15,870 --> 00:30:19,180
这里的 "C "就相当于绿旗点击时的 "C"。

656
00:30:19,180 --> 00:30:19,680
为什么？

657
00:30:19,680 --> 00:30:20,638
你只需要它在那里。

658
00:30:20,638 --> 00:30:22,320
这样才能让你的计划顺利进行。

659
00:30:22,320 --> 00:30:25,500
主功能确实会有一些特殊的功能，但更多的情况是

660
00:30:25,500 --> 00:30:26,340
下次吧

661
00:30:26,340 --> 00:30:28,950
但我为什么要在这里写这行代码呢？

662
00:30:28,950 --> 00:30:33,990
正确的拼写确实是 stdio.h，即 S-T-D-I-O dot H。

663
00:30:33,990 --> 00:30:37,500
而且这次是有角度的支架，有点新意。

664
00:30:37,500 --> 00:30:40,290
有一个哈希值，然后是一个包含关键字。

665
00:30:40,290 --> 00:30:42,123
如果你不知道某样东西是什么，那就有

666
00:30:42,123 --> 00:30:45,165
把它扔掉，看看会发生什么，也没什么坏处。

667
00:30:45,165 --> 00:30:46,360
所以，请允许我删除这一行。

668
00:30:46,360 --> 00:30:48,910
让我回到终端窗口，清空屏幕、

669
00:30:48,910 --> 00:30:50,160
然后再次运行 make hello。

670
00:30:50,160 --> 00:30:53,290
现在让我们试着编译这个没有第一行的程序。

671
00:30:53,290 --> 00:30:53,790
为什么？

672
00:30:53,790 --> 00:30:56,340
我不明白，让我们拭目以待吧。

673
00:30:56,340 --> 00:30:58,920
好吧，这又是一个错误，但让我们看看 --

674
00:30:58,920 --> 00:31:03,480
hello.c，第 5 行，第 5 个字符--所以这是很早期的--

675
00:31:03,480 --> 00:31:07,920
错误，隐式声明了类型为 int 的库函数 printf

676
00:31:07,920 --> 00:31:09,150
然后点、点、点。

677
00:31:09,150 --> 00:31:12,630
因此，隐式声明库函数 printf--

678
00:31:12,630 --> 00:31:14,490
所以这听起来非常隐晦。

679
00:31:14,490 --> 00:31:16,920
你会更好地理解这些短语。

680
00:31:16,920 --> 00:31:22,620
但显然，我确实需要 stdio.h 的 include 行。

681
00:31:22,620 --> 00:31:23,820
但为什么呢？

682
00:31:23,820 --> 00:31:27,810
根据这一症状，您的直觉可能是

683
00:31:27,810 --> 00:31:33,330
第一行代码的作用是什么？

684
00:31:33,330 --> 00:31:35,370
为什么直觉上它必须存在？

685
00:31:35,370 --> 00:31:37,290
听众：这就是[听不清]的功能。

686
00:31:37,290 --> 00:31:38,290
戴维-J-马兰：没错。

687
00:31:38,290 --> 00:31:41,350
这就像导入一个资料库，这样你就可以做一些事情，比如打印东西

688
00:31:41,350 --> 00:31:42,137
在屏幕上显示出来。

689
00:31:42,137 --> 00:31:45,220
在 Scratch 中，大部分拼图都不需要这样做。

690
00:31:45,220 --> 00:31:47,950
但你可能还记得，在第 0 周的中途、

691
00:31:47,950 --> 00:31:51,640
我点击了 Scratch 屏幕左下角的扩展按钮、

692
00:31:51,640 --> 00:31:54,340
我还为文字输入了一些额外的拼图块

693
00:31:54,340 --> 00:31:59,170
我们听到了令人毛骨悚然的人性化声音

694
00:31:59,170 --> 00:32:00,100
猫的嘴。

695
00:32:00,100 --> 00:32:02,500
这就像增加了一个图书馆

696
00:32:02,500 --> 00:32:04,390
别人写的代码。

697
00:32:04,390 --> 00:32:06,550
在这种情况下，它是第三方。

698
00:32:06,550 --> 00:32:08,380
但我让自己接触到了它。

699
00:32:08,380 --> 00:32:09,250
我也一样。

700
00:32:09,250 --> 00:32:13,900
原来，在 C 语言中并不能自动获得 printf。

701
00:32:13,900 --> 00:32:17,560
您必须包含一个所谓的头文件，该文件

702
00:32:17,560 --> 00:32:20,020
声明了该函数的存在。

703
00:32:20,020 --> 00:32:22,570
现在，历史上这样做的原因只是效率问题。

704
00:32:22,570 --> 00:32:26,882
在电脑速度较慢、资源有限的年代、

705
00:32:26,882 --> 00:32:29,590
你不想让自己进入整个厨房

706
00:32:29,590 --> 00:32:30,610
功能汇。

707
00:32:30,610 --> 00:32:34,690
您只想包含您真正关心的功能。

708
00:32:34,690 --> 00:32:39,180
如今，这是一个复制/粘贴步骤，因为您几乎总是

709
00:32:39,180 --> 00:32:40,930
想在屏幕上打印一些东西、

710
00:32:40,930 --> 00:32:42,680
至少在编写这样的程序时是这样。

711
00:32:42,680 --> 00:32:45,760
但这些所谓的头文件包含了足够的信息

712
00:32:45,760 --> 00:32:50,350
标准 I/O 库中的所有函数。

713
00:32:50,350 --> 00:32:53,450
而标准 I/O 只是指标准输入和输出。

714
00:32:53,450 --> 00:32:54,700
这样做合适吗？

715
00:32:54,700 --> 00:32:57,010
因为打印是非常基本的输出。

716
00:32:57,010 --> 00:32:59,920
原来，还有其他功能可以从人类的

717
00:32:59,920 --> 00:33:01,310
键盘--稍后再谈。

718
00:33:01,310 --> 00:33:03,970
但是，只要你想在 C 语言的屏幕上打印一些东西，你就可以用它来打印、

719
00:33:03,970 --> 00:33:07,630
您确实需要在代码顶部包含该头文件。

720
00:33:07,630 --> 00:33:11,350
这基本上是在通知编译器，嘿，编译器、

721
00:33:11,350 --> 00:33:15,980
我想使用标准 I/O 库的功能、

722
00:33:15,980 --> 00:33:18,320
包括本例中的 printf。

723
00:33:18,320 --> 00:33:20,770
如果你不小心漏掉了头文件、

724
00:33:20,770 --> 00:33:24,040
就是行不通，因为它不知道 printf 是什么。

725
00:33:24,040 --> 00:33:27,970
在这种情况下，这是一些不被认可的符号。

726
00:33:27,970 --> 00:33:34,320
好了，关于这行代码，这行代码的问题、

727
00:33:34,320 --> 00:33:37,590
或者这些头文件是什么？

728
00:33:37,590 --> 00:33:40,890
好吧，你可能会问，那你怎么知道存在哪些功能呢？

729
00:33:40,890 --> 00:33:43,990
您如何知道您可能真的想要包含哪些文件？

730
00:33:43,990 --> 00:33:46,620
事实证明，C 语言是一门历史悠久的语言、

731
00:33:46,620 --> 00:33:48,720
并有充足的文献资料。

732
00:33:48,720 --> 00:33:52,770
需要注意的是，它的文档并不一定对用户那么友好。

733
00:33:52,770 --> 00:33:56,370
但我们为课程准备的是一个简化版本

734
00:33:56,370 --> 00:34:01,680
在此 URL（manual.cs50.io）上查看 C 语言的官方文档。

735
00:34:01,680 --> 00:34:04,380
在 C 语言和其他语言的世界里也是如此、

736
00:34:04,380 --> 00:34:06,150
有所谓的手动页面。

737
00:34:06,150 --> 00:34:08,820
而这些只是基于文本的文档

738
00:34:08,820 --> 00:34:11,010
老实说，这通常是用一种声音写出来的

739
00:34:11,010 --> 00:34:14,560
你必须是一个经验丰富的程序员，才能理解其中的一些内容。

740
00:34:14,560 --> 00:34:17,699
因此，我们在这一版本的相同文档中做了以下工作

741
00:34:17,699 --> 00:34:20,699
我们已经导入了所有原始官方文档、

742
00:34:20,699 --> 00:34:24,074
但我们增加了不太舒适的英语翻译

743
00:34:24,074 --> 00:34:26,699
您在课堂上可能会用到的许多功能，只需

744
00:34:26,699 --> 00:34:27,713
帮助您入职。

745
00:34:27,713 --> 00:34:30,630
因此，从长远来看，您并不需要这些文件。

746
00:34:30,630 --> 00:34:34,320
不过，为了方便起见，我们还是把它翻译成术语吧

747
00:34:34,320 --> 00:34:36,630
您可能会喜欢的助教、

748
00:34:36,630 --> 00:34:39,969
例如，与这些文件的原作者相对。

749
00:34:39,969 --> 00:34:42,420
因此，举例来说，如果您有兴趣阅读

750
00:34:42,420 --> 00:34:48,330
那么，在 stdio.h 文件中存在哪些函数呢？

751
00:34:48,330 --> 00:34:52,830
您可以访问这样的 URL，或者在 manual.cs50.io 上搜索。

752
00:34:52,830 --> 00:34:56,350
这将显示该函数库中所有可用函数的列表、

753
00:34:56,350 --> 00:34:58,350
并打印是否确实是其中之一。

754
00:34:58,350 --> 00:35:00,683
然后你可以进一步点击，到达一个 URL

755
00:35:00,683 --> 00:35:03,475
像这样，它将为您提供所有文档，说明如何

756
00:35:03,475 --> 00:35:04,110
来使用 printf。

757
00:35:04,110 --> 00:35:07,560
事实证明，除了打印 "你好，世界"，你还可以做更多。

758
00:35:07,560 --> 00:35:09,450
我们今天就来浅谈一下。

759
00:35:09,450 --> 00:35:12,900
但事实证明，文件总是

760
00:35:12,900 --> 00:35:16,680
是您解决 "我该怎么办 "等问题的最终权威来源、

761
00:35:16,680 --> 00:35:18,160
如何才能做到？

762
00:35:18,160 --> 00:35:23,010
与此同时，原来 CS50 也有自己的资料库

763
00:35:23,010 --> 00:35:25,980
并可通过名为 cs50.h 的头文件访问。

764
00:35:25,980 --> 00:35:28,530
在 C 语言中，输出实际上是

765
00:35:28,530 --> 00:35:30,750
相对来说，只要你

766
00:35:30,750 --> 00:35:34,110
习惯所有的大括号、小括号、引号等。

767
00:35:34,110 --> 00:35:36,670
但输入就比较困难了。

768
00:35:36,670 --> 00:35:41,100
如果你以前学过编程，用 Python 输入并不难。

769
00:35:41,100 --> 00:35:42,540
在 Java 中做到这一点并不难。

770
00:35:42,540 --> 00:35:46,312
我们几周后就会知道原因。

771
00:35:46,312 --> 00:35:48,270
但在课堂的前几周、

772
00:35:48,270 --> 00:35:50,880
实际上，我们为你提供了一些训练轮、

773
00:35:50,880 --> 00:35:53,700
在这种情况下，我们有一些功能

774
00:35:53,700 --> 00:35:56,430
在 cs50.h 文件中声明。

775
00:35:56,430 --> 00:35:59,220
它的文档存放在这样一个 URL 上。

776
00:35:59,220 --> 00:36:01,230
稍后，我们将使用其中的几种。

777
00:36:01,230 --> 00:36:05,040
您会发现 CS50 为您提供了一些函数，如 get_char

778
00:36:05,040 --> 00:36:08,580
用于从用户键盘上获取单个字符、

779
00:36:08,580 --> 00:36:11,790
get_int 从用户键盘上获取一个整数、

780
00:36:11,790 --> 00:36:15,450
get_string，从用户键盘上获取文本序列，以及一堆

781
00:36:15,450 --> 00:36:16,930
其他人也是如此。

782
00:36:16,930 --> 00:36:19,920
那么，让我们实际使用一下这些功能吧、

783
00:36:19,920 --> 00:36:22,410
重温我们的第二个计划

784
00:36:22,410 --> 00:36:26,710
上次用 Scratch 写的，在输出中增加了一些输入。

785
00:36:26,710 --> 00:36:28,830
因此，Scratch 的第一个版本只是 hello, world。

786
00:36:28,830 --> 00:36:31,200
每次点击绿旗时都说同样的话。

787
00:36:31,200 --> 00:36:33,180
不过，回顾第 2 版，它做到了这一点。

788
00:36:33,180 --> 00:36:35,190
它问用户：你叫什么名字？

789
00:36:35,190 --> 00:36:40,870
然后，以某种方式返回一个返回值，我们称之为 "返回值"。

790
00:36:40,870 --> 00:36:44,100
然后，我们把 "你好 "和 "这个名字 "结合起来，说得更多一些

791
00:36:44,100 --> 00:36:46,420
屏幕上很有趣

792
00:36:46,420 --> 00:36:48,420
那么，这个模型是什么样的呢？

793
00:36:48,420 --> 00:36:49,560
还是老样子。

794
00:36:49,560 --> 00:36:52,680
我们在中间有一个函数，函数就像代码一样

795
00:36:52,680 --> 00:36:54,480
实现我们的算法。

796
00:36:54,480 --> 00:36:56,910
这需要一个或多个参数，比如你

797
00:36:56,910 --> 00:37:00,000
最终想在屏幕上说些什么？

798
00:37:00,000 --> 00:37:03,580
在这种情况下，返回值实际上是一个返回值。

799
00:37:03,580 --> 00:37:07,660
因此，在获取输入的情况下，我们可以再次考虑这个询问块、

800
00:37:07,660 --> 00:37:08,490
就像上周一样

801
00:37:08,490 --> 00:37:12,420
输入的内容就是你想问用户的任何英语单词。

802
00:37:12,420 --> 00:37:14,670
然后返回一个值。

803
00:37:14,670 --> 00:37:17,550
而在 MIT 的世界答案中，这是默认调用的。

804
00:37:17,550 --> 00:37:20,460
但我们会发现，在 C 语言中，这些返回值可以任意调用

805
00:37:20,460 --> 00:37:22,300
你最终想要的变量。

806
00:37:22,300 --> 00:37:24,100
但这不同于副作用。

807
00:37:24,100 --> 00:37:27,100
副作用就是屏幕上经常出现的视觉效果、

808
00:37:27,100 --> 00:37:28,980
比如 "说话泡泡 "或 "你好，世界"。

809
00:37:28,980 --> 00:37:32,220
返回值实际上是从函数中返回的值

810
00:37:32,220 --> 00:37:34,020
您可以使用或重复使用。

811
00:37:34,020 --> 00:37:38,400
那么，本周如何将上周的 Scratch 代码块转换为 C 代码呢？

812
00:37:38,400 --> 00:37:41,340
好吧，如果你想询问用户姓名之类的信息、

813
00:37:41,340 --> 00:37:42,580
你可以做到这一点。

814
00:37:42,580 --> 00:37:45,600
您使用的是 CS50 函数 get_string。

815
00:37:45,600 --> 00:37:49,950
你还可以用括号来表示这里是输入，那里也是输入。

816
00:37:49,950 --> 00:37:52,967
然后，您就可以把想问用户的句子--

817
00:37:52,967 --> 00:37:54,300
引号/非引号，你叫什么名字？

818
00:37:54,300 --> 00:37:57,150
但在 C 语言中确实需要引号。

819
00:37:57,150 --> 00:37:59,220
因此，我也会继续添加这些内容。

820
00:37:59,220 --> 00:38:03,720
很微妙，但我特意在问号后面加了一个空格、

821
00:38:03,720 --> 00:38:06,840
但在双引号之前，以便光标

822
00:38:06,840 --> 00:38:08,998
因为，在这种情况下、

823
00:38:08,998 --> 00:38:11,790
我们不会像在 Scratch 中那样得到一个特殊的语音框。

824
00:38:11,790 --> 00:38:14,582
它只会让光标停留在原处，所以我们会看到它、

825
00:38:14,582 --> 00:38:16,980
从美学角度看，这只是将闪烁的光标移动了一个

826
00:38:16,980 --> 00:38:19,800
屏幕上句子后面的空格。

827
00:38:19,800 --> 00:38:21,930
好吧，但问题出在 "划痕 "上、

828
00:38:21,930 --> 00:38:25,140
我们只是自动从用户那里得到了答案

829
00:38:25,140 --> 00:38:27,180
在一个名为 "答案 "的特殊变量中。

830
00:38:27,180 --> 00:38:30,270
在 C 语言中，你必须说得更具体一些。

831
00:38:30,270 --> 00:38:35,780
在 C 语言中，如果要从 get_string 这样的函数中获取返回值、

832
00:38:35,780 --> 00:38:40,420
必须使用等号，然后在左边输入变量名。

833
00:38:40,420 --> 00:38:42,280
变量的选择由您决定。

834
00:38:42,280 --> 00:38:44,290
我可以给它起任何名字--X、Y、Z。

835
00:38:44,290 --> 00:38:47,470
我更愿意将其描述为 "回答 "与 "什么 "之间的 "平等"。

836
00:38:47,470 --> 00:38:48,880
麻省理工学院用 Scratch 做到了这一点。

837
00:38:48,880 --> 00:38:53,090
但请注意，这本身并不代表平等。

838
00:38:53,090 --> 00:38:55,640
这就是本案中的任务。

839
00:38:55,640 --> 00:38:58,180
因此，在 C 语言中，当您使用单个等号时、

840
00:38:58,180 --> 00:39:01,720
这意味着将右侧的值复制到

841
00:39:01,720 --> 00:39:03,590
从右到左

842
00:39:03,590 --> 00:39:05,390
这对我们有什么好处？

843
00:39:05,390 --> 00:39:08,170
那么，如果 get_string 是一个用以下内容提示用户的函数

844
00:39:08,170 --> 00:39:12,160
引号/非引号，你叫什么名字，它有我声称的返回值、

845
00:39:12,160 --> 00:39:14,750
这意味着它能给我带来一些价值。

846
00:39:14,750 --> 00:39:17,960
但如何利用这些价值，则取决于 C 语言中的我。

847
00:39:17,960 --> 00:39:21,520
因此，如果我想将该值复制到一个变量中，以便使用和重复使用、

848
00:39:21,520 --> 00:39:25,300
我使用了等号，并在等号的左侧发明了

849
00:39:25,300 --> 00:39:27,340
任何我想要的变量名。

850
00:39:27,340 --> 00:39:28,450
有一定的规则。

851
00:39:28,450 --> 00:39:29,700
有一些惯例。

852
00:39:29,700 --> 00:39:32,590
但一般情况下，如果使用全小写的单词、

853
00:39:32,590 --> 00:39:34,570
你状态不错

854
00:39:34,570 --> 00:39:37,040
但 C 比这更迂腐。

855
00:39:37,040 --> 00:39:38,980
那些曾经编程的人

856
00:39:38,980 --> 00:39:41,410
可能不习惯这样做，例如在 Python 中，它的

857
00:39:41,410 --> 00:39:43,330
我们将在几周后进入这个世界。

858
00:39:43,330 --> 00:39:48,670
您还必须告诉 C 您要存储的值的类型。

859
00:39:48,670 --> 00:39:54,370
因此，如果我确实想从用户那里获得一串文本--所以不是整数，也不是

860
00:39:54,370 --> 00:39:55,270
一个字符。

861
00:39:55,270 --> 00:39:58,430
我想要一整串文字，比如一个短语、一个句子、一个名字、

862
00:39:58,430 --> 00:39:59,270
在这种情况下

863
00:39:59,270 --> 00:40:04,250
我必须告诉 C，这个变量的类型是字符串。

864
00:40:04,250 --> 00:40:06,267
所以有点啰嗦，但你会习惯的。

865
00:40:06,267 --> 00:40:07,600
你只需做到准确无误。

866
00:40:07,600 --> 00:40:12,760
你要告诉计算机这个变量中的值是什么类型的。

867
00:40:12,760 --> 00:40:15,040
好吧，就差一点就对了、

868
00:40:15,040 --> 00:40:19,210
但我还是遗漏了一些令人讨厌的重要内容。

869
00:40:19,210 --> 00:40:20,470
还缺什么？

870
00:40:20,470 --> 00:40:21,070
是吗？

871
00:40:21,070 --> 00:40:21,970
听众：分号？

872
00:40:21,970 --> 00:40:23,178
戴维-J-马兰：所以是分号。

873
00:40:23,178 --> 00:40:24,230
这是一份声明。

874
00:40:24,230 --> 00:40:27,040
如果你愿意，这就像是一个完整的思想。

875
00:40:27,040 --> 00:40:31,680
在 "代码 "中，我确实需要用结尾的分号来结束它。

876
00:40:31,680 --> 00:40:33,430
好吧，这还真是一言难尽、

877
00:40:33,430 --> 00:40:35,720
但让我们试着在我的代码中使用它。

878
00:40:35,720 --> 00:40:40,250
让我回到 VS 代码，这里有我的代码的第 0 版。

879
00:40:40,250 --> 00:40:44,560
让我在 hello.c 的顶部加入另一个文件、

880
00:40:44,560 --> 00:40:48,790
即包含 cs50.h，这样我就可以访问了

881
00:40:48,790 --> 00:40:51,370
到 get_string 以及其他我可能需要的内容。

882
00:40:51,370 --> 00:40:56,710
现在，让我在大括号内添加一行代码。

883
00:40:56,710 --> 00:40:58,390
让我继续这么做

884
00:40:58,390 --> 00:41:03,820
字符串答案等于 get_string，引号/非引号，你叫什么名字、

885
00:41:03,820 --> 00:41:04,847
问号。

886
00:41:04,847 --> 00:41:07,180
我要在双引号前多加一个空格。

887
00:41:07,180 --> 00:41:10,430
我确实要用分号来结束我的想法。

888
00:41:10,430 --> 00:41:14,260
现在，请允许我故意犯一个错误，以说明问题。

889
00:41:14,260 --> 00:41:19,840
现在让我尝试将 hello, world 改为 hello, comma, answer。

890
00:41:19,840 --> 00:41:22,630
现在，也许，尽管这是一些新的代码行、

891
00:41:22,630 --> 00:41:24,520
你可以看到我在哪里出错了。

892
00:41:24,520 --> 00:41:26,980
不过，让我现在试着制作这个程序吧。

893
00:41:26,980 --> 00:41:27,970
到目前为止，一切顺利。

894
00:41:27,970 --> 00:41:29,120
因此没有错误信息。

895
00:41:29,120 --> 00:41:30,140
所以这是件好事。

896
00:41:30,140 --> 00:41:34,000
让我继续运行 ./hello，你会看到提示。

897
00:41:34,000 --> 00:41:35,650
你叫什么名字 问号

898
00:41:35,650 --> 00:41:37,942
注意，光标确实向右移了一个空格

899
00:41:37,942 --> 00:41:39,817
只是因为我觉得这样看起来更漂亮

900
00:41:39,817 --> 00:41:42,190
留出一点空白，而不是留下

901
00:41:42,190 --> 00:41:43,600
就在问号后面。

902
00:41:43,600 --> 00:41:44,530
让我输入我的名字。

903
00:41:44,530 --> 00:41:48,340
但是，即使你以前从未做过编程，我也在这里搞砸了。

904
00:41:48,340 --> 00:41:51,240
按下回车键后，屏幕上会出现什么？

905
00:41:51,240 --> 00:41:52,240
听众：你好，请回答。

906
00:41:52,240 --> 00:41:53,115
是的。

907
00:41:53,115 --> 00:41:54,280
你好，请回答，很有可能。

908
00:41:54,280 --> 00:41:54,730
为什么？

909
00:41:54,730 --> 00:41:56,855
因为电脑会从字面上理解我。

910
00:41:56,855 --> 00:41:59,020
如果我说 "你好"，请回答。

911
00:41:59,020 --> 00:42:01,750
这就是文本字符串，其后的新行是

912
00:42:01,750 --> 00:42:03,260
将输出到屏幕上。

913
00:42:03,260 --> 00:42:08,530
因此，我们需要用某种方法将答案输入这行代码。

914
00:42:08,530 --> 00:42:10,330
这并不像从头开始那么简单。

915
00:42:10,330 --> 00:42:14,140
您只需抓取第二个 say 块，然后将变量拖放到那里即可。

916
00:42:14,140 --> 00:42:15,670
实际上，我们需要一种新的语法。

917
00:42:15,670 --> 00:42:18,250
一开始看起来很奇怪，但它无处不在

918
00:42:18,250 --> 00:42:22,900
在当今的软件中，尤其是在 C 语言和某些其他语言的世界里。

919
00:42:22,900 --> 00:42:27,610
因此，请允许我提出如下解决方案。

920
00:42:27,610 --> 00:42:31,450
那么，当我们用 Scratch 来做这件事的时候，还记得最优雅的解决方案是

921
00:42:31,450 --> 00:42:32,350
是这里。

922
00:42:32,350 --> 00:42:36,550
我们仍然使用了 say 块，它与今天的 printf 类似。

923
00:42:36,550 --> 00:42:41,630
但我使用连接拼图和 Scratch 来组合 hello、逗号和空格、

924
00:42:41,630 --> 00:42:43,340
然后是人的名字。

925
00:42:43,340 --> 00:42:45,790
那么，我们如何将这些代码翻译成 C 语言呢？

926
00:42:45,790 --> 00:42:47,830
现在看起来有点不一样了。

927
00:42:47,830 --> 00:42:51,700
我将从带有括号和分号的 printf 开始

928
00:42:51,700 --> 00:42:53,530
代表说区块。

929
00:42:53,530 --> 00:42:55,240
但我现在该如何加入呢？

930
00:42:55,240 --> 00:42:58,330
这就是拼图没有完美转换的地方。

931
00:42:58,330 --> 00:43:00,290
这将是实现这一目标的方法。

932
00:43:00,290 --> 00:43:03,430
输入 hello、逗号和占位符。

933
00:43:03,430 --> 00:43:07,810
这就是 C 语言中的格式代码，专门用于 printf。

934
00:43:07,810 --> 00:43:11,350
它只是表示这是一个字符串的占位符。

935
00:43:11,350 --> 00:43:12,740
同样，字符串只是文本。

936
00:43:12,740 --> 00:43:17,120
也就是说，"嘿，电脑，打印出来"，"你好，逗号，空格"、

937
00:43:17,120 --> 00:43:23,200
而不是 %s。%s 被特殊处理，表示插入某个值

938
00:43:23,200 --> 00:43:23,903
这里。

939
00:43:23,903 --> 00:43:25,570
好吧，我还需要什么？

940
00:43:25,570 --> 00:43:28,030
嗯，这还是一些文字，所以我还是

941
00:43:28,030 --> 00:43:32,460
用双引号将整个内容包围起来。

942
00:43:32,460 --> 00:43:35,220
我还是要把反斜杠 n 包括在内，只是

943
00:43:35,220 --> 00:43:37,870
以保持整洁，并将光标移到下一行。

944
00:43:37,870 --> 00:43:45,120
因此，C 语言的最后一步是以某种方式将答案与单词 hello 连接起来。

945
00:43:45,120 --> 00:43:49,980
实现这一功能的方法是使用 printf，传递给它的不是一个参数，而是

946
00:43:49,980 --> 00:43:51,000
这就是我一直在做的事情。

947
00:43:51,000 --> 00:43:53,820
我一直在给它传递一串文本，引号/非引号。

948
00:43:53,820 --> 00:43:58,320
现在我要添加一个逗号，然后是我想要的值的名称

949
00:43:58,320 --> 00:44:02,760
printf 返回并插入 %s。

950
00:44:02,760 --> 00:44:04,410
而 printf 在这方面就很聪明。

951
00:44:04,410 --> 00:44:09,390
如果有一个 %s 和一个逗号后的附加参数，它就会 --

952
00:44:09,390 --> 00:44:10,980
从右到左，将其插入。

953
00:44:10,980 --> 00:44:16,470
如果逗号后有两个 %s 和两个变量，也没关系。

954
00:44:16,470 --> 00:44:19,860
如果用逗号分隔，就会将第一个 %s 插入第一个 %s

955
00:44:19,860 --> 00:44:22,380
并将第二个变量输入第二个 %s。

956
00:44:22,380 --> 00:44:24,750
因此，操作顺序就是从左至右。

957
00:44:24,750 --> 00:44:30,302
虽然没有这么漂亮或简单，但 C 语言就是这么做的。

958
00:44:30,302 --> 00:44:32,760
好吧，让我暂停一下，因为这里面有很多符号。

959
00:44:32,760 --> 00:44:35,080
有关于这项技术的问题吗？

960
00:44:35,080 --> 00:44:35,580
是吗？

961
00:44:35,580 --> 00:44:39,725
听众：为什么在上一节中不使用反斜杠 n？

962
00:44:39,725 --> 00:44:41,600
大卫-J-马兰：是的，一个非常好的问题。

963
00:44:41,600 --> 00:44:45,550
我刚才为什么要把反斜杠 n 排除在外？

964
00:44:45,550 --> 00:44:48,280
真的，如果你愿意，这只是我的审美观。

965
00:44:48,280 --> 00:44:49,760
除此之外，没有其他充分的理由。

966
00:44:49,760 --> 00:44:52,210
因此，如果我回头看看我的代码，你非常正确地

967
00:44:52,210 --> 00:44:54,460
请注意，我在这里没有使用反斜杠 n。

968
00:44:54,460 --> 00:44:57,400
这只是因为，不管我有什么风格、

969
00:44:57,400 --> 00:45:00,460
我希望在问题之后输入姓名。

970
00:45:00,460 --> 00:45:04,030
我完全可以在这里加一个反斜杠，而不是空格。

971
00:45:04,030 --> 00:45:06,490
这样我就可以在下面打字了。

972
00:45:06,490 --> 00:45:07,490
完全没问题

973
00:45:07,490 --> 00:45:09,670
只是想给你看点不一样的东西。

974
00:45:09,670 --> 00:45:10,210
接得好

975
00:45:10,210 --> 00:45:10,660
是吗？

976
00:45:10,660 --> 00:45:12,070
听众：你能举出一个有两个 %s 的例子吗？

977
00:45:12,070 --> 00:45:14,470
戴维-J-马兰：我能举一个有两个%的例子吗？

978
00:45:14,470 --> 00:45:15,250
当然。

979
00:45:15,250 --> 00:45:17,570
因此，让我在 VS 代码中这样做。

980
00:45:17,570 --> 00:45:20,050
让我清空终端窗口，清理一下。

981
00:45:20,050 --> 00:45:21,170
让我来吧

982
00:45:21,170 --> 00:45:23,620
而不是到处调用变量答案、

983
00:45:23,620 --> 00:45:26,080
让我先打电话。

984
00:45:26,080 --> 00:45:27,490
我要问两个问题。

985
00:45:27,490 --> 00:45:28,880
你叫什么名字？

986
00:45:28,880 --> 00:45:32,620
现在让我来做字符串 last equals get_string--

987
00:45:32,620 --> 00:45:35,560
哎呀，大写字母很重要，让我把大写字母 S 更正一下

988
00:45:35,560 --> 00:45:41,720
引号/非引号 你姓什么 问号 分号

989
00:45:41,720 --> 00:45:47,320
现在我们输入一个 %s 和第二个 %s。

990
00:45:47,320 --> 00:45:52,720
巧合的是，我现在要输入第一个第一个和最后一个最后一个。

991
00:45:52,720 --> 00:45:55,240
现在我要回到终端窗口。

992
00:45:55,240 --> 00:46:00,280
打招呼--祈祷一切顺利--./你好。

993
00:46:00,280 --> 00:46:02,620
这是我的第一个问题，大卫。

994
00:46:02,620 --> 00:46:04,240
这是我的第二个问题，马兰。

995
00:46:04,240 --> 00:46:05,650
然后呢？

996
00:46:05,650 --> 00:46:06,670
你好，大卫-马兰。

997
00:46:06,670 --> 00:46:08,440
因此，它只是从左到右插入。

998
00:46:08,440 --> 00:46:10,510
我所做的一切都是为了与 Scratch 保持一致。

999
00:46:10,510 --> 00:46:12,670
让我继续再撤消一次。

1000
00:46:12,670 --> 00:46:15,130
我再回去回答，就像这样。

1001
00:46:15,130 --> 00:46:17,800
我还是只问名字吧。

1002
00:46:17,800 --> 00:46:19,300
我要删除最后一次提及。

1003
00:46:19,300 --> 00:46:21,520
我将删除提及的第二个 %s。

1004
00:46:21,520 --> 00:46:24,400
现在，如果我重新编译这个更简单的版本、

1005
00:46:24,400 --> 00:46:27,720
哦，我确实搞砸了--不是故意的。

1006
00:46:27,720 --> 00:46:29,220
我做错了什么？

1007
00:46:29,220 --> 00:46:31,353
听众：你忘了改第 7 行的第一行。

1008
00:46:31,353 --> 00:46:33,270
戴维-J-马兰：是的，所以只是新手的错误。

1009
00:46:33,270 --> 00:46:37,800
因此，为了与第 0 周保持一致，我将变量改回了答案、

1010
00:46:37,800 --> 00:46:39,610
但我在这里没有改动。

1011
00:46:39,610 --> 00:46:42,750
因此，我首先使用了未声明的标识符。

1012
00:46:42,750 --> 00:46:46,470
它是未声明的，因为我在前一行声明了答案。

1013
00:46:46,470 --> 00:46:47,950
我没有先申报。

1014
00:46:47,950 --> 00:46:51,060
所以，凭直觉，我确实想把它改成这样。

1015
00:46:51,060 --> 00:46:56,740
现在让我再打一次招呼，./hello，这次只输入我的名字。

1016
00:46:56,740 --> 00:46:59,400
这就是了 你好 大卫

1017
00:46:59,400 --> 00:47:02,220
有问题吗？

1018
00:47:02,220 --> 00:47:03,390
是吗？

1019
00:47:03,390 --> 00:47:04,608
听众：[听不清]

1020
00:47:04,608 --> 00:47:06,150
啊，占位者 --

1021
00:47:06,150 --> 00:47:09,240
我放大一下 - - 只是一个百分点，然后是一个 s。

1022
00:47:09,240 --> 00:47:17,370
因此，我的字符串内部是 %s，然后我在引号外加了一个逗号、

1023
00:47:17,370 --> 00:47:23,400
然后是我要为 %s 输入值的变量名称。

1024
00:47:23,400 --> 00:47:28,080
现在请注意，严格来说，里面有两个逗号

1025
00:47:28,080 --> 00:47:30,300
第 7 行的括号。

1026
00:47:30,300 --> 00:47:33,690
然而，我声称，printf 目前、

1027
00:47:33,690 --> 00:47:37,290
只接受两个参数。

1028
00:47:37,290 --> 00:47:41,582
为什么有两个逗号却只有两个参数？

1029
00:47:41,582 --> 00:47:43,290
如果有两个逗号，你会认为

1030
00:47:43,290 --> 00:47:45,700
会有三个论点，对吗？

1031
00:47:45,700 --> 00:47:47,904
听众：逗号在引号之间、

1032
00:47:47,904 --> 00:47:49,700
所以它算一个逗号[INNAUDIBLE]

1033
00:47:49,700 --> 00:47:50,700
戴维-J-马兰：没错。

1034
00:47:50,700 --> 00:47:53,160
引号之间的逗号只是英语中的一种用法。

1035
00:47:53,160 --> 00:47:55,240
这是把 "你好 "和 "名字 "分开。

1036
00:47:55,240 --> 00:47:57,690
所以，这就是为什么它不仅用了引号、

1037
00:47:57,690 --> 00:48:01,710
这也是为什么 VS Code 等程序会语法高亮显示它的原因

1038
00:48:01,710 --> 00:48:05,580
稍有不同，就会让你觉得它与众不同、

1039
00:48:05,580 --> 00:48:08,790
尽管在这种情况下，它有点微妙 -- 浅蓝色与白色的对比 --

1040
00:48:08,790 --> 00:48:10,830
但它确实在尽力而为。

1041
00:48:10,830 --> 00:48:13,150
关于这个占位符的其他问题？

1042
00:48:13,150 --> 00:48:13,650
是吗？

1043
00:48:13,650 --> 00:48:16,390
听众：如果你想在结尾加上感叹号的话、

1044
00:48:16,390 --> 00:48:18,460
请在答案变量后加上逗号、

1045
00:48:18,460 --> 00:48:21,943
是把它放在[INNAUDIBLE]，还是要另起一行？

1046
00:48:21,943 --> 00:48:23,360
大卫-J-马兰：啊，问得好。

1047
00:48:23,360 --> 00:48:25,750
如果我想在名字后面加上一个感叹号、

1048
00:48:25,750 --> 00:48:28,230
我是否需要再添加一个占位符等等？

1049
00:48:28,230 --> 00:48:29,980
实际上，我可以做得更简单。

1050
00:48:29,980 --> 00:48:33,610
我可以把感叹号放在百分号后面。

1051
00:48:33,610 --> 00:48:35,830
我本身并不需要额外的占位符。

1052
00:48:35,830 --> 00:48:40,030
如果我现在放大并再次运行 make hello，./hello、

1053
00:48:40,030 --> 00:48:42,280
并只输入我的名字--没有感叹号--

1054
00:48:42,280 --> 00:48:45,580
现在你会更兴奋地看到，你好，逗号，大卫。

1055
00:48:45,580 --> 00:48:46,510
所以 printf 很聪明。

1056
00:48:46,510 --> 00:48:51,400
它会找出 %s 所在的位置，然后去替换它。

1057
00:48:51,400 --> 00:48:54,662
现在，让我提出一个编程中常见的问题

1058
00:48:54,662 --> 00:48:57,370
是，一旦我们决定如何设计某样东西、

1059
00:48:57,370 --> 00:49:01,240
我们常常把自己逼入绝境，为自己的决定后悔。

1060
00:49:01,240 --> 00:49:08,410
有谁能想到使用 %s 作为占位符会产生什么问题吗？

1061
00:49:08,410 --> 00:49:11,680
在这个字符串中打印出来？

1062
00:49:11,680 --> 00:49:14,635
如果我们以这种特殊的方式使用百分数，会出什么问题呢？

1063
00:49:14,635 --> 00:49:16,775
听众：[听不清]

1064
00:49:16,775 --> 00:49:17,650
是的。

1065
00:49:17,650 --> 00:49:20,320
如果你真的想说，不管出于什么奇怪的原因、

1066
00:49:20,320 --> 00:49:23,245
屏幕上的 %s -- 或者老实说，哪怕只有一个 %。

1067
00:49:23,245 --> 00:49:25,930
原来，百分号的处理方法是

1068
00:49:25,930 --> 00:49:29,650
特别是在 printf 字符串中。

1069
00:49:29,650 --> 00:49:31,460
那么，这里有什么解决办法呢？

1070
00:49:31,460 --> 00:49:34,690
解决类似问题有不同的模式。

1071
00:49:34,690 --> 00:49:40,990
但假设你想说，比如说，我得到了 100%。

1072
00:49:40,990 --> 00:49:43,480
让我来彻底改变一下。

1073
00:49:43,480 --> 00:49:47,290
所以，我在你的测试中得到了 100%的分数。

1074
00:49:47,290 --> 00:49:50,860
好了，让我先去打个招呼，回车。

1075
00:49:50,860 --> 00:49:52,950
好了，转换指定符无效。

1076
00:49:52,950 --> 00:49:55,450
我的意思是，我不知道这意味着什么，但它是下划线

1077
00:49:55,450 --> 00:49:57,410
百分号有问题。

1078
00:49:57,410 --> 00:50:00,730
原来，人类早在几年前就决定，唉，好吧，该死的。

1079
00:50:00,730 --> 00:50:01,615
我们已经使用了 %。

1080
00:50:01,615 --> 00:50:04,990
那么，两个百分号就意味着一个百分号，真的。

1081
00:50:04,990 --> 00:50:09,727
所以，现在如果我重新运行 make hello、aha、./hello，就能得到 100% 的结果。

1082
00:50:09,727 --> 00:50:13,060
老实说，有些事情你必须去问别人、

1083
00:50:13,060 --> 00:50:15,190
你必须谷歌，必须在文档中查找。

1084
00:50:15,190 --> 00:50:17,840
但这类问题总有解决的办法。

1085
00:50:17,840 --> 00:50:19,930
值得庆幸的是，这种情况并不常见。

1086
00:50:19,930 --> 00:50:21,230
是吗？

1087
00:50:21,230 --> 00:50:22,360
哦，只是说说而已。

1088
00:50:22,360 --> 00:50:23,060
还有其他问题吗？

1089
00:50:23,060 --> 00:50:23,560
是吗？

1090
00:50:23,560 --> 00:50:27,622
听众：所以，如果你有多个[听不清]

1091
00:50:27,622 --> 00:50:29,580
DAVID J. MALAN: 如果你有多个变量、

1092
00:50:29,580 --> 00:50:31,380
是按左右顺序排列的。

1093
00:50:31,380 --> 00:50:34,187
因此，printf 会分析第一个文本字符串

1094
00:50:34,187 --> 00:50:35,520
在引号之间传递。

1095
00:50:35,520 --> 00:50:40,290
不管第一个 % 是什么，逗号之后传入的第一个变量就是

1096
00:50:40,290 --> 00:50:41,207
被插在那里。

1097
00:50:41,207 --> 00:50:44,290
然后，第二个连接到第二个、第三个，再连接到第三个、

1098
00:50:44,290 --> 00:50:44,832
等等。

1099
00:50:44,832 --> 00:50:47,130
因此，它只是基于从左到右。

1100
00:50:47,130 --> 00:50:48,220
是吗？

1101
00:50:48,220 --> 00:50:50,760
听众：这更像是一个澄清问题。

1102
00:50:50,760 --> 00:50:52,453
%s 到底是什么意思？

1103
00:50:52,453 --> 00:50:54,120
戴维-J-马兰：这只是一个占位符。

1104
00:50:54,120 --> 00:50:58,570
这就是所谓的格式代码，通俗地说，就是输入某个值

1105
00:50:58,570 --> 00:50:59,070
这里。

1106
00:50:59,070 --> 00:51:04,060
而 printf -- 几十年前编写 printf 的人类决定将 %s

1107
00:51:04,060 --> 00:51:04,560
很特别

1108
00:51:04,560 --> 00:51:04,890
为什么？

1109
00:51:04,890 --> 00:51:05,490
只是因为

1110
00:51:05,490 --> 00:51:06,900
他们需要一些占位者。

1111
00:51:06,900 --> 00:51:10,110
他们认为，没有人会真的想输入 %s。

1112
00:51:10,110 --> 00:51:12,420
如果他们这样做了，他们可以只做 %%。

1113
00:51:12,420 --> 00:51:17,280
因此，他们决定以这样一种方式来实现 printf，即他们的代码可以

1114
00:51:17,280 --> 00:51:20,190
分析输入的任何文本，查找 %s、

1115
00:51:20,190 --> 00:51:24,960
然后以某种方式将后续值插入该占位符。

1116
00:51:24,960 --> 00:51:28,390
问题是

1117
00:51:28,390 --> 00:51:28,890
什么？

1118
00:51:28,890 --> 00:51:30,870
观众：如果我们想用自己名字的缩写或别的什么呢？

1119
00:51:30,870 --> 00:51:33,720
大卫-J-马兰：啊，那如果你想做一个单一的角色呢？

1120
00:51:33,720 --> 00:51:38,070
首字母缩写，如 D M 或 D J M，代表姓、名、中、后。

1121
00:51:38,070 --> 00:51:41,670
这也是一个完美的切入点，从你们俩聊到一般情况、

1122
00:51:41,670 --> 00:51:44,310
在 C 语言中将被称为数据类型。

1123
00:51:44,310 --> 00:51:48,135
原来，在 C 语言中，不仅字符串是文本。

1124
00:51:48,135 --> 00:51:50,760
在接下来的几周里，我们将更详细地了解到

1125
00:51:50,760 --> 00:51:52,560
引擎盖下面真的有一根绳子。

1126
00:51:52,560 --> 00:51:55,620
但是，程序并不是只能输出文本字符串。

1127
00:51:55,620 --> 00:51:58,860
它们确实可以输出单字符，如首字母缩写。

1128
00:51:58,860 --> 00:52:01,020
它们也可以输出整数。

1129
00:52:01,020 --> 00:52:03,510
原来 printf 有不同的格式代码

1130
00:52:03,510 --> 00:52:05,868
适用于各种不同的数据类型。

1131
00:52:05,868 --> 00:52:08,410
接下来几周我们将看到的数据类型包括

1132
00:52:08,410 --> 00:52:10,530
这里将是这个列表，你会注意到它

1133
00:52:10,530 --> 00:52:13,920
与 CS50 的功能几乎完全一致

1134
00:52:13,920 --> 00:52:17,722
如 get_char、get_int 和 get_string。

1135
00:52:17,722 --> 00:52:20,430
我们之所以这样称呼这些函数，是因为每个函数

1136
00:52:20,430 --> 00:52:23,490
的目的是返回不同类型的值。

1137
00:52:23,490 --> 00:52:26,070
在这个示例中，我们已经使用了 get_string。

1138
00:52:26,070 --> 00:52:29,880
我们很快就会看到 get_int，我们也会看到使用其他功能的机会。

1139
00:52:29,880 --> 00:52:33,660
但这些确实是现有数据的菜单

1140
00:52:33,660 --> 00:52:35,940
类型和其他类型--点、点、点--你

1141
00:52:35,940 --> 00:52:38,400
在用 C 语言编写程序时可以使用。

1142
00:52:38,400 --> 00:52:41,430
因此，您有责任提前做出决定、

1143
00:52:41,430 --> 00:52:44,250
我想在这个变量中存储一个 int 还是一个字符串？

1144
00:52:44,250 --> 00:52:48,420
或者，在编写更高级的代码时，甚至可以使用图像、声音或视频。

1145
00:52:48,420 --> 00:52:51,030
这些都可以是不同的数据类型，点点点。

1146
00:52:51,030 --> 00:52:54,300
但现在我们只关注这些基元。

1147
00:52:54,300 --> 00:52:54,988
这可真不少。

1148
00:52:54,988 --> 00:52:57,030
我们先休息五分钟。

1149
00:52:57,030 --> 00:52:57,680
还没有饼干。

1150
00:52:57,680 --> 00:53:00,180
但五分钟后，我们会再回来，深入探讨更多细节。

1151
00:53:00,180 --> 00:53:02,097
今天第二次休息时，我们将吃饼干。

1152
00:53:02,097 --> 00:53:05,640


1153
00:53:05,640 --> 00:53:07,295
好了，我们回来了。

1154
00:53:07,295 --> 00:53:09,170
所以，如果你一直在家里玩的话

1155
00:53:09,170 --> 00:53:11,587
但在路上遇到一些颠簸，这完全正常。

1156
00:53:11,587 --> 00:53:13,430
事实上，讲座的目标一般

1157
00:53:13,430 --> 00:53:16,395
让你们从概念上了解我们将

1158
00:53:16,395 --> 00:53:18,020
在本周内将会去的地方。

1159
00:53:18,020 --> 00:53:20,498
但是，通过动手实验室和问题集

1160
00:53:20,498 --> 00:53:22,790
你将真正有机会按照自己的步伐前进

1161
00:53:22,790 --> 00:53:25,730
来克服一些同样的困难。

1162
00:53:25,730 --> 00:53:28,880
但今天，让我再给你们介绍几种构件。

1163
00:53:28,880 --> 00:53:31,460
这两项翻译最初将从 Scratch 开始。

1164
00:53:31,460 --> 00:53:33,860
也就是说，就像条件句一样，就像现在的 C 语言一样、

1165
00:53:33,860 --> 00:53:36,690
在了解了如何使用函数之后

1166
00:53:36,690 --> 00:53:39,530
至少 get_string 和 printf--

1167
00:53:39,530 --> 00:53:43,370
我们可以使用像我之前创建的字符串这样的变量、

1168
00:53:43,370 --> 00:53:46,490
我现在怎样才能在其中加入决策和条件等内容呢？

1169
00:53:46,490 --> 00:53:47,100
是吗

1170
00:53:47,100 --> 00:53:50,780
那么，在 Scratch 中使用条件时，我们在左边使用了这种语法。

1171
00:53:50,780 --> 00:53:55,220
在 Scratch 中，您可以这样表达 x 和 y 这两个变量、

1172
00:53:55,220 --> 00:53:56,360
有这种关系。

1173
00:53:56,360 --> 00:54:01,020
如果 x 小于 y，则在屏幕上显示 x 小于 y。

1174
00:54:01,020 --> 00:54:03,320
好吧，让我用 C 代码翻译一下。

1175
00:54:03,320 --> 00:54:06,500
因此，在 C 语言中，相应的代码将如下所示、

1176
00:54:06,500 --> 00:54:08,390
假设 x 和 y 已经存在

1177
00:54:08,390 --> 00:54:09,530
稍后再谈。

1178
00:54:09,530 --> 00:54:13,140
请注意，我们将一再看到一种模式。

1179
00:54:13,140 --> 00:54:18,560
在 x 和小于 y 的周围要加括号，所以要加括号

1180
00:54:18,560 --> 00:54:20,390
左右的布尔表达式。

1181
00:54:20,390 --> 00:54:23,768
布尔表达式是真/假、是/否的答案、

1182
00:54:23,768 --> 00:54:26,060
你想问的问题，以便决定

1183
00:54:26,060 --> 00:54:27,680
是否做某事。

1184
00:54:27,680 --> 00:54:29,310
所以你要用括号。

1185
00:54:29,310 --> 00:54:34,550
因此，在函数中，我们使用括号来表示 printf，使用括号来表示

1186
00:54:34,550 --> 00:54:38,660
get_string，这只是风格上奇怪的不一致。

1187
00:54:38,660 --> 00:54:42,860
在使用关键词 if 时，作为最佳实践，您应该这样做、

1188
00:54:42,860 --> 00:54:44,690
在 "如果 "后面加一个空格。

1189
00:54:44,690 --> 00:54:49,070
在使用 printf 或 get_string 等函数时，就不应该这样做。

1190
00:54:49,070 --> 00:54:52,400
两者都可以使用，但你会发现从风格上来说，这些都是惯例

1191
00:54:52,400 --> 00:54:55,970
因此，在此处使用 if 时要留出空格。

1192
00:54:55,970 --> 00:54:58,850
好了，现在在大括号内

1193
00:54:58,850 --> 00:55:02,360
是要有条件执行的实际代码的位置。

1194
00:55:02,360 --> 00:55:05,270
因此，如果要打印 x 小于 y

1195
00:55:05,270 --> 00:55:08,570
只有当 x 在 C 中实际小于 y 时，您才会

1196
00:55:08,570 --> 00:55:10,670
使用这个开放式的大括号，直到现在、

1197
00:55:10,670 --> 00:55:12,740
你可能很少在你的键盘上使用 --

1198
00:55:12,740 --> 00:55:14,820
和下面的封闭式卷曲支撑。

1199
00:55:14,820 --> 00:55:17,960
如果你愿意，这些都是抱在一起的，一条或多条线

1200
00:55:17,960 --> 00:55:20,990
的代码--在精神上非常相似

1201
00:55:20,990 --> 00:55:25,050
看这里的橙色拼图块是如何与这里的紫色拼图块拥抱在一起的。

1202
00:55:25,050 --> 00:55:27,050
因此，C 语言中没有图形，全是文本。

1203
00:55:27,050 --> 00:55:31,760
因此，你可以认为这些大括号代表的是同一个意思。

1204
00:55:31,760 --> 00:55:37,460
顺便提一句，如果您在 if

1205
00:55:37,460 --> 00:55:41,430
如果你愿意的话，严格来说，你不需要大括号。

1206
00:55:41,430 --> 00:55:43,670
不过，为了保持良好的风格，还是要把它们写进去。

1207
00:55:43,670 --> 00:55:46,040
这将使你的意图更加明显。

1208
00:55:46,040 --> 00:55:48,650
如果你想用 Scratch 来表达这个意思--怎么样？

1209
00:55:48,650 --> 00:55:52,700
在这条路上，你有两条路可走，可以说是向左，也可以说是向右？

1210
00:55:52,700 --> 00:55:56,480
那么，如果 x 小于 y，我想说 x 小于 y。

1211
00:55:56,480 --> 00:56:01,190
否则，我想说的是相反的，在这种情况下，x 不小于 y。

1212
00:56:01,190 --> 00:56:03,710
因此，我是根据布尔表达式做出决定的。

1213
00:56:03,710 --> 00:56:08,340
在 C 语言中，这几乎是一样的，但你在其中加入了关键词 else --

1214
00:56:08,340 --> 00:56:11,210
因此，麻省理工学院为 Scratch 借用了相同的关键字--

1215
00:56:11,210 --> 00:56:14,690
和另一对大括号，分别表示打开和关闭。

1216
00:56:14,690 --> 00:56:17,150
你现在可能猜到里面装的是什么了吧。

1217
00:56:17,150 --> 00:56:22,905
那么，你可以打印出 x 小于 y，或者打印出 x 不小于 y。

1218
00:56:22,905 --> 00:56:25,280
好吧，如果有三岔路口怎么办？

1219
00:56:25,280 --> 00:56:29,370
在 Scratch 中，如果你愿意的话，这在图形上确实有点不方便。

1220
00:56:29,370 --> 00:56:34,490
但请注意，在 Scratch 中，我们可以这样表达如果 x 小于 y、

1221
00:56:34,490 --> 00:56:36,110
说 x 小于 y。

1222
00:56:36,110 --> 00:56:40,760
否则，如果 x 大于 y，就说 x 大于 y。

1223
00:56:40,760 --> 00:56:45,470
否则，如果 x 等于 y，就说 x 等于 y。

1224
00:56:45,470 --> 00:56:48,770
这里有一点小矛盾。

1225
00:56:48,770 --> 00:56:51,980
就在不久前，我在 C 语言中声称，等号

1226
00:56:51,980 --> 00:56:54,435
代表什么操作？

1227
00:56:54,435 --> 00:56:55,310
听众：分配任务。

1228
00:56:55,310 --> 00:56:57,770
戴维-J-马兰：从右到左分配任务。

1229
00:56:57,770 --> 00:56:59,900
只要 Scratch 真的是为孩子们准备的、

1230
00:56:59,900 --> 00:57:03,350
他们并不想在语义上纠缠不清、

1231
00:57:03,350 --> 00:57:06,360
等号在 Scratch 中表示相等。

1232
00:57:06,360 --> 00:57:09,050
不过，我们马上就需要用 C 语言来解决这个问题。

1233
00:57:09,050 --> 00:57:11,750
在 C 语言中，等号表示从右向左赋值。

1234
00:57:11,750 --> 00:57:14,210
在 Scratch 中，它的字面意思就是你所期望的。

1235
00:57:14,210 --> 00:57:17,690
好了，让我们把这段代码翻译成 C 语言、

1236
00:57:17,690 --> 00:57:20,780
该代码将与此相对应。

1237
00:57:20,780 --> 00:57:24,110
你也许可以看到，解决方案是什么，有点傻傻的、

1238
00:57:24,110 --> 00:57:28,160
与早些时候的 %% 解决方案不同，当时人类把自己画成了一个

1239
00:57:28,160 --> 00:57:29,100
另一角。

1240
00:57:29,100 --> 00:57:32,900
你说 "如果"，你说 "如果"，你说 "如果"、

1241
00:57:32,900 --> 00:57:36,620
我们是如何解决使用单个等号的问题的？

1242
00:57:36,620 --> 00:57:39,650
在 C 语言中，当您想表达相等时

1243
00:57:39,650 --> 00:57:42,110
左边的东西等于右边的东西吗？

1244
00:57:42,110 --> 00:57:45,590
两个等号紧挨着，没有空格

1245
00:57:45,590 --> 00:57:47,090
在它们之间。

1246
00:57:47,090 --> 00:57:50,960
但现在这个代码在左边和右边都是正确的、

1247
00:57:50,960 --> 00:57:53,640
无论您是用 Scratch 还是用 C 语言来做这件事。

1248
00:57:53,640 --> 00:57:58,400
但现在我们可以挑剔我们的代码，特别是其中的设计。

1249
00:57:58,400 --> 00:58:02,820
从逻辑上讲，有谁能对这段代码的设计提出批评、

1250
00:58:02,820 --> 00:58:04,280
是用 Scratch 还是用 C 语言？

1251
00:58:04,280 --> 00:58:06,200
我觉得我们可以做得更好。

1252
00:58:06,200 --> 00:58:07,576
后面怎么样？

1253
00:58:07,576 --> 00:58:10,908
听众：在大于或小于之后的唯一选项是

1254
00:58:10,908 --> 00:58:12,930
比是[INNAUDIBLE]。

1255
00:58:12,930 --> 00:58:13,930
很好。

1256
00:58:13,930 --> 00:58:17,350
从逻辑上讲，x 一定小于 y、

1257
00:58:17,350 --> 00:58:22,510
或者 x 大于 y，或者根据结论，它一定等于 y。

1258
00:58:22,510 --> 00:58:24,910
那你为什么要浪费我的时间或电脑的时间呢？

1259
00:58:24,910 --> 00:58:26,170
问第三个问题？

1260
00:58:26,170 --> 00:58:30,160
如果从逻辑上讲，正如你所指出的，你不需要再问最后这个问题、

1261
00:58:30,160 --> 00:58:31,510
不言而喻。

1262
00:58:31,510 --> 00:58:33,220
所以这只是一个小调整。

1263
00:58:33,220 --> 00:58:37,120
在 x 等于 y 的情况下，你可能要做额外的工作。

1264
00:58:37,120 --> 00:58:38,350
因此，我们可以对其进行改进。

1265
00:58:38,350 --> 00:58:42,280
就像在 Scratch 中一样，你可以使用 else 块，在 C 语言中也是如此、

1266
00:58:42,280 --> 00:58:47,110
我们是否可以将这段代码简化为 "else"，即一种逻辑上的 "万能 "代码？

1267
00:58:47,110 --> 00:58:49,720
当然，这只是处理现实问题

1268
00:58:49,720 --> 00:58:52,400
而不是最终情况。

1269
00:58:52,400 --> 00:58:55,570
好了，现在我们有能力表达条件式了

1270
00:58:55,570 --> 00:58:56,770
布尔表达式。

1271
00:58:56,770 --> 00:58:59,030
接下来，让我们在这里做点什么吧。

1272
00:58:59,030 --> 00:59:00,610
让我回到 VS 代码。

1273
00:59:00,610 --> 00:59:03,520
我关闭了 hello.c，想创建第二个文件

1274
00:59:03,520 --> 00:59:05,020
为了现在的一些演示。

1275
00:59:05,020 --> 00:59:09,160
回想一下，输入代码、空格，然后输入

1276
00:59:09,160 --> 00:59:11,440
您要创建的文件的名称。

1277
00:59:11,440 --> 00:59:13,565
例如，我可能会做 compare.c。

1278
00:59:13,565 --> 00:59:15,940
我想编写一个程序，开始比较

1279
00:59:15,940 --> 00:59:17,740
一些数值，以示说明。

1280
00:59:17,740 --> 00:59:20,050
但在此之前，让我先给你们看看

1281
00:59:20,050 --> 00:59:23,830
打开右侧的文件资源管理器，其精神类似于

1282
00:59:23,830 --> 00:59:25,180
连接到 Mac 或 PC。

1283
00:59:25,180 --> 00:59:28,750
你可以在这里点击一个图标，然后点击加号图标、

1284
00:59:28,750 --> 00:59:30,010
就会得到一个蓝色的盒子。

1285
00:59:30,010 --> 00:59:34,120
我可以输入 compare.c，然后手动创建它。

1286
00:59:34,120 --> 00:59:37,930
请注意，即使我没有输入代码，也能打开标签页。

1287
00:59:37,930 --> 00:59:41,470
同样，左边是图形用户界面（GUI）、

1288
00:59:41,470 --> 00:59:42,820
尽管是一个简单的问题。

1289
00:59:42,820 --> 00:59:45,970
右侧和底部是命令行界面、

1290
00:59:45,970 --> 00:59:47,260
但它们是一脉相承的。

1291
00:59:47,260 --> 00:59:52,090
不过好在，如果我有意无意地关闭了这个文件、

1292
00:59:52,090 --> 00:59:54,790
什么的，我可以重新打开它，而无需创建

1293
00:59:54,790 --> 00:59:58,930
只需运行相同的命令--code、space、compare.c., 就可以重新创建一个新的代码。

1294
00:59:58,930 --> 01:00:00,340
因此，代码是 VS 代码的一部分。

1295
01:00:00,340 --> 01:00:02,140
这只是一个方便用户的快捷方式。

1296
01:00:02,140 --> 01:00:05,888
但它只是创建一个文件或打开一个现有文件。

1297
01:00:05,888 --> 01:00:08,930
为了给代码腾出更多空间，我要隐藏文件资源管理器。

1298
01:00:08,930 --> 01:00:10,222
让我们开始吧。

1299
01:00:10,222 --> 01:00:14,200
让我们编写一个程序，比较人类输入的两个值、

1300
01:00:14,200 --> 01:00:15,340
但这次不是字符串。

1301
01:00:15,340 --> 01:00:17,170
让我们使用一些实际的整数。

1302
01:00:17,170 --> 01:00:20,920
好的，我将继续包含 CS50 库的头文件

1303
01:00:20,920 --> 01:00:22,090
文件顶部--

1304
01:00:22,090 --> 01:00:23,260
cs50.h.

1305
01:00:23,260 --> 01:00:25,804
我还将包含 stdio.h。

1306
01:00:25,804 --> 01:00:26,668
为什么？

1307
01:00:26,668 --> 01:00:31,190
一种是通过 get_string、get_int 等方式提供方便用户的输入。

1308
01:00:31,190 --> 01:00:35,560
在使用 stdio.h 的情况下，我可以通过 printf 得到用户友好的输出结果。

1309
01:00:35,560 --> 01:00:39,430
现在，我将盲打这行代码，我们回头再看

1310
01:00:39,430 --> 01:00:40,310
在未来几周。

1311
01:00:40,310 --> 01:00:42,520
但就目前而言，这类似于当

1312
01:00:42,520 --> 01:00:44,920
绿旗点击 Scratch 中的代码。

1313
01:00:44,920 --> 01:00:46,460
现在，让我们开始吧。

1314
01:00:46,460 --> 01:00:49,210
让我继续从用户那里获取_int

1315
01:00:49,210 --> 01:00:51,713
并询问用户，什么是 x，问号。

1316
01:00:51,713 --> 01:00:53,380
我不打算费心去做新的生产线。

1317
01:00:53,380 --> 01:00:56,410
为了美观起见，我想把它们都放在一条线上。

1318
01:00:56,410 --> 01:00:59,710
但是，当我取回一个 int 时，就像取回一个字符串一样、

1319
01:00:59,710 --> 01:01:01,580
我得到了一个返回值。

1320
01:01:01,580 --> 01:01:06,040
因此，如果我想将 get_int 的结果存储在某个地方，我应该怎么做呢？

1321
01:01:06,040 --> 01:01:07,927
我最好把它放在一个变量中。

1322
01:01:07,927 --> 01:01:09,760
我可以随意调用变量。

1323
01:01:09,760 --> 01:01:12,790
以前，我使用的是答案、第一个或最后一个。

1324
01:01:12,790 --> 01:01:14,410
现在我要使用 x。

1325
01:01:14,410 --> 01:01:18,310
但从逻辑上讲，这里还有两件事要做，尽管我们

1326
01:01:18,310 --> 01:01:19,870
技术上还没有做到这一点。

1327
01:01:19,870 --> 01:01:21,130
我还需要做什么？

1328
01:01:21,130 --> 01:01:22,410
听众：分号。

1329
01:01:22,410 --> 01:01:24,535
戴维-J-马兰：所以我需要在末尾加上分号。

1330
01:01:24,535 --> 01:01:26,010
观众：首先是int。

1331
01:01:26,010 --> 01:01:27,885
戴维-J-马兰：还有开头的 int。

1332
01:01:27,885 --> 01:01:31,257
从今天起，程序员需要决定自己要

1333
01:01:31,257 --> 01:01:32,840
将存储在变量中。

1334
01:01:32,840 --> 01:01:35,750
你只需要告诉电脑，它就会知道。

1335
01:01:35,750 --> 01:01:38,990
现在，作为对 Python 等语言和更现代语言的预告、

1336
01:01:38,990 --> 01:01:41,240
原来，人类意识到，哎呀，这太愚蠢了。

1337
01:01:41,240 --> 01:01:44,115
为什么电脑不能识别出我在这里输入了一个 int？

1338
01:01:44,115 --> 01:01:45,800
我为什么要主动告诉它？

1339
01:01:45,800 --> 01:01:48,080
因此，在现在的一些语言中，如 Python

1340
01:01:48,080 --> 01:01:50,990
会去掉一些语法，去掉分号。

1341
01:01:50,990 --> 01:01:54,530
但现在我们要看的，其实是这一切运作的起源。

1342
01:01:54,530 --> 01:01:57,380
好了，我已经用分号结束了这一行。

1343
01:01:57,380 --> 01:01:58,440
让我再做一件事。

1344
01:01:58,440 --> 01:02:02,390
让我再问一下用户，"Y "是什么，问号。

1345
01:02:02,390 --> 01:02:06,680
因此，希望用户能做出几乎相同但不同的反应。

1346
01:02:06,680 --> 01:02:10,490
让我简单地问一下，x 是否小于 y、

1347
01:02:10,490 --> 01:02:14,690
在括号中，然后是一些大括号，让我继续打印出来、

1348
01:02:14,690 --> 01:02:18,950
引号/非引号，x 小于 y 反斜线 n。

1349
01:02:18,950 --> 01:02:20,600
顺便说一句

1350
01:02:20,600 --> 01:02:23,240
我好像打得很快。

1351
01:02:23,240 --> 01:02:25,610
有些是因为 VS Code 在帮助我。

1352
01:02:25,610 --> 01:02:29,720
让我回到第一行，输入 if，按回车键。

1353
01:02:29,720 --> 01:02:33,630
现在，我只能在键盘上输入开放式大括号。

1354
01:02:33,630 --> 01:02:36,410
这是目前许多文本编辑器的一项功能。

1355
01:02:36,410 --> 01:02:37,980
它完成了你思想的一部分。

1356
01:02:37,980 --> 01:02:38,480
为什么？

1357
01:02:38,480 --> 01:02:40,580
只是为了省下一个按键，以确保

1358
01:02:40,580 --> 01:02:42,660
你不会不小心忘记关闭的那个。

1359
01:02:42,660 --> 01:02:45,750
因此，有时你会发现一些你没有键入的事情正在发生。

1360
01:02:45,750 --> 01:02:49,550
这只是 VS Code 或你未来使用的程序想帮你而已。

1361
01:02:49,550 --> 01:02:52,445
我现在手动输入 printf

1362
01:02:52,445 --> 01:02:57,050
x 小于 y 反斜线 n 加引号 分号。

1363
01:02:57,050 --> 01:03:01,400
现在让我来试着运行这个，我们会看到 --

1364
01:03:01,400 --> 01:03:02,000
让我们看看

1365
01:03:02,000 --> 01:03:05,510
所以要进行 -- 不是 hello -- 而是进行比较，因为这个文件是

1366
01:03:05,510 --> 01:03:09,050
名为 compare.c，点击回车键。

1367
01:03:09,050 --> 01:03:12,320
没有输出是好事，因为这意味着我没有搞砸。

1368
01:03:12,320 --> 01:03:16,580
让我用 ./compare 代替 ./hello，回车。

1369
01:03:16,580 --> 01:03:17,390
什么是 x？

1370
01:03:17,390 --> 01:03:18,410
1 怎么样？

1371
01:03:18,410 --> 01:03:19,040
什么是 y？

1372
01:03:19,040 --> 01:03:19,840
两个怎么样？

1373
01:03:19,840 --> 01:03:22,230
X 小于 y。

1374
01:03:22,230 --> 01:03:23,387
好吧，让我们再试一次。

1375
01:03:23,387 --> 01:03:25,220
在这里，我还能帮你省下一些按键。

1376
01:03:25,220 --> 01:03:26,360
让我清理一下屏幕。

1377
01:03:26,360 --> 01:03:30,350
而不是不停地输入 ./this 和 ./that、

1378
01:03:30,350 --> 01:03:34,610
您还可以在 VS 代码中使用键盘上的箭头键来滚动浏览

1379
01:03:34,610 --> 01:03:35,310
时间

1380
01:03:35,310 --> 01:03:37,940
因此，如果我按一次 "向上 "键，就会出现我写的最后一条命令。

1381
01:03:37,940 --> 01:03:41,480
如果我做两次，就会出现我写的倒数第二个命令。

1382
01:03:41,480 --> 01:03:43,460
因此，有时如果你看到我做事很快、

1383
01:03:43,460 --> 01:03:46,550
这只是因为我在作弊，在这样翻阅我的历史。

1384
01:03:46,550 --> 01:03:51,380
好吧，让我重新运行 ./compare，回车。

1385
01:03:51,380 --> 01:03:52,670
这次我们反过来

1386
01:03:52,670 --> 01:03:55,100
2 表示 x，1 表示 y。

1387
01:03:55,100 --> 01:03:56,870
当然，现在没有产出了。

1388
01:03:56,870 --> 01:03:58,670
好吧，这在逻辑上是可以预料的

1389
01:03:58,670 --> 01:04:00,170
因为我们这里没有其他人。

1390
01:04:00,170 --> 01:04:00,980
那就加上这个吧。

1391
01:04:00,980 --> 01:04:05,060
Else -- 现在让我们打开我的大括号，让 VS Code 来完成其中一项

1392
01:04:05,060 --> 01:04:12,350
printf, quote/unquote, x is not less than y backslash n semicolon.

1393
01:04:12,350 --> 01:04:16,430
让我再试一次-- ./compare，回车。

1394
01:04:16,430 --> 01:04:19,100
同样，2 表示 x，1 表示 y。

1395
01:04:19,100 --> 01:04:20,540
我们应该看到

1396
01:04:20,540 --> 01:04:22,990
呵呵。

1397
01:04:22,990 --> 01:04:24,830
我做错了什么？

1398
01:04:24,830 --> 01:04:27,050
为什么我看不到其他输出？

1399
01:04:27,050 --> 01:04:27,550
是吗？

1400
01:04:27,550 --> 01:04:29,592
听众：你在重建时更改了代码。

1401
01:04:29,592 --> 01:04:30,690
您需要对其进行编译。

1402
01:04:30,690 --> 01:04:31,290
戴维-J-马兰：没错。

1403
01:04:31,290 --> 01:04:34,415
你必须养成修改代码后重新编译的习惯。

1404
01:04:34,415 --> 01:04:36,420
或者说，服务器中的 0 和 1

1405
01:04:36,420 --> 01:04:39,000
在手动编译之前都是旧的。

1406
01:04:39,000 --> 01:04:41,040
所以我们要解决这个问题 - -进行比较，回车。

1407
01:04:41,040 --> 01:04:42,030
无错误信息。

1408
01:04:42,030 --> 01:04:45,420
./compare, 2, 1.

1409
01:04:45,420 --> 01:04:47,320
现在我又得到了输出结果。

1410
01:04:47,320 --> 01:04:49,230
所以 x 不小于 y。

1411
01:04:49,230 --> 01:04:52,390
如果我再加上第三个条件呢？

1412
01:04:52,390 --> 01:04:55,650
那么，我们可以高效或低效地做到这一点。

1413
01:04:55,650 --> 01:04:57,270
让我继续完善这个问题。

1414
01:04:57,270 --> 01:05:03,780
因此，如果 x 大于 y，我们就从字面上说，x 大于 y。

1415
01:05:03,780 --> 01:05:07,950
现在，如果 x 等于 y，我就可以做 x else。

1416
01:05:07,950 --> 01:05:11,080
但我认为，我们已经说过这是不必要的低效。

1417
01:05:11,080 --> 01:05:12,810
所以，我们还是来个 "一网打尽 "吧。

1418
01:05:12,810 --> 01:05:14,730
在这里，我要说的是，引号/引号、

1419
01:05:14,730 --> 01:05:19,960
x 等于 y 反斜线 n，在此处加引号。

1420
01:05:19,960 --> 01:05:24,070
因此，我认为现在通过这段代码，我们已经处理了所有三种情况。

1421
01:05:24,070 --> 01:05:28,680
让我继续正确地重新编译 - make compare, ./compare.

1422
01:05:28,680 --> 01:05:31,350
现在是 1 和 2 --

1423
01:05:31,350 --> 01:05:32,340
小于 y。

1424
01:05:32,340 --> 01:05:33,510
让我再跑一遍。

1425
01:05:33,510 --> 01:05:36,690
2 和 1 -- x 大于 y。

1426
01:05:36,690 --> 01:05:41,100
最后，1 和 1，x 等于 y。

1427
01:05:41,100 --> 01:05:43,270
因此，在大多数情况下，我们的代码越来越长。

1428
01:05:43,270 --> 01:05:45,870
我们已经编写了 21 行代码，虽然其中一些

1429
01:05:45,870 --> 01:05:47,700
只是屏幕上的单个字符。

1430
01:05:47,700 --> 01:05:49,410
其他一切几乎都一样。

1431
01:05:49,410 --> 01:05:56,190
我的 get_int 函数使用 CS50 库的头文件 stdio.h

1432
01:05:56,190 --> 01:05:58,590
为我的 printf 函数，其余的

1433
01:05:58,590 --> 01:06:01,810
也是新的条件语法。

1434
01:06:01,810 --> 01:06:04,350
那么，关于 C 语言实施的问题

1435
01:06:04,350 --> 01:06:08,237
这样的基本比较？

1436
01:06:08,237 --> 01:06:08,820
有问题吗？

1437
01:06:08,820 --> 01:06:09,320
是吗？

1438
01:06:09,320 --> 01:06:12,360
只是一个语法问题只是一个综合问题--开场

1439
01:06:12,360 --> 01:06:14,530
托架是否需要另起一行？

1440
01:06:14,530 --> 01:06:15,190
大卫-J-马兰：问得好。

1441
01:06:15,190 --> 01:06:17,440
开头的括号需要另起一行吗？

1442
01:06:17,440 --> 01:06:18,610
在 CS50 中，是的。

1443
01:06:18,610 --> 01:06:21,310
你会看到，这是提交过程的一部分、

1444
01:06:21,310 --> 01:06:25,540
我们会将您的代码与风格指南进行比较，这是行业规范。

1445
01:06:25,540 --> 01:06:29,290
一家公司会有自己的风格和代码外观。

1446
01:06:29,290 --> 01:06:31,540
公司内部一般都有自动化工具

1447
01:06:31,540 --> 01:06:35,080
有助于对代码进行反馈或使其风格化。

1448
01:06:35,080 --> 01:06:38,410
除了我们在课堂上使用的风格，还有其他风格。

1449
01:06:38,410 --> 01:06:41,500
我们特意保留并请您保留

1450
01:06:41,500 --> 01:06:44,110
将大括号放在自己一行，只要

1451
01:06:44,110 --> 01:06:48,430
因为它很像 Scratch 块的拥抱性质

1452
01:06:48,430 --> 01:06:51,370
并清楚地表明它们是平衡的、开放的和封闭的。

1453
01:06:51,370 --> 01:06:56,020
然而，在某些语言和某些程序员那里，还有另一种常见的范式

1454
01:06:56,020 --> 01:06:59,420
是在每一个人身上做这样的事情。

1455
01:06:59,420 --> 01:07:03,670
因此，开头的大括号和这里是同一行。

1456
01:07:03,670 --> 01:07:05,030
我们不建议这样做。

1457
01:07:05,030 --> 01:07:07,900
这在 JavaScript 世界和其他一些世界非常流行。

1458
01:07:07,900 --> 01:07:11,110
但在现实世界中，最终还是要由每个程序员来决定

1459
01:07:11,110 --> 01:07:13,720
和/或他们供职的公司（如适用）、

1460
01:07:13,720 --> 01:07:16,210
来决定这些事情。

1461
01:07:16,210 --> 01:07:18,640
好吧，那就超越这些条件式吧、

1462
01:07:18,640 --> 01:07:21,140
如果我们想做一件很普通的事，该怎么办？

1463
01:07:21,140 --> 01:07:24,280
因此，如今您使用的几乎所有软件或网站

1464
01:07:24,280 --> 01:07:28,360
输入 "是 "或 "否"，或只输入 "是 "或 "否"，表示您同意某些条款和条件。

1465
01:07:28,360 --> 01:07:30,280
Y代表 "是"，N代表 "否"。

1466
01:07:30,280 --> 01:07:33,195
那么，我们该如何实施某种协议制度呢？

1467
01:07:33,195 --> 01:07:34,070
让我来吧

1468
01:07:34,070 --> 01:07:37,810
让我创建一个新程序，第三个程序名为 agree.c。

1469
01:07:37,810 --> 01:07:41,230
因此，我将编写代码 agree.c，为自己添加一个新标签。

1470
01:07:41,230 --> 01:07:44,230
我将一如既往地从包含 cs50.h 开始。

1471
01:07:44,230 --> 01:07:46,480
让我们加入 stdio.h。

1472
01:07:46,480 --> 01:07:50,770
然后让我执行 int main(void)--这也是为了今天的目的、

1473
01:07:50,770 --> 01:07:53,200
我们认为这只是复制/粘贴。

1474
01:07:53,200 --> 01:07:57,850
例如，如果我只想得到 "Y "或 "N"，而不是 "Yes "或 "No"、

1475
01:07:57,850 --> 01:08:00,520
我们可以在这里使用一个更简单的变量。

1476
01:08:00,520 --> 01:08:03,800
只有一个字符、一个字符、一个字符如何？

1477
01:08:03,800 --> 01:08:07,120
例如，我可以使用 get_char 来询问用户、

1478
01:08:07,120 --> 01:08:09,760
你同意吗，问号。

1479
01:08:09,760 --> 01:08:12,880
但和以前一样，我需要把它存放在某个地方。

1480
01:08:12,880 --> 01:08:15,130
所以我不想要字符串，因为那是单字符。

1481
01:08:15,130 --> 01:08:16,180
我不想要 int。

1482
01:08:16,180 --> 01:08:17,380
我只想要一个 char。

1483
01:08:17,380 --> 01:08:21,500
字面意思是 C -H -A然后我想叫它什么都行

1484
01:08:21,500 --> 01:08:25,370
如果你的程序很简单，只有一个变量，那么这就是常规程序

1485
01:08:25,370 --> 01:08:27,040
且其类型为 char，则将其称为 c。

1486
01:08:27,040 --> 01:08:28,569
如果是 int，则称其为 i。

1487
01:08:28,569 --> 01:08:29,830
如果是字符串，则称为 s。

1488
01:08:29,830 --> 01:08:32,590
现在，我只想简单地称之为 c。

1489
01:08:32,590 --> 01:08:34,370
现在我要问一个问题。

1490
01:08:34,370 --> 01:08:43,240
因此，如果 c 等于 y，那么

1491
01:08:43,240 --> 01:08:47,290
让我继续打印出同意的反斜线 n、

1492
01:08:47,290 --> 01:08:50,380
好像他们同意了我的条款和条件。

1493
01:08:50,380 --> 01:08:51,880
否则，让我们拭目以待。

1494
01:08:51,880 --> 01:08:57,729
否则，如果字符等于等于、引号/无引号、n，那么让我继续吧

1495
01:08:57,729 --> 01:09:03,609
并打印出来，说 "不同意"，好像他们不同意似的，引号/引号。

1496
01:09:03,609 --> 01:09:07,060
我想，最初就这样吧。

1497
01:09:07,060 --> 01:09:11,830
现在，你会发现一个奇怪的地方，也许是一个不一致的地方。

1498
01:09:11,830 --> 01:09:15,760
虽然有些微妙，但有谁想说出来吗？

1499
01:09:15,760 --> 01:09:19,720
我做了一些稍微不同的事情，但还没有解释清楚。

1500
01:09:19,720 --> 01:09:20,380
你看到了吗？

1501
01:09:20,380 --> 01:09:22,625
听众：单引号。

1502
01:09:22,625 --> 01:09:23,500
是的。

1503
01:09:23,500 --> 01:09:27,880
所以，我突然用单引号来表示我的单字符

1504
01:09:27,880 --> 01:09:30,590
和双引号来表示实际的文本字符串。

1505
01:09:30,590 --> 01:09:34,210
这在 C 语言中是必要的。

1506
01:09:34,210 --> 01:09:37,420
文本，如某个人的名字、某个句子、某个段落，任何东西

1507
01:09:37,420 --> 01:09:41,380
如果字符真的超过一个，通常使用双引号。

1508
01:09:41,380 --> 01:09:42,399
事实上，你必须这样做。

1509
01:09:42,399 --> 01:09:47,620
在处理刻意使用的单个字符时，比如我是来找 y 或 n 的、

1510
01:09:47,620 --> 01:09:49,819
则必须使用单引号。

1511
01:09:49,819 --> 01:09:50,319
为什么？

1512
01:09:50,319 --> 01:09:52,240
因为这样可以确保计算机

1513
01:09:52,240 --> 01:09:54,550
知道它确实是字符而不是字符串。

1514
01:09:54,550 --> 01:09:55,930
因此，双引号适用于字符串。

1515
01:09:55,930 --> 01:09:57,520
单引号表示字符。

1516
01:09:57,520 --> 01:10:00,550
说到这里，让我继续放大。

1517
01:10:00,550 --> 01:10:04,780
让我在终端窗口中运行 make agree，回车。

1518
01:10:04,780 --> 01:10:08,770
看起来运行正常，所以让我继续进行 ./agree 操作。

1519
01:10:08,770 --> 01:10:12,250
让我先输入 y。

1520
01:10:12,250 --> 01:10:13,090
开始了

1521
01:10:13,090 --> 01:10:14,980
输入。

1522
01:10:14,980 --> 01:10:16,540
咦？

1523
01:10:16,540 --> 01:10:17,470
让我再试一次。

1524
01:10:17,470 --> 01:10:18,580
重新运行 ./同意。

1525
01:10:18,580 --> 01:10:20,170
没有呢？

1526
01:10:20,170 --> 01:10:22,480
输入。

1527
01:10:22,480 --> 01:10:25,720
为什么它的表现不符合我的预期？

1528
01:10:25,720 --> 01:10:28,480
听众：因为你输入了大写的Y和大写的N。

1529
01:10:28,480 --> 01:10:29,590
大卫-J-马兰：是的，我有点作弊了、

1530
01:10:29,590 --> 01:10:32,230
就在我开始输入时，我按下了大写锁定键。

1531
01:10:32,230 --> 01:10:32,730
为什么？

1532
01:10:32,730 --> 01:10:35,950
因为我故意想用大写字母而不是小写字母打字、

1533
01:10:35,950 --> 01:10:37,540
这也算合情合理。

1534
01:10:37,540 --> 01:10:40,728
如果强迫用户切换大写锁定，就有点令人讨厌了

1535
01:10:40,728 --> 01:10:42,770
当您只需要一个简单的答案时，可以打开或关闭按键。

1536
01:10:42,770 --> 01:10:45,310
这不是最好的用户体验。

1537
01:10:45,310 --> 01:10:47,200
但如果我合作的话，它就会起作用。

1538
01:10:47,200 --> 01:10:49,420
让我不按大写锁定键再运行一遍

1539
01:10:49,420 --> 01:10:52,030
y 小写表示 "是"。

1540
01:10:52,030 --> 01:10:55,210
啊，成功了，"不 "的小写是 "n"。

1541
01:10:55,210 --> 01:10:55,990
这招还真管用。

1542
01:10:55,990 --> 01:10:57,910
但我怎样才能让它同时发挥作用呢？

1543
01:10:57,910 --> 01:10:59,180
这样如何？

1544
01:10:59,180 --> 01:11:01,400
让我来补充两个可能性。

1545
01:11:01,400 --> 01:11:06,340
因此，如果 c 等于引号/无引号大写 Y、

1546
01:11:06,340 --> 01:11:10,720
然后也做 printf agreed 反斜杠 n。

1547
01:11:10,720 --> 01:11:17,470
下面，如果 c 等于等于单引号大写 N、

1548
01:11:17,470 --> 01:11:20,980
然后继续打印，同样，不同意。

1549
01:11:20,980 --> 01:11:23,770
我现在要说，这是正确的。

1550
01:11:23,770 --> 01:11:26,980
我很快就会同意的，./同意。

1551
01:11:26,980 --> 01:11:28,210
我会使用大写字母。

1552
01:11:28,210 --> 01:11:29,170
现在可以用了。

1553
01:11:29,170 --> 01:11:30,610
我要用大写字母。

1554
01:11:30,610 --> 01:11:32,200
它又成功了。

1555
01:11:32,200 --> 01:11:34,510
但这也许不是最好的设计。

1556
01:11:34,510 --> 01:11:39,220
让我把终端窗口隐藏起来，在屏幕上同时显示这些内容。

1557
01:11:39,220 --> 01:11:43,195
为什么说这不是最好的设计，尽管它是正确的？

1558
01:11:43,195 --> 01:11:46,250


1559
01:11:46,250 --> 01:11:49,628
我们还可以在这里抛出另一个艺术术语，比如[SNIFFS]什么的

1560
01:11:49,628 --> 01:11:51,170
这个代码有点奇怪。

1561
01:11:51,170 --> 01:11:52,450
这是一个实际的艺术术语。

1562
01:11:52,450 --> 01:11:54,100
这里有代码的味道。

1563
01:11:54,100 --> 01:11:55,930
有点不对劲。

1564
01:11:55,930 --> 01:11:56,620
为什么？

1565
01:11:56,620 --> 01:11:57,894
你怎么看？

1566
01:11:57,894 --> 01:12:01,846
听众：[听不清]

1567
01:12:01,846 --> 01:12:06,895


1568
01:12:06,895 --> 01:12:07,770
是的。

1569
01:12:07,770 --> 01:12:09,370
同样的输出一再出现。

1570
01:12:09,370 --> 01:12:10,530
我是说，我是手动输入的。

1571
01:12:10,530 --> 01:12:12,905
但老实说，我还不如直接复制粘贴呢

1572
01:12:12,905 --> 01:12:17,080
我的大部分原始代码都是为了两个大写字母而反复修改的。

1573
01:12:17,080 --> 01:12:23,370
因此，如果第 10 行和第 14 行相同，第 18 行和第 22 行相同，并且

1574
01:12:23,370 --> 01:12:26,875
其余的 if 和 else if 几乎都是一样的、

1575
01:12:26,875 --> 01:12:28,500
[有些代码的味道。

1576
01:12:28,500 --> 01:12:29,370
设计不合理。

1577
01:12:29,370 --> 01:12:29,820
为什么？

1578
01:12:29,820 --> 01:12:32,778
因为如果我现在想改变现状，就像上周在 Scratch 中一样、

1579
01:12:32,778 --> 01:12:35,970
我可能需要修改多个地方的代码，或者复制/粘贴

1580
01:12:35,970 --> 01:12:37,120
从来都不是一件好事。

1581
01:12:37,120 --> 01:12:41,280
而且，上帝也不允许我添加对 "是 "和 "否 "这两个完整单词的支持、

1582
01:12:41,280 --> 01:12:42,760
它真的会变得很长。

1583
01:12:42,760 --> 01:12:44,170
那么，我们该如何解决这个问题呢？

1584
01:12:44,170 --> 01:12:47,160
事实证明，我们可以把这些想法结合起来。

1585
01:12:47,160 --> 01:12:49,470
因此，让我先尝试改进 "是"。

1586
01:12:49,470 --> 01:12:54,325
事实证明，如果我删除该条款，我就能真正地把东西放在一起。

1587
01:12:54,325 --> 01:12:57,450
在 Scratch 中，有几块拼图，如果你没有发现的话、

1588
01:12:57,450 --> 01:12:59,430
字面上有 "或 "字和""字的

1589
01:12:59,430 --> 01:13:02,350
及其上的布尔表达式，从而可以组合布尔表达式。

1590
01:13:02,350 --> 01:13:06,600
这样，要么这个是真的，要么这个是真的，要么这个和这个都是真的。

1591
01:13:06,600 --> 01:13:09,270
在 C 语言中，你不能只说 "或"。

1592
01:13:09,270 --> 01:13:12,850
而不是使用两个竖条。

1593
01:13:12,850 --> 01:13:16,260
从逻辑上讲，竖条在一起表示或。

1594
01:13:16,260 --> 01:13:21,780
因此，我可以说，C 等于引号/引号大写的 Y，同意。

1595
01:13:21,780 --> 01:13:24,270
现在我可以删除下面的代码了。

1596
01:13:24,270 --> 01:13:29,100
让我继续说，竖条两次 C

1597
01:13:29,100 --> 01:13:32,340
等于大写的引号/无引号 N。

1598
01:13:32,340 --> 01:13:36,870
现在，我的程序大约减少了三分之一，这很好。

1599
01:13:36,870 --> 01:13:38,140
减少冗余。

1600
01:13:38,140 --> 01:13:43,290
如果我重新打开终端窗口，重新运行 make of agree、./agree、

1601
01:13:43,290 --> 01:13:49,860
现在我可以输入小 Y 或大 Y，小写和大写也是如此

1602
01:13:49,860 --> 01:13:54,090
N.那么关于这个语法还有什么问题吗？

1603
01:13:54,090 --> 01:13:56,407
只是把事情做得更严密？

1604
01:13:56,407 --> 01:13:57,990
还会有其他类似的把戏。

1605
01:13:57,990 --> 01:13:58,942
是吗？

1606
01:13:58,942 --> 01:14:01,615
听众：难道就没有忽略案件的功能吗？

1607
01:14:01,615 --> 01:14:03,240
大卫-J-马兰：这真是一个好问题。

1608
01:14:03,240 --> 01:14:06,030
难道就没有忽略案件的功能吗？

1609
01:14:06,030 --> 01:14:07,890
简而言之，有。

1610
01:14:07,890 --> 01:14:10,950
实际上，大约一周后，我们就会看到如何做到这一点。

1611
01:14:10,950 --> 01:14:13,080
在其他语言中，还有更多的方法

1612
01:14:13,080 --> 01:14:17,100
只对用户的输入进行规范化处理，丢弃任何空格字符

1613
01:14:17,100 --> 01:14:19,890
他们可能不小心按了一下，导致所有内容都变成了小写。

1614
01:14:19,890 --> 01:14:23,372
在 C 语言中，要做到这一点，我们需要付出更多的努力。

1615
01:14:23,372 --> 01:14:26,080
但事实上，早在下周，我们就会看到如何做到这一点。

1616
01:14:26,080 --> 01:14:29,490
但现在我们要比较的确实只是这些字面数值。

1617
01:14:29,490 --> 01:14:30,570
还有其他问题吗？

1618
01:14:30,570 --> 01:14:33,874
听众：所以我们假设用户输入的是他们建议的内容。

1619
01:14:33,874 --> 01:14:37,618
如果他们输入一个数字，你如何处理？

1620
01:14:37,618 --> 01:14:39,160
大卫-J-马兰：问得好。

1621
01:14:39,160 --> 01:14:42,068
所以我们假设，这个项目和我之前的所有项目都是如此、

1622
01:14:42,068 --> 01:14:45,360
当我问他们的名字时，他们输入了 David

1623
01:14:45,360 --> 01:14:49,290
而不是 123，或者，在这种情况下，他们输入了一个字符而不是

1624
01:14:49,290 --> 01:14:50,040
一个完整的词。

1625
01:14:50,040 --> 01:14:53,520
因此，这也是使用图书馆的常见功能之一。

1626
01:14:53,520 --> 01:14:59,550
因此，举例来说，如果我再次运行 "同意"，并说 "当然，请输入"、

1627
01:14:59,550 --> 01:15:01,330
它完全拒绝它。

1628
01:15:01,330 --> 01:15:01,830
为什么？

1629
01:15:01,830 --> 01:15:05,850
因为 s、u、r、e 是一串字符。

1630
01:15:05,850 --> 01:15:07,320
这不是一个单独的字符。

1631
01:15:07,320 --> 01:15:11,380
现在，我可以直接说 x，当然，它既不是 y 也不是 n。

1632
01:15:11,380 --> 01:15:14,190
但它能容忍这种情况，因为它是一个单独的字符。

1633
01:15:14,190 --> 01:15:17,790
但 CS50 的资料库内置了一些拒绝功能

1634
01:15:17,790 --> 01:15:19,210
的输入，这是意料之外的。

1635
01:15:19,210 --> 01:15:22,920
因此，如果使用 get_int，而用户输入的不是数字 1 或 2

1636
01:15:22,920 --> 01:15:26,940
但猫，C-A-T，它会再次提示他们，再次提示他们。

1637
01:15:26,940 --> 01:15:30,480
如果用 C 语言手动操作，也会出现这种情况、

1638
01:15:30,480 --> 01:15:34,068
你最终要写这么多代码来检查所有这些错误。

1639
01:15:34,068 --> 01:15:36,360
这就是为什么我们要在几周内使用这些训练轮的原因

1640
01:15:36,360 --> 01:15:38,190
只是为了让代码更健壮。

1641
01:15:38,190 --> 01:15:40,500
但几周后，我们将收回自由。

1642
01:15:40,500 --> 01:15:44,970
你会看到并理解它是如何做到这一切的。

1643
01:15:44,970 --> 01:15:46,750
好吧，这样如何？

1644
01:15:46,750 --> 01:15:50,640
现在，让我们过渡到更像 Scratch 的字面意思、

1645
01:15:50,640 --> 01:15:53,290
通过创建另一个名为喵喵的程序怎么样 --

1646
01:15:53,290 --> 01:15:54,567
so meow.c.

1647
01:15:54,567 --> 01:15:56,650
我们将不提供任何音频功能。

1648
01:15:56,650 --> 01:15:57,750
我们只能依靠印刷品。

1649
01:15:57,750 --> 01:16:00,390
假设我想写一个程序

1650
01:16:00,390 --> 01:16:03,000
并看到它只是在模拟猫叫。

1651
01:16:03,000 --> 01:16:04,960
因此，我现在还不需要任何用户输入。

1652
01:16:04,960 --> 01:16:06,960
所以我打算使用 stdio.h。

1653
01:16:06,960 --> 01:16:09,940
在这里，我将照例执行 int main(void)。

1654
01:16:09,940 --> 01:16:13,710
然后，我将继续执行 printf meow backslash n。

1655
01:16:13,710 --> 01:16:16,650
让这只猫喵喵叫三声，就像上周一样。

1656
01:16:16,650 --> 01:16:18,870
所以我要 "喵喵喵 "地叫。

1657
01:16:18,870 --> 01:16:21,100
请注意，无论您何时突出显示这些线条，都是旁观者、

1658
01:16:21,100 --> 01:16:22,350
你会看到小圆点出现。

1659
01:16:22,350 --> 01:16:24,780
这只是一个视觉提示，让你搞清楚

1660
01:16:24,780 --> 01:16:26,460
你缩进了多少个空格。

1661
01:16:26,460 --> 01:16:30,133
VS Code 和许多编辑器一样，会自动为你缩进代码。

1662
01:16:30,133 --> 01:16:32,550
我没有每次都按四下空格键。

1663
01:16:32,550 --> 01:16:34,020
我连 Tab 都没打。

1664
01:16:34,020 --> 01:16:38,280
不过，在 C 语言中，缩进行的惯例确实是

1665
01:16:38,280 --> 01:16:40,410
酌情增加四个空格

1666
01:16:40,410 --> 01:16:41,933
所以不是三个，也不是五个。

1667
01:16:41,933 --> 01:16:44,100
这些小点能帮助你看清事物，让它们

1668
01:16:44,100 --> 01:16:45,850
作为一种良好的风格。

1669
01:16:45,850 --> 01:16:48,600
好吧，那么这个计划，我现在就规定一下、

1670
01:16:48,600 --> 01:16:49,600
确实会奏效。

1671
01:16:49,600 --> 01:16:52,560
让喵喵叫--有点可爱--现在又喵喵叫了。

1672
01:16:52,560 --> 01:16:54,000
那里，三次。

1673
01:16:54,000 --> 01:16:54,540
正确。

1674
01:16:54,540 --> 01:16:55,500
它喵喵叫了三声。

1675
01:16:55,500 --> 01:16:57,060
当然，这并不是精心设计的。

1676
01:16:57,060 --> 01:16:58,935
上周的 Scratch 设计得并不好。

1677
01:16:58,935 --> 01:17:00,480
为什么？

1678
01:17:00,480 --> 01:17:03,130
我应该怎么做？

1679
01:17:03,130 --> 01:17:03,630
是吗？

1680
01:17:03,630 --> 01:17:04,120
听众：循环？

1681
01:17:04,120 --> 01:17:05,412
听众：这可能是一个循环。

1682
01:17:05,412 --> 01:17:07,140
是的。

1683
01:17:07,140 --> 01:17:09,310
这是一个完美的循环机会。

1684
01:17:09,310 --> 01:17:09,810
为什么？

1685
01:17:09,810 --> 01:17:12,810
因为如果你想改一下这些词的大写、

1686
01:17:12,810 --> 01:17:16,260
或者你想把声音改成狗的 "汪汪 "声什么的、

1687
01:17:16,260 --> 01:17:18,390
你得改一、二、三个地方。

1688
01:17:18,390 --> 01:17:20,160
这也太傻了吧？

1689
01:17:20,160 --> 01:17:23,020
在代码中，您最好在一个地方进行更改。

1690
01:17:23,020 --> 01:17:24,880
那我该怎么做呢？

1691
01:17:24,880 --> 01:17:27,120
是的，我们可以引入一个循环。

1692
01:17:27,120 --> 01:17:30,420
但我们还需要另一个在 Scratch 中使用过的构件、

1693
01:17:30,420 --> 01:17:32,710
即那些被称为变量的东西。

1694
01:17:32,710 --> 01:17:35,070
因此，回想一下变量，就像一个代数-- x、

1695
01:17:35,070 --> 01:17:38,520
y、z，等等，都可以为你存储一个值。

1696
01:17:38,520 --> 01:17:42,630
Scratch 中的变量可能是这样的

1697
01:17:42,630 --> 01:17:45,880
使用这块橙色拼图可以设置任意名称的变量、

1698
01:17:45,880 --> 01:17:46,890
而不仅仅是 x、y 或 z。

1699
01:17:46,890 --> 01:17:49,710
不过，你也可以叫它更有描述性的名字，比如计数器、

1700
01:17:49,710 --> 01:17:51,840
并将其设置为某个值。

1701
01:17:51,840 --> 01:17:56,490
在 C 语言中，这样做的方法与某些语法的精神类似

1702
01:17:56,490 --> 01:17:57,570
我们迄今为止看到的

1703
01:17:57,570 --> 01:17:59,910
首先，您需要说出变量的名称、

1704
01:17:59,910 --> 01:18:01,740
一个等号，然后是数值。

1705
01:18:01,740 --> 01:18:05,470
您也要对其进行初始化，因此要从右向左复制。

1706
01:18:05,470 --> 01:18:05,970
为什么？

1707
01:18:05,970 --> 01:18:09,570
因为等号同样表示从右到左的分配。

1708
01:18:09,570 --> 01:18:10,740
但这还不够。

1709
01:18:10,740 --> 01:18:12,282
你可能已经有了这种直觉。

1710
01:18:12,282 --> 01:18:16,170
为了创建变量，这行代码大概还缺什么？

1711
01:18:16,170 --> 01:18:16,767
听众： Int.

1712
01:18:16,767 --> 01:18:19,350
戴维-J-马兰：所以我们需要确保计算机知道

1713
01:18:19,350 --> 01:18:20,610
这确实是一个 int。

1714
01:18:20,610 --> 01:18:23,802
最后还有分号。

1715
01:18:23,802 --> 01:18:25,260
至此，我的思考结束了。

1716
01:18:25,260 --> 01:18:27,302
所以比 Scratch 更烦人，但我们

1717
01:18:27,302 --> 01:18:28,660
开始看到这里的模式了。

1718
01:18:28,660 --> 01:18:30,810
因此，并非每一种语法都是新的。

1719
01:18:30,810 --> 01:18:33,480
好吧，如果你想将计数器递增 1、

1720
01:18:33,480 --> 01:18:37,480
Scratch 使用动词 change，意思是将数值添加到计数器中。

1721
01:18:37,480 --> 01:18:41,700
因此，如果我想递增一个名为 counter 的现有变量、

1722
01:18:41,700 --> 01:18:43,930
这种语法更有趣一些。

1723
01:18:43,930 --> 01:18:48,690
原来代码是这样的，这看起来几乎是个悖论。

1724
01:18:48,690 --> 01:18:51,990
计数器如何等于计数器加 1？

1725
01:18:51,990 --> 01:18:53,160
数学不是这样的。

1726
01:18:53,160 --> 01:18:56,860
但同样，一个等号是从右往左赋值的。

1727
01:18:56,860 --> 01:18:59,910
这就是说，不管计数器的值是多少，都要加 1、

1728
01:18:59,910 --> 01:19:03,930
并将该值从右向左复制到计数器本身。

1729
01:19:03,930 --> 01:19:07,530
你仍然需要分号，但我认为

1730
01:19:07,530 --> 01:19:13,330
在更新现有变量时，无需提及关键字 int。

1731
01:19:13,330 --> 01:19:18,060
因此，只有在 C 语言中创建变量时，才会使用字符串或

1732
01:19:18,060 --> 01:19:19,950
或任何其他我们最终将

1733
01:19:19,950 --> 01:19:23,370
只有在首次创建或初始化时才能看到。

1734
01:19:23,370 --> 01:19:25,780
此后，如果你想改变它，它也只是存在而已。

1735
01:19:25,780 --> 01:19:27,060
这是你给的词。

1736
01:19:27,060 --> 01:19:29,950
电脑很聪明，至少能记住它的类型。

1737
01:19:29,950 --> 01:19:32,100
因此，这一行现在已经完成

1738
01:19:32,100 --> 01:19:35,580
事实证明，在代码中，正如我们将要看到的，添加以下内容是很常见的

1739
01:19:35,580 --> 01:19:37,740
一起，逐一递增。

1740
01:19:37,740 --> 01:19:40,710
因此，同一个想法实际上有不同的语法。

1741
01:19:40,710 --> 01:19:43,290
这里的专业术语是 "句法糖"。

1742
01:19:43,290 --> 01:19:46,410
在代码中，做同一件事往往有很多种方法、

1743
01:19:46,410 --> 01:19:49,900
尽管归根结底，它们的功能完全相同。

1744
01:19:49,900 --> 01:19:54,120
因此，举例来说，如果在使用 CS50 几天后，您觉得这样做有点乏味

1745
01:19:54,120 --> 01:19:57,765
要继续输入一些程序，可以简化为这样。

1746
01:19:57,765 --> 01:19:59,340
这就是语法糖。

1747
01:19:59,340 --> 01:20:03,810
您可以使用等号加号，只在左侧提及一次变量名、

1748
01:20:03,810 --> 01:20:06,480
它只知道这意味着前一件事。

1749
01:20:06,480 --> 01:20:10,420
只是稍微简洁了一些。

1750
01:20:10,420 --> 01:20:12,900
在数值上加 1 也是很常见的事情。

1751
01:20:12,900 --> 01:20:13,800
而且不一定是 1。

1752
01:20:13,800 --> 01:20:14,800
但在这种情况下，确实如此。

1753
01:20:14,800 --> 01:20:19,110
但如果确实是 1，则可以进一步收紧代码，只做这件事、

1754
01:20:19,110 --> 01:20:20,550
反++。

1755
01:20:20,550 --> 01:20:25,740
因此，在 C 语言中，任何时候看到 ++，都意味着在该特定值的基础上加 1。

1756
01:20:25,740 --> 01:20:26,472
变量。

1757
01:20:26,472 --> 01:20:28,680
在另一个方向上还有其他方法。

1758
01:20:28,680 --> 01:20:31,420
如果要从变量中减去 1、

1759
01:20:31,420 --> 01:20:34,890
可以使用前面的任何语法，用减号代替正号、

1760
01:20:34,890 --> 01:20:38,490
或者你可以更简洁地进行反击。

1761
01:20:38,490 --> 01:20:42,520
这是典型的 C 语言程序员的做法。

1762
01:20:42,520 --> 01:20:45,210
好吧，如果我们没有变量，让我们

1763
01:20:45,210 --> 01:20:47,500
去用 loop 解决喵喵叫的问题。

1764
01:20:47,500 --> 01:20:49,320
因此，在 Scratch 中，我们可以看到这样的循环。

1765
01:20:49,320 --> 01:20:52,680
当然，这让猫喵喵叫了三声。

1766
01:20:52,680 --> 01:20:54,480
如何在 C 语言中做到这一点？

1767
01:20:54,480 --> 01:20:58,900
现在，这里的代码变得更加复杂了。

1768
01:20:58,900 --> 01:21:01,140
但如果你理解了每一行、

1769
01:21:01,140 --> 01:21:03,520
我们就会顺理成章地知道发生了什么。

1770
01:21:03,520 --> 01:21:07,320
因此，我认为，以下是一种实施方法

1771
01:21:07,320 --> 01:21:12,330
这有点荒谬，对吗？

1772
01:21:12,330 --> 01:21:15,900
我们从两块超级简单的拼图变成了这样，我的天啊、

1773
01:21:15,900 --> 01:21:18,990
这是 1、2、3、4、5、6 行代码，都相当复杂。

1774
01:21:18,990 --> 01:21:20,740
于是事态迅速升级。

1775
01:21:20,740 --> 01:21:21,960
但每条线路都在做什么呢？

1776
01:21:21,960 --> 01:21:24,120
我们还会看到其他更简单的方法。

1777
01:21:24,120 --> 01:21:28,710
因此，我们将一个名为 counter 的变量初始化为 3，就像之前一样。

1778
01:21:28,710 --> 01:21:29,370
为什么？

1779
01:21:29,370 --> 01:21:32,800
那么，"循环 "或 "重复三次 "是什么意思呢？

1780
01:21:32,800 --> 01:21:35,190
好吧，这就好比一件事做了三次、

1781
01:21:35,190 --> 01:21:37,260
然后做，然后倒数，然后

1782
01:21:37,260 --> 01:21:41,080
做，然后倒数，再做，直到数完为止。

1783
01:21:41,080 --> 01:21:44,910
这就是声明一个名为 counter 的变量，并将其设置为 3。

1784
01:21:44,910 --> 01:21:50,370
然后，我在 C 语言中诱导一个循环，其精神与重复 3 相似、

1785
01:21:50,370 --> 01:21:52,440
但你必须自己做更多的计算。

1786
01:21:52,440 --> 01:21:54,990
所以我在括号里提出了这个问题、

1787
01:21:54,990 --> 01:21:59,200
当 count 大于 0 时，我该怎么办？

1788
01:21:59,200 --> 01:22:04,080
好吧，根据大括号内的缩进，我想喵一次。

1789
01:22:04,080 --> 01:22:06,990
然后，说白了，最后一行代码是做什么用的？

1790
01:22:06,990 --> 01:22:12,120
如果计数器一开始是 3，那么减去 1 后就变成了 2。

1791
01:22:12,120 --> 01:22:13,320
然后呢？

1792
01:22:13,320 --> 01:22:17,620
就像 Scratch 中的循环一样，它知道如何来回循环。

1793
01:22:17,620 --> 01:22:21,010
尽管 Scratch 中有一个漂亮的箭头，但这里没有、

1794
01:22:21,010 --> 01:22:26,310
C 知道这样做一次又一次，一次又一次，不断地问这个问题

1795
01:22:26,310 --> 01:22:28,870
然后在最后更新该值。

1796
01:22:28,870 --> 01:22:33,690
因此，如果我只强调其中的几个步骤，变量一开始就是 3。

1797
01:22:33,690 --> 01:22:35,100
实际上，让我简化一下 2.

1798
01:22:35,100 --> 01:22:37,980
我之前说过，在使用单一变量时、

1799
01:22:37,980 --> 01:22:41,280
人们通常只用 i 来表示 int，或用 c 来表示 char、

1800
01:22:41,280 --> 01:22:43,480
或 s 表示字符串，除非您有多个变量。

1801
01:22:43,480 --> 01:22:44,730
所以，让我把代码写得更密一些。

1802
01:22:44,730 --> 01:22:47,220
而这已经让它看起来更容易接受一些。

1803
01:22:47,220 --> 01:22:50,320
实际上，让我把它进一步收紧，增加一个步骤。

1804
01:22:50,320 --> 01:22:52,860
因此，现在这一切都非常紧凑、简洁

1805
01:22:52,860 --> 01:22:54,653
因为您现在就可以编写这段代码。

1806
01:22:54,653 --> 01:22:56,320
那么，这里究竟会发生什么呢？

1807
01:22:56,320 --> 01:22:59,550
第一行代码执行后，i 初始化为 3。

1808
01:22:59,550 --> 01:23:00,900
然后我们检查条件。

1809
01:23:00,900 --> 01:23:03,840
当 i 大于 0 时，i 是否大于 0？

1810
01:23:03,840 --> 01:23:05,580
嗯，显然是我的三根手指。

1811
01:23:05,580 --> 01:23:07,590
所以我们在屏幕上打印出了喵喵。

1812
01:23:07,590 --> 01:23:13,110
然后从 i 中减去 1，此时 i 的值为 2。

1813
01:23:13,110 --> 01:23:15,330
然后代码返回到条件。

1814
01:23:15,330 --> 01:23:17,580
注意，这里的条件是在括号里的。

1815
01:23:17,580 --> 01:23:19,420
这是另一个布尔表达式。

1816
01:23:19,420 --> 01:23:23,340
因此，循环可以使用布尔表达式，就像条件使用

1817
01:23:23,340 --> 01:23:24,990
布尔表达式来做决定。

1818
01:23:24,990 --> 01:23:27,840
不过，这个环节决定的不是做这件事还是做那件事

1819
01:23:27,840 --> 01:23:31,330
而是是否要一而再、再而三地做同样的事情。

1820
01:23:31,330 --> 01:23:34,200
当它一行接一行地敲击代码时、

1821
01:23:34,200 --> 01:23:40,450
最终会降到 1，然后是 0，最后停止。

1822
01:23:40,450 --> 01:23:45,330
换个角度看--这里有一些道具--假设这个球在这里

1823
01:23:45,330 --> 01:23:49,410
是变量，用三个压力球将其初始化为 3、

1824
01:23:49,410 --> 01:23:51,570
你可以做三次，对不对？

1825
01:23:51,570 --> 01:23:53,320
如果我想送出三个压力球 --

1826
01:23:53,320 --> 01:23:56,653
这是您免费获得压力球的机会，无需回答任何问题。

1827
01:23:56,653 --> 01:23:57,400
好了，我们走吧。

1828
01:23:57,400 --> 01:24:00,180
因此，我们开始从我的变量中减去 1。

1829
01:24:00,180 --> 01:24:01,830
我还剩下两个。

1830
01:24:01,830 --> 01:24:02,460
我的天啊

1831
01:24:02,460 --> 01:24:04,845
好吧 别告诉桑德斯

1832
01:24:04,845 --> 01:24:07,470
[哦，对不起

1833
01:24:07,470 --> 01:24:08,080
哦。

1834
01:24:08,080 --> 01:24:08,580
[笑声]

1835
01:24:08,580 --> 01:24:10,350
好吧，结局很糟糕。

1836
01:24:10,350 --> 01:24:11,070
致歉。

1837
01:24:11,070 --> 01:24:11,570
好的

1838
01:24:11,570 --> 01:24:13,740
但现在的教育重点是

1839
01:24:13,740 --> 01:24:17,037
我的变量被进一步递减，以至于 --

1840
01:24:17,037 --> 01:24:18,370
我不会再扔那么远了。

1841
01:24:18,370 --> 01:24:19,620
我做不到

1842
01:24:19,620 --> 01:24:20,143
开始了

1843
01:24:20,143 --> 01:24:21,060
好了，我们开始吧。

1844
01:24:21,060 --> 01:24:22,740
最后一项减法。

1845
01:24:22,740 --> 01:24:24,880
现在我们的变量是空的。

1846
01:24:24,880 --> 01:24:28,380
所以我们有三个压力球，这就是变量的全部。

1847
01:24:28,380 --> 01:24:29,475
这是某种存储设备。

1848
01:24:29,475 --> 01:24:32,100
当然，它实际上是在计算机内存中实现的。

1849
01:24:32,100 --> 01:24:35,860
但从隐喻的角度来看，它其实只是一个具有一定价值的碗。

1850
01:24:35,860 --> 01:24:37,800
而每当你或，在这种情况下，减去、

1851
01:24:37,800 --> 01:24:39,840
你只是在改变该变量的值。

1852
01:24:39,840 --> 01:24:43,830
当然，括号中的代码只是检查、

1853
01:24:43,830 --> 01:24:44,610
碗是空的吗？

1854
01:24:44,610 --> 01:24:45,360
碗是空的吗？

1855
01:24:45,360 --> 01:24:46,570
碗是空的吗？

1856
01:24:46,570 --> 01:24:50,350
也就是，i 是否大于 0？

1857
01:24:50,350 --> 01:24:55,210
对我们如何以这种方式实现循环有任何疑问吗？

1858
01:24:55,210 --> 01:24:58,080
下课后我还欠你一个压力球呢

1859
01:24:58,080 --> 01:24:59,820
对环路有疑问？

1860
01:24:59,820 --> 01:25:03,240
好吧，事实证明，这有点难看。

1861
01:25:03,240 --> 01:25:05,580
这真的开始让人失去乐趣了

1862
01:25:05,580 --> 01:25:09,422
当你必须写出这一连串步骤时，你就会感到编程的困难。

1863
01:25:09,422 --> 01:25:11,380
原来，还有其他方法可以做到这一点。

1864
01:25:11,380 --> 01:25:13,110
但首先，让我们从逻辑上看看，还能怎么做

1865
01:25:13,110 --> 01:25:16,410
你可能会表达这个意思，因为我们一直使用零有点奇怪。

1866
01:25:16,410 --> 01:25:19,890
因此，还有一种方法就是反转逻辑。

1867
01:25:19,890 --> 01:25:23,820
你完全可以从变量开始，称 i 等于 1。

1868
01:25:23,820 --> 01:25:28,290
然后你可以问，i 是否小于或等于 3？

1869
01:25:28,290 --> 01:25:30,210
注意这里的新语法。

1870
01:25:30,210 --> 01:25:33,330
在典型的键盘上，有小于

1871
01:25:33,330 --> 01:25:35,370
或等号 或大于或等于号

1872
01:25:35,370 --> 01:25:37,870
就像你在数学课上写的那样，1 比另一个大。

1873
01:25:37,870 --> 01:25:42,390
因此，在 C 语言中，您可以使用两个字符，即小于和等号

1874
01:25:42,390 --> 01:25:45,360
或（如果合适）大于，后面跟等号。

1875
01:25:45,360 --> 01:25:47,370
这就顺理成章地抓住了这一想法。

1876
01:25:47,370 --> 01:25:50,580
请注意，我正在改变我的问题。

1877
01:25:50,580 --> 01:25:53,910
我将 i 初始化为 1，然后将其最终递增

1878
01:25:53,910 --> 01:25:55,830
到 2，再到 3。

1879
01:25:55,830 --> 01:25:57,930
但因为我做的少于或等于、

1880
01:25:57,930 --> 01:26:00,340
还是要从 1、2、3 开始。

1881
01:26:00,340 --> 01:26:01,530
这样也行得通。

1882
01:26:01,530 --> 01:26:03,810
同样，我们还可以用另一种方法来解决这个问题。

1883
01:26:03,810 --> 01:26:10,320
我们可以将 i 初始化为 0，然后说，好吧，i 小于 3

1884
01:26:10,320 --> 01:26:11,640
并不断递增。

1885
01:26:11,640 --> 01:26:14,940
而我所展示的最后一种形式实际上是最经典的。

1886
01:26:14,940 --> 01:26:18,420
从 1 到 3 的思考方式可能最像人类。

1887
01:26:18,420 --> 01:26:22,620
从 3 比 0 的角度来考虑问题，可能最有压力、

1888
01:26:22,620 --> 01:26:23,740
倒计时

1889
01:26:23,740 --> 01:26:26,730
但通常情况下，大多数程序员的常用语法是

1890
01:26:26,730 --> 01:26:31,440
一旦你适应了从 0 开始计数，你就会发现总是从 0 开始计数

1891
01:26:31,440 --> 01:26:35,610
并向上数到小于您正在向上数的值。

1892
01:26:35,610 --> 01:26:40,043
因此，在这里将其改为小于或等于 3 是不正确的，为什么？

1893
01:26:40,043 --> 01:26:42,960
如果我把小于改为小于或等于，结果会怎样？

1894
01:26:42,960 --> 01:26:44,340
它只会喵两声。

1895
01:26:44,340 --> 01:26:47,280
是啊 它还会多喵一声 实际上是第四次 总共喵了四次

1896
01:26:47,280 --> 01:26:47,780
对不对？

1897
01:26:47,780 --> 01:26:51,150
因为你会从 0 开始，然后是 1、2、3。

1898
01:26:51,150 --> 01:26:53,220
小于或等于 3 -- 抱歉 --

1899
01:26:53,220 --> 01:26:55,420
3 会给你第四次。

1900
01:26:55,420 --> 01:26:58,650
因此，我们确实希望 "比 "只少一个。

1901
01:26:58,650 --> 01:27:01,198
好了，现在我们有了这些选项、

1902
01:27:01,198 --> 01:27:02,490
让我再给你举一个例子。

1903
01:27:02,490 --> 01:27:04,907
这个也需要更多时间来适应、

1904
01:27:04,907 --> 01:27:07,210
但这可能是更常见的写法。

1905
01:27:07,210 --> 01:27:11,590
请允许我提出如下实施建议。

1906
01:27:11,590 --> 01:27:13,390
让我回到我的代码这里。

1907
01:27:13,390 --> 01:27:20,040
让我来看看我的几个 printfs，除一个外全部删除

1908
01:27:20,040 --> 01:27:21,000
最终。

1909
01:27:21,000 --> 01:27:22,750
让我们用代码来实现这一点。

1910
01:27:22,750 --> 01:27:30,510
那么，当 i 小于 3 时，让 int i 得到 0 怎么样？

1911
01:27:30,510 --> 01:27:33,960
那么，让我们继续说 printf quote/unquote meow--

1912
01:27:33,960 --> 01:27:36,930
喵--喵 反斜线 n.

1913
01:27:36,930 --> 01:27:41,310
然后我们要做 i 减 minus 还是 plus plus？

1914
01:27:41,310 --> 01:27:42,237
加加。

1915
01:27:42,237 --> 01:27:44,570
大卫-J-马兰：所以，加上加上，因为我们是从 0 开始的

1916
01:27:44,570 --> 01:27:47,120
并上升至但不超过 3。

1917
01:27:47,120 --> 01:27:51,678
所以，现在让我在清空终端 ./meow 后，继续制作喵星人、

1918
01:27:51,678 --> 01:27:52,970
还是一样正确。

1919
01:27:52,970 --> 01:27:55,400
但它更

1920
01:27:55,400 --> 01:27:56,730
它的设计更好一些。

1921
01:27:56,730 --> 01:27:57,230
为什么？

1922
01:27:57,230 --> 01:28:00,770
因为现在如果我想把它从 3 次改为 30 次、

1923
01:28:00,770 --> 01:28:01,850
我可以在那里更改。

1924
01:28:01,850 --> 01:28:03,770
我可以重新编译我的代码。

1925
01:28:03,770 --> 01:28:06,020
我可以用 ./meow 来完成。

1926
01:28:06,020 --> 01:28:09,450
我不必再复制粘贴 27 次才能达到这种效果。

1927
01:28:09,450 --> 01:28:13,400
我甚至可以通过改变一个位置来改变单词的内容。

1928
01:28:13,400 --> 01:28:15,920
但事实证明，还有其他方法可以做到这一点。

1929
01:28:15,920 --> 01:28:20,502
我建议，我们也向你介绍一下所谓的 for 循环。

1930
01:28:20,502 --> 01:28:22,460
所以，如果你想重复三遍、

1931
01:28:22,460 --> 01:28:25,940
你完全可以采用我们刚才看到的 while 循环方法、

1932
01:28:25,940 --> 01:28:27,500
或者你也可以这样做。

1933
01:28:27,500 --> 01:28:30,270
而这个需要更多的时间来适应、

1934
01:28:30,270 --> 01:28:34,200
但它将所有相同的逻辑整合到了一条线上。

1935
01:28:34,200 --> 01:28:36,830
请注意，这里有一个关键词。

1936
01:28:36,830 --> 01:28:40,730
在这里，"为 "只是一个介词，一般是指"......"、

1937
01:28:40,730 --> 01:28:42,110
这里有一个循环。

1938
01:28:42,110 --> 01:28:46,097
这里的括号内不仅仅是布尔表达式。

1939
01:28:46,097 --> 01:28:47,930
这就是事情变得有点奇怪的地方。

1940
01:28:47,930 --> 01:28:50,900
分号左边有三样东西

1941
01:28:50,900 --> 01:28:54,230
在两个分号中间，在分号右边。

1942
01:28:54,230 --> 01:28:58,198
这确实是我们唯一能看到分号的地方，而且很奇怪。

1943
01:28:58,198 --> 01:28:59,990
通常情况下，它都在线路的末端。

1944
01:28:59,990 --> 01:29:02,030
现在是两个人在队伍中间、

1945
01:29:02,030 --> 01:29:04,920
但这就是人类多年前决定的方式。

1946
01:29:04,920 --> 01:29:06,080
这是在干什么？

1947
01:29:06,080 --> 01:29:07,850
几乎一样。

1948
01:29:07,850 --> 01:29:12,320
它将把一个名为 i 的变量初始化为 0。

1949
01:29:12,320 --> 01:29:14,240
然后进行检查。

1950
01:29:14,240 --> 01:29:19,880
如果小于 3，就会执行大括号中的操作、

1951
01:29:19,880 --> 01:29:22,980
最后，它将增加 i 并重复。

1952
01:29:22,980 --> 01:29:26,240
因此，首先，我将依次强调这些内容。

1953
01:29:26,240 --> 01:29:28,340
初始化为 0，就像之前一样。

1954
01:29:28,340 --> 01:29:30,170
然后对这一条件进行检查。

1955
01:29:30,170 --> 01:29:32,150
这是一个布尔表达式。

1956
01:29:32,150 --> 01:29:34,610
是或否，真或假，就是它的答案。

1957
01:29:34,610 --> 01:29:37,970
如果 i 小于 3，那么一旦从 0 开始，就应该小于 3、

1958
01:29:37,970 --> 01:29:40,550
好吧，那我们就继续打印 "喵喵"。

1959
01:29:40,550 --> 01:29:42,350
然后，i 将被递增。

1960
01:29:42,350 --> 01:29:43,580
因此，它从 0 开始。

1961
01:29:43,580 --> 01:29:45,170
现在是 1。

1962
01:29:45,170 --> 01:29:48,150
此时，将再次检查布尔表达式。

1963
01:29:48,150 --> 01:29:50,840
这样你就不会一直把 i 改回 0。

1964
01:29:50,840 --> 01:29:53,210
第一步只有一次。

1965
01:29:53,210 --> 01:29:56,270
但现在，你重复了其他三个亮点。

1966
01:29:56,270 --> 01:29:57,770
我检查 i 是否小于 3。

1967
01:29:57,770 --> 01:29:58,320
就是这样。

1968
01:29:58,320 --> 01:29:59,600
所以我打印了喵喵。

1969
01:29:59,600 --> 01:30:00,875
然后将 i.

1970
01:30:00,875 --> 01:30:03,410
我检查 i（现在为 2）是否小于 3。

1971
01:30:03,410 --> 01:30:03,980
就是这样。

1972
01:30:03,980 --> 01:30:05,240
我打印了喵喵。

1973
01:30:05,240 --> 01:30:06,380
i 会递增。

1974
01:30:06,380 --> 01:30:07,100
我现在检查。

1975
01:30:07,100 --> 01:30:08,120
i 小于 3 吗？

1976
01:30:08,120 --> 01:30:11,360
不，不是的，因为 3 并不小于 3。

1977
01:30:11,360 --> 01:30:12,800
整件事就这样停止了。

1978
01:30:12,800 --> 01:30:15,950
以及大括号下面的代码（如果有的话）、

1979
01:30:15,950 --> 01:30:17,420
开始执行。

1980
01:30:17,420 --> 01:30:21,470
就像在 Scratch 中一样，你跳出了循环，拼图碎片

1981
01:30:21,470 --> 01:30:22,610
被拥抱

1982
01:30:22,610 --> 01:30:31,520
那么，关于循环的另一种语法，又名 for 循环，有什么问题吗？

1983
01:30:31,520 --> 01:30:34,195
听众：你能再解释一下为什么不回到 0 吗？

1984
01:30:34,195 --> 01:30:35,570
大卫-J-马兰：对不起，再说一遍？

1985
01:30:35,570 --> 01:30:37,400
听众：你能再解释一下为什么不重置为 0 吗？

1986
01:30:37,400 --> 01:30:38,275
是的。

1987
01:30:38,275 --> 01:30:40,400
我能再解释一下为什么不重置为 0 吗？

1988
01:30:40,400 --> 01:30:41,690
老实说，只是因为

1989
01:30:41,690 --> 01:30:43,490
这就是他们选择的语法。

1990
01:30:43,490 --> 01:30:45,620
第一个分号前的第一部分

1991
01:30:45,620 --> 01:30:47,660
只执行一次，只是因为

1992
01:30:47,660 --> 01:30:48,740
设计就是这样。

1993
01:30:48,740 --> 01:30:51,660
其他一切都循环往复。

1994
01:30:51,660 --> 01:30:54,277
这只是使用

1995
01:30:54,277 --> 01:30:55,610
代码行数稍多一些。

1996
01:30:55,610 --> 01:30:57,818
使用 while 循环只需六行代码。

1997
01:30:57,818 --> 01:30:59,387
从逻辑上讲，这是一码事。

1998
01:30:59,387 --> 01:31:01,220
程序员，一旦他们变得更加得心应手、

1999
01:31:01,220 --> 01:31:04,053
我更喜欢这样，因为它表达了你的所有相同想法

2000
01:31:04,053 --> 01:31:05,240
更简洁明了。

2001
01:31:05,240 --> 01:31:06,380
仅此而已。

2002
01:31:06,380 --> 01:31:06,890
是吗？

2003
01:31:06,890 --> 01:31:07,620
听众：这就是我的问题。

2004
01:31:07,620 --> 01:31:08,412
大卫-J-马兰：好的。

2005
01:31:08,412 --> 01:31:11,210
所以，让我们把这一点应用到我的喵星人例子中吧。

2006
01:31:11,210 --> 01:31:12,590
让我回到代码这里。

2007
01:31:12,590 --> 01:31:14,898
请注意，如果我突出显示所有这些句子、

2008
01:31:14,898 --> 01:31:16,190
我想我们可以把它做得更严密一些。

2009
01:31:16,190 --> 01:31:21,350
让我把这些都去掉，改成 for int i equals 0。

2010
01:31:21,350 --> 01:31:22,790
我说的是平等。

2011
01:31:22,790 --> 01:31:24,260
大多数程序员都会说 "得到"。

2012
01:31:24,260 --> 01:31:28,130
因此，int i gets 0 意味着赋值--单词 get。

2013
01:31:28,130 --> 01:31:32,360
现在我要做的是 i 小于 3 i++。

2014
01:31:32,360 --> 01:31:37,670
现在，我要在这里输入 printf quote/unquote meow backslash n。

2015
01:31:37,670 --> 01:31:39,450
因此，确实有点紧张。

2016
01:31:39,450 --> 01:31:41,408
我是说，有两行只是大括号。

2017
01:31:41,408 --> 01:31:43,580
现在真正有价值的代码只有两行。

2018
01:31:43,580 --> 01:31:47,460
让我继续做喵，./喵。

2019
01:31:47,460 --> 01:31:51,680
同样，我们又恢复了业务，其中三台只进行印刷。

2020
01:31:51,680 --> 01:31:54,050
好了，我们还应该探索最后一个结构

2021
01:31:54,050 --> 01:31:56,330
只是因为它有时很有用。

2022
01:31:56,330 --> 01:31:58,010
这是一个永远的街区。

2023
01:31:58,010 --> 01:32:00,170
这在 Scratch 中会有点奇怪

2024
01:32:00,170 --> 01:32:02,750
喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵喵

2025
01:32:02,750 --> 01:32:06,290
但是，Scratch 中确实有一个永久块，即执行以下操作、

2026
01:32:06,290 --> 01:32:07,490
永远

2027
01:32:07,490 --> 01:32:10,485
我想，我上周口头提出了至少一个例子

2028
01:32:10,485 --> 01:32:11,360
这在哪里有用？

2029
01:32:11,360 --> 01:32:13,040
一直喵喵叫，有点烦人。

2030
01:32:13,040 --> 01:32:14,990
但你能想到在哪些常见情况下

2031
01:32:14,990 --> 01:32:19,100
您是否想编写代码或使用永远循环的程序？

2032
01:32:19,100 --> 01:32:19,657
是吗？

2033
01:32:19,657 --> 01:32:21,740
观众：在整场比赛中播放音乐。

2034
01:32:21,740 --> 01:32:22,970
是的，玩音乐。

2035
01:32:22,970 --> 01:32:25,370
就像 Spotify 播放列表一样，只是不断重复

2036
01:32:25,370 --> 01:32:26,495
将是某种循环。

2037
01:32:26,495 --> 01:32:28,310
观众：检查碰撞

2038
01:32:28,310 --> 01:32:29,840
DAVID J. MALAN：在 Scratch 中检查碰撞、

2039
01:32:29,840 --> 01:32:32,548
以便查看是否有东西从墙上或其他精灵上弹起。

2040
01:32:32,548 --> 01:32:33,590
是吗？

2041
01:32:33,590 --> 01:32:36,512
观众：Oh, checking for input.

2042
01:32:36,512 --> 01:32:37,970
检查输入。

2043
01:32:37,970 --> 01:32:40,900
所以是的，get_string 本质上就是永远在那里等待

2044
01:32:40,900 --> 01:32:43,300
让我输入一些内容，直到我输入为止。

2045
01:32:43,300 --> 01:32:44,470
看看时间看看时间

2046
01:32:44,470 --> 01:32:45,760
DAVID J. MALAN：查看时间，实际上是

2047
01:32:45,760 --> 01:32:47,860
维持人类的时间，就像挂钟一样。

2048
01:32:47,860 --> 01:32:48,550
在你后面？

2049
01:32:48,550 --> 01:32:49,420
是一样的吗？

2050
01:32:49,420 --> 01:32:50,590
听众：我想说的是检查时间。

2051
01:32:50,590 --> 01:32:52,173
大卫-J-马兰：好的，看看时间。

2052
01:32:52,173 --> 01:32:52,900
还有一个？

2053
01:32:52,900 --> 01:32:53,995
还能检测按键。

2054
01:32:53,995 --> 01:32:56,620
就像在 Scratch 中一样，只是在等待某种事件的发生、

2055
01:32:56,620 --> 01:32:58,182
就像在手机或浏览器上一样。

2056
01:32:58,182 --> 01:32:59,890
因此，有很多例子表明，你

2057
01:32:59,890 --> 01:33:01,510
可能要做的事情永远 -

2058
01:33:01,510 --> 01:33:04,520
这样你就能看到相应的 C 语言构件了。

2059
01:33:04,520 --> 01:33:08,290
这有点奇怪，但这可能是最经典的方法

2060
01:33:08,290 --> 01:33:11,783
如果你想永远打印喵喵的声音

2061
01:33:11,783 --> 01:33:14,950
这将有点疯狂，因为它真的会打印并接管

2062
01:33:14,950 --> 01:33:16,990
您的电脑将永远打印

2063
01:33:16,990 --> 01:33:18,850
你一般会这样做。

2064
01:33:18,850 --> 01:33:19,490
为什么？

2065
01:33:19,490 --> 01:33:22,810
那么，while 循环希望在括号中加入一个布尔表达式、

2066
01:33:22,810 --> 01:33:26,020
而布尔表达式同样是一个 "是/否"、"真/假 "的问题。

2067
01:33:26,020 --> 01:33:29,620
但如果你希望这个问题的答案永远是 "是

2068
01:33:29,620 --> 01:33:33,490
或者说，总是如此，在 C 语言和许多语言中都是如此

2069
01:33:33,490 --> 01:33:35,950
就会说真实，因为真实

2070
01:33:35,950 --> 01:33:38,800
T-R-U-E--永远不会神奇地变成假的。

2071
01:33:38,800 --> 01:33:41,570
我的意思是，它只是编程语言中的一个特殊词汇。

2072
01:33:41,570 --> 01:33:45,680
因此，说 "同时真实"，只是意味着永远做以下事情。

2073
01:33:45,680 --> 01:33:48,580
真假之前的另一个常见范式

2074
01:33:48,580 --> 01:33:52,300
如果这样做变得司空见惯 --

2075
01:33:52,300 --> 01:33:54,220
在 1.

2076
01:33:54,220 --> 01:33:57,820
你可能会在网上的例子和文本中看到类似的内容、

2077
01:33:57,820 --> 01:33:59,770
而 1 其实是一回事。

2078
01:33:59,770 --> 01:34:04,840
计算机通常会将任何 0 值解释为假值。

2079
01:34:04,840 --> 01:34:09,310
任何 1 或其他非零值

2080
01:34:09,310 --> 01:34:11,210
通常被解释为真。

2081
01:34:11,210 --> 01:34:15,400
因此，这也会产生同样的效果，即说 while true 或 while 1。

2082
01:34:15,400 --> 01:34:18,700
一般说来，虽然现在的情况可能更清楚一些。

2083
01:34:18,700 --> 01:34:20,650
现在，永远喵喵叫可不是什么好事。

2084
01:34:20,650 --> 01:34:23,770
但假设我这样做是有意还是无意呢？

2085
01:34:23,770 --> 01:34:24,950
好吧，让我们试试这个。

2086
01:34:24,950 --> 01:34:26,570
在这里，我将进入我的代码。

2087
01:34:26,570 --> 01:34:30,550
我打算去掉 for 循环，将 while 循环改为：

2088
01:34:30,550 --> 01:34:32,180
确实如此。

2089
01:34:32,180 --> 01:34:36,100
在这种情况下，好吧，我们保留它 - 让我们做到这一点。

2090
01:34:36,100 --> 01:34:38,230
让喵喵进来

2091
01:34:38,230 --> 01:34:41,840
你会看到这个，使用了未声明的标识符 true。

2092
01:34:41,840 --> 01:34:46,360
这其实是在暗示我提到的旧方法是 0 和 1。

2093
01:34:46,360 --> 01:34:48,220
如今，你可以说 "真"，也可以说 "假"。

2094
01:34:48,220 --> 01:34:53,560
但是，"真 "和 "假 "本身就是必须包含的特殊词语。

2095
01:34:53,560 --> 01:34:56,740
事实证明，如果要使用类似这样的特殊布尔值、

2096
01:34:56,740 --> 01:35:00,850
还有一个我们没见过的头文件叫 stdbool，它的本质是

2097
01:35:00,850 --> 01:35:03,640
创建 true 和 false 作为关键字。

2098
01:35:03,640 --> 01:35:06,550
另外，CS50 也包含相同的文件。

2099
01:35:06,550 --> 01:35:08,980
因此，在 CS50 中更常见的情况是这样的。

2100
01:35:08,980 --> 01:35:13,360
现在，如果我清空终端窗口，运行 make meow，然后运行 ./meow 并点击

2101
01:35:13,360 --> 01:35:18,970
进入，好了，不幸的是，这不是最好的事情做无限时

2102
01:35:18,970 --> 01:35:21,350
你在云中使用浏览器。

2103
01:35:21,350 --> 01:35:24,970
这确实是一个浏览器，只是在这里全屏显示。

2104
01:35:24,970 --> 01:35:29,462
这意味着我通过互联网向我的电脑发送了数百万只喵星人。

2105
01:35:29,462 --> 01:35:32,170
所以，这种情况总会发生在你身上，但可能不会发生在喵喵身上。

2106
01:35:32,170 --> 01:35:34,150
但你将失去对终端窗口的控制。

2107
01:35:34,150 --> 01:35:34,420
为什么？

2108
01:35:34,420 --> 01:35:35,170
因为你搞砸了。

2109
01:35:35,170 --> 01:35:36,250
这就是一个无限循环。

2110
01:35:36,250 --> 01:35:37,090
你不是故意的

2111
01:35:37,090 --> 01:35:37,690
或许你是这样想的。

2112
01:35:37,690 --> 01:35:39,232
你很想知道会发生什么。

2113
01:35:39,232 --> 01:35:41,590
你是做什么的？

2114
01:35:41,590 --> 01:35:43,930
喵喵声什么时候停止？

2115
01:35:43,930 --> 01:35:45,910
我们有什么办法？

2116
01:35:45,910 --> 01:35:48,550
那么，Control-C 将是你的朋友。

2117
01:35:48,550 --> 01:35:51,070
有时，在云环境中，你必须多次点击。

2118
01:35:51,070 --> 01:35:55,540
但用于取消的 Control-C 会中断正在运行的程序。

2119
01:35:55,540 --> 01:35:58,660
我保证，几乎所有人都会在某个时刻

2120
01:35:58,660 --> 01:36:02,560
不小心引入了一个无限循环，因为你的计算稍有偏差。

2121
01:36:02,560 --> 01:36:05,680
如有疑问，请单击终端窗口，然后点击 Control-C--

2122
01:36:05,680 --> 01:36:07,060
有时是多次

2123
01:36:07,060 --> 01:36:09,545
这样，无论那里发生了什么，都会被取消。

2124
01:36:09,545 --> 01:36:11,170
在这种情况下，我可能是故意的。

2125
01:36:11,170 --> 01:36:14,330
但事实上，有时并不是有意为之。

2126
01:36:14,330 --> 01:36:18,010
好吧，我们一直认为图形用户界面是理所当然的。

2127
01:36:18,010 --> 01:36:22,557
界面有一段时间了，事实上，我输入的命令

2128
01:36:22,557 --> 01:36:23,890
的按钮。

2129
01:36:23,890 --> 01:36:25,848
让我来给大家介绍一下

2130
01:36:25,848 --> 01:36:29,290
我们一直在引擎盖下面使用的是什么？

2131
01:36:29,290 --> 01:36:31,630
即一个名为 Linux 的操作系统。

2132
01:36:31,630 --> 01:36:34,270
当然，我一直在口头上暗指 Mac 和 PC

2133
01:36:34,270 --> 01:36:37,690
因为几乎所有人的台式机都在运行 macOS 或 Windows 系统

2134
01:36:37,690 --> 01:36:38,680
或笔记本电脑。

2135
01:36:38,680 --> 01:36:40,930
但还有很多其他操作系统、

2136
01:36:40,930 --> 01:36:43,330
其中最流行的一种叫做 Linux。

2137
01:36:43,330 --> 01:36:47,680
如今，Linux 在服务器上的使用非常普遍--公司

2138
01:36:47,680 --> 01:36:51,610
托管电子邮件的公司、托管网站或应用程序的公司等。

2139
01:36:51,610 --> 01:36:53,980
某些计算机科学家或计算机科学专业学生

2140
01:36:53,980 --> 01:36:56,950
他们经常喜欢吹嘘自己运行的是 Linux 系统，因为那是个东西。

2141
01:36:56,950 --> 01:37:01,030
但它实际上只是 macOS 或 Windows 的替代品

2142
01:37:01,030 --> 01:37:04,150
如果你需要，它可以为你提供图形用户界面、

2143
01:37:04,150 --> 01:37:07,480
但也特别是命令行环境。

2144
01:37:07,480 --> 01:37:12,040
现在，有趣的事实来了--Windows 和 macOS 确实有终端窗口或同等功能

2145
01:37:12,040 --> 01:37:12,550
其中。

2146
01:37:12,550 --> 01:37:16,150
最终，你可能会在自己的 Mac 或 PC 上使用它来解决某些问题。

2147
01:37:16,150 --> 01:37:19,690
但是，Linux 和其他操作系统一样，都是真正以".....、

2148
01:37:19,690 --> 01:37:23,530
它的命令行环境，同样，我在前面已经把它与图形用户界面

2149
01:37:23,530 --> 01:37:26,500
作为命令行界面或 CLI。

2150
01:37:26,500 --> 01:37:29,450
这其实指的是终端窗口。

2151
01:37:29,450 --> 01:37:33,790
因此，如果我回到 VS 代码，让我先关闭我的标签页

2152
01:37:33,790 --> 01:37:36,160
并将注意力完全集中在终端窗口上、

2153
01:37:36,160 --> 01:37:39,640
这个终端窗口其实就是你的命令行界面

2154
01:37:39,640 --> 01:37:42,390
到您自己的云服务器上。

2155
01:37:42,390 --> 01:37:44,140
这里的术语是你们每个人都将拥有

2156
01:37:44,140 --> 01:37:47,530
你在云中拥有自己的容器，就像你自己的电脑一样

2157
01:37:47,530 --> 01:37:51,430
使用自己的用户名和密码在互联网上运行

2158
01:37:51,430 --> 01:37:54,530
如果你愿意，还可以访问你自己的硬盘驱动器、

2159
01:37:54,530 --> 01:37:57,430
你自己的主文件夹，里面有你在课堂上的所有文件。

2160
01:37:57,430 --> 01:38:01,390
除非您启用了实时共享，否则只有您自己才能访问。

2161
01:38:01,390 --> 01:38:03,880
因此，当你在这里输入命令时，它看起来就像

2162
01:38:03,880 --> 01:38:06,400
当然，就像你在自己的 Mac 或 PC 上打字一样。

2163
01:38:06,400 --> 01:38:09,070
但它们实际上是通过浏览器发送的

2164
01:38:09,070 --> 01:38:13,570
在云端的某个服务器上，由你来控制，真的、

2165
01:38:13,570 --> 01:38:15,830
你自己的账户。

2166
01:38:15,830 --> 01:38:19,390
原来还有其他值得了解的命令。

2167
01:38:19,390 --> 01:38:21,292
今天我们就给大家介绍其中的几种。

2168
01:38:21,292 --> 01:38:23,500
在接下来的几周里，你们是否有机会

2169
01:38:23,500 --> 01:38:24,710
也可以和其他人一起玩。

2170
01:38:24,710 --> 01:38:26,260
但这些都是一些基础知识。

2171
01:38:26,260 --> 01:38:29,782
它们都非常简洁明了，因为事实上，对于你要做的事情

2172
01:38:29,782 --> 01:38:31,990
在命令行键入时，人类一般不会

2173
01:38:31,990 --> 01:38:33,640
想输入长命令。

2174
01:38:33,640 --> 01:38:35,890
因此，这里很多都是缩写。

2175
01:38:35,890 --> 01:38:38,590
现在，我先从最常见的问题说起

2176
01:38:38,590 --> 01:38:44,480
是 ls，一个小写的 l 和一个小写的 s，简洁地表示 list。

2177
01:38:44,480 --> 01:38:47,380
所以，如果我现在进入我的终端窗口，直到现在、

2178
01:38:47,380 --> 01:38:51,370
我只输入了代码，这是 VS 代码用于创建和打开文件的功能、

2179
01:38:51,370 --> 01:38:56,110
和 make 会触发我的代码编译，如果我现在输入 ls 呢？

2180
01:38:56,110 --> 01:39:00,070
这将列出我当前文件夹中的所有文件--

2181
01:39:00,070 --> 01:39:02,000
如果你愿意的话，可以把我的硬盘放在云端。

2182
01:39:02,000 --> 01:39:05,780
所以，如果我按下回车键，你会看到一大堆结果。

2183
01:39:05,780 --> 01:39:07,240
现在，它们也有了颜色编码。

2184
01:39:07,240 --> 01:39:09,910
这里的白色是以 .c 结尾的。

2185
01:39:09,910 --> 01:39:11,980
这些是我编写的源代码文件

2186
01:39:11,980 --> 01:39:15,790
在今天的课堂上，我们学习了 agree.c、compare.c、hello.c 和 meow.c。

2187
01:39:15,790 --> 01:39:19,270
你也许能猜到，这里的绿色，只是按照惯例

2188
01:39:19,270 --> 01:39:24,382
末尾有星号表示其特殊代表什么？

2189
01:39:24,382 --> 01:39:25,340
其他四人之一。

2190
01:39:25,340 --> 01:39:26,315
是吗？

2191
01:39:26,315 --> 01:39:27,800
机器码？机器码？

2192
01:39:27,800 --> 01:39:29,520
是的，机器代码。

2193
01:39:29,520 --> 01:39:33,710
因此，这些就是我的实际程序，它们的名称完全相同，只是去掉了 .c

2194
01:39:33,710 --> 01:39:34,340
延长。

2195
01:39:34,340 --> 01:39:36,830
星号表示它们是可执行的。

2196
01:39:36,830 --> 01:39:39,582
在 macOS 或 Windows 世界中，您需要双击。

2197
01:39:39,582 --> 01:39:41,540
但在命令行环境下、

2198
01:39:41,540 --> 01:39:46,280
这意味着您可以使用 ./ 和不带星号的名称来执行或运行

2199
01:39:46,280 --> 01:39:47,400
其中的代码。

2200
01:39:47,400 --> 01:39:51,560
因此，如果我打开文件资源管理器，在电脑上点击 Command-B

2201
01:39:51,560 --> 01:39:54,990
这里只是一个快捷键--你会看到完全一样的东西。

2202
01:39:54,990 --> 01:39:59,210
因此，ls 是列出账户文件的命令行界面。

2203
01:39:59,210 --> 01:40:03,060
但在这里，因为我使用的是 VS Code 或类似程序、

2204
01:40:03,060 --> 01:40:06,213
我还获得了图形用户界面。

2205
01:40:06,213 --> 01:40:07,880
所以，这只是两个不同的地方。

2206
01:40:07,880 --> 01:40:09,680
您可以使用任何您觉得合适的方式。

2207
01:40:09,680 --> 01:40:12,260
但随着时间的推移，你会自然而然地感到更加舒适

2208
01:40:12,260 --> 01:40:14,720
并能单独使用终端窗口。

2209
01:40:14,720 --> 01:40:16,773
那么，这份清单上还有什么呢？

2210
01:40:16,773 --> 01:40:19,190
在休息时间，我至少在你们当中的一个人身上看到了这一点、

2211
01:40:19,190 --> 01:40:23,330
例如，它创建了一个名为 hello 的文件，而不是 hello.c。

2212
01:40:23,330 --> 01:40:27,230
所以你是在不小心的情况下按了回车键。

2213
01:40:27,230 --> 01:40:30,420
然后，你像这样输入所有代码。

2214
01:40:30,420 --> 01:40:32,270
然后在终端窗口中

2215
01:40:32,270 --> 01:40:34,760
你在做什么？

2216
01:40:34,760 --> 01:40:38,960
而现在这样做实际上什么也没做。

2217
01:40:38,960 --> 01:40:40,820
我不能 - 我打 -

2218
01:40:40,820 --> 01:40:42,380
我正在尝试运行命令。

2219
01:40:42,380 --> 01:40:44,690
我的许可被拒绝了，你们中至少有一个人被拒绝了。

2220
01:40:44,690 --> 01:40:45,433
这是为什么呢？

2221
01:40:45,433 --> 01:40:46,850
好吧，让我们快速检查一下。

2222
01:40:46,850 --> 01:40:50,690
如果我执行 ls 命令，我现在看到的是 hello，但 hello 有

2223
01:40:50,690 --> 01:40:53,180
旁边没有星号，这意味着它不可执行。

2224
01:40:53,180 --> 01:40:53,930
这就是我的密码。

2225
01:40:53,930 --> 01:40:54,470
为什么？

2226
01:40:54,470 --> 01:40:57,540
请注意，我的标签顶部确认了，哦，我搞砸了。

2227
01:40:57,540 --> 01:41:00,740
我没有给我的文件取名为 hello.c，但这是必须的。

2228
01:41:00,740 --> 01:41:01,920
那你该怎么办？

2229
01:41:01,920 --> 01:41:05,810
好吧，你可以非常黑客地复制这个，创建一个新文件，然后粘贴进去。

2230
01:41:05,810 --> 01:41:06,770
或者不，不，不。

2231
01:41:06,770 --> 01:41:09,890
我们现在知道如何重命名，因为这是我们的选项之一。

2232
01:41:09,890 --> 01:41:11,100
让我来吧。

2233
01:41:11,100 --> 01:41:17,600
让我用 mv 命令移动、hello、hello.c，然后按回车键。

2234
01:41:17,600 --> 01:41:20,250
你会看到标签页关闭，因为 hello 已不存在。

2235
01:41:20,250 --> 01:41:25,130
但如果我现在键入 ls，你会看到，啊，有 hello.c。

2236
01:41:25,130 --> 01:41:28,910
如果我现在打开那个文件，哇，里面都是我的代码。

2237
01:41:28,910 --> 01:41:31,010
现在，如果我做hello --

2238
01:41:31,010 --> 01:41:37,350
make hello -- 现在我确实得到了一个可执行文件，在这个文件中，世界被还原了。

2239
01:41:37,350 --> 01:41:40,950
因此，mv 不仅是一个重命名命令，而且还可以用来重命名、

2240
01:41:40,950 --> 01:41:43,020
最终也可用于移动文件。

2241
01:41:43,020 --> 01:41:45,230
您还可以创建目录或文件夹。

2242
01:41:45,230 --> 01:41:48,950
例如，如果我再次进入 VS 代码，假设

2243
01:41:48,950 --> 01:41:52,760
我把鼠标悬停在这里，点击的不是加号文件图标，而是加号文件夹、

2244
01:41:52,760 --> 01:41:56,210
例如，我可以创建一个名为 pset1 的文件夹来解决问题

2245
01:41:56,210 --> 01:41:57,620
班级中的第 1 组。

2246
01:41:57,620 --> 01:42:00,290
现在你会发现它是空的，因为我的所有其他文件

2247
01:42:00,290 --> 01:42:02,840
都在我账户的默认文件夹中。

2248
01:42:02,840 --> 01:42:05,460
但我也可以这样进去。

2249
01:42:05,460 --> 01:42:11,060
我可以点击 "文件"，然后创建一个名为 mario.c 的新文件、

2250
01:42:11,060 --> 01:42:13,430
例如，这是第一个问题之一。

2251
01:42:13,430 --> 01:42:18,960
但你现在会发现，mario.c 位于 pset1 文件夹内。

2252
01:42:18,960 --> 01:42:23,300
因此，如果我放大并在终端窗口输入 ls、

2253
01:42:23,300 --> 01:42:26,720
我在任何地方都看不到 mario.c。

2254
01:42:26,720 --> 01:42:28,688
但我确实看到了 pset1 文件夹。

2255
01:42:28,688 --> 01:42:31,730
它是浅蓝色的，后面有一条斜线，你不必输入。

2256
01:42:31,730 --> 01:42:33,300
它只是表示这是一个文件夹。

2257
01:42:33,300 --> 01:42:37,640
现在，我可以在左上方清楚地看到 pwet1 包含 mario.c。

2258
01:42:37,640 --> 01:42:40,610
但如果我想在这里制作马里奥、

2259
01:42:40,610 --> 01:42:42,800
没有以马里奥为目标的规则。

2260
01:42:42,800 --> 01:42:44,510
它似乎并不存在。

2261
01:42:44,510 --> 01:42:46,650
那是因为你进入了错误的目录。

2262
01:42:46,650 --> 01:42:49,010
因此，在命令行界面中，情况就不那么简单了

2263
01:42:49,010 --> 01:42:51,560
就像点击一个文件夹，然后就打开了。

2264
01:42:51,560 --> 01:42:55,250
您必须更改目录或文件夹。

2265
01:42:55,250 --> 01:42:57,660
cd 将是那里的命令。

2266
01:42:57,660 --> 01:43:00,600
因此，如果我想真正进入该目录、

2267
01:43:00,600 --> 01:43:04,070
我可以进行 cd、空格、pset1、回车。

2268
01:43:04,070 --> 01:43:05,960
现在你会看到我的提示变化。

2269
01:43:05,960 --> 01:43:09,200
这只是一个常见的惯例，但并不是唯一的惯例。

2270
01:43:09,200 --> 01:43:12,470
现在我还有一个美元符号，表示我可以在哪里输入命令。

2271
01:43:12,470 --> 01:43:16,520
但在它之前，我会看到一个提示，不断提醒我在哪个文件夹中。

2272
01:43:16,520 --> 01:43:19,550
我们像许多 Linux 用户一样，故意把它放在那里

2273
01:43:19,550 --> 01:43:23,620
因为与 macOS 或 Windows 不同的是，它们只是为了提醒自己所在的位置、

2274
01:43:23,620 --> 01:43:26,120
在那里，有一个漂亮的大窗口告诉你你在哪里、

2275
01:43:26,120 --> 01:43:29,000
在命令行中，需要用文字提醒您。

2276
01:43:29,000 --> 01:43:33,350
但现在如果我输入 ls 并按回车键，会看到什么？

2277
01:43:33,350 --> 01:43:34,340
听众：Mario.c

2278
01:43:34,340 --> 01:43:36,170
是的，Mario.C。

2279
01:43:36,170 --> 01:43:38,460
现在如果我想打开它 --

2280
01:43:38,460 --> 01:43:42,140
如果要实际编译，我可以在该目录下运行 make mario

2281
01:43:42,140 --> 01:43:43,940
一旦我真正输入了所有代码。

2282
01:43:43,940 --> 01:43:46,050
请放心，在成套问题和实验中，我们都能做到这一点、

2283
01:43:46,050 --> 01:43:48,800
我们几乎总是 -- 当然，在课堂的前几周 --

2284
01:43:48,800 --> 01:43:50,810
给你准确的输入命令。

2285
01:43:50,810 --> 01:43:52,880
很可能是因为这对你们中的许多人来说都很陌生、

2286
01:43:52,880 --> 01:43:55,100
你会不小心键入错误的命令。

2287
01:43:55,100 --> 01:43:56,000
没什么大不了的。

2288
01:43:56,000 --> 01:43:58,850
请记住，您有不同的方法来解决这些问题。

2289
01:43:58,850 --> 01:44:00,740
你有图形化的文件资源管理器，它可以

2290
01:44:00,740 --> 01:44:02,198
应该感觉更熟悉一些。

2291
01:44:02,198 --> 01:44:04,940
但随着时间的推移，你会开始了解，而且，说实话、

2292
01:44:04,940 --> 01:44:08,630
可能更喜欢这样的命令--所以 cd 代表更改目录、

2293
01:44:08,630 --> 01:44:14,420
cp 用于复制文件，ls 用于列出文件，mkdir 用于创建目录

2294
01:44:14,420 --> 01:44:17,630
用命令行而不是按钮- 创建新文件夹

2295
01:44:17,630 --> 01:44:21,924
mv 表示移动或重命名，rm 表示--

2296
01:44:21,924 --> 01:44:22,770
听众：删除。

2297
01:44:22,770 --> 01:44:23,728
DAVID J. MALAN: 删除。

2298
01:44:23,728 --> 01:44:24,960
所以一定要小心。

2299
01:44:24,960 --> 01:44:26,520
Rmdir，删除目录。

2300
01:44:26,520 --> 01:44:28,860
还有几十、几百条其他命令。

2301
01:44:28,860 --> 01:44:30,780
您不需要很多，但我们可以从以下几个方面入手

2302
01:44:30,780 --> 01:44:33,310
随着时间的推移，表面的问题会越来越多。

2303
01:44:33,310 --> 01:44:35,280
但归根结底，这个命令行界面

2304
01:44:35,280 --> 01:44:38,630
将是一个更强大的机制，一个更有能力的机制、

2305
01:44:38,630 --> 01:44:40,380
并最终建立一个更有效的机制

2306
01:44:40,380 --> 01:44:43,980
用于编写代码、运行命令、解决问题和分析数据。

2307
01:44:43,980 --> 01:44:46,050
一般来说，即使知道有

2308
01:44:46,050 --> 01:44:49,680
早期会有一些成长的烦恼，因为它是

2309
01:44:49,680 --> 01:44:51,880
可能对你们很多人来说都很陌生。

2310
01:44:51,880 --> 01:44:55,020
因此，我们还有一些问题需要解决、

2311
01:44:55,020 --> 01:44:56,475
但我们答应过今天吃饼干的。

2312
01:44:56,475 --> 01:44:58,350
我们先休息 10 分钟。

2313
01:44:58,350 --> 01:45:00,150
现在，我们在前厅供应饼干。

2314
01:45:00,150 --> 01:45:02,910
我们10分钟后回来

2315
01:45:02,910 --> 01:45:04,740
好了，我们回来了。

2316
01:45:04,740 --> 01:45:08,400
到目前为止，我们所做的每个 C 语言代码示例都是

2317
01:45:08,400 --> 01:45:10,740
旨在展示一个特定主题。

2318
01:45:10,740 --> 01:45:14,190
但我们认为，我们应该尝试退一步，解决一个更普遍的问题

2319
01:45:14,190 --> 01:45:17,880
并让你感觉到什么时候给你一个问题集，或者只是

2320
01:45:17,880 --> 01:45:20,670
编程问题，甚至从哪里开始

2321
01:45:20,670 --> 01:45:23,280
以及在不明显的情况下如何去做

2322
01:45:23,280 --> 01:45:25,260
练习的意义是什么？

2323
01:45:25,260 --> 01:45:27,330
昔日我最喜欢的游戏之一

2324
01:45:27,330 --> 01:45:30,510
就是这个 "超级马里奥兄弟"，它有这么多的

2325
01:45:30,510 --> 01:45:31,500
从那时起，我们就以不同的形式出现。

2326
01:45:31,500 --> 01:45:35,250
但在这款原创的二维侧滚动游戏中、

2327
01:45:35,250 --> 01:45:37,450
有很多这样的艺术品。

2328
01:45:37,450 --> 01:45:40,260
例如，天空中就有四个问号。

2329
01:45:40,260 --> 01:45:44,370
最初，我们会在 C 语言和许多编程语言中发现这一点、

2330
01:45:44,370 --> 01:45:48,030
将注意力集中在黑白字体上更容易、更容易获得

2331
01:45:48,030 --> 01:45:49,920
交互式程序以文本方式运行，而不是

2332
01:45:49,920 --> 01:45:51,900
但更多的是

2333
01:45:51,900 --> 01:45:55,830
在不久的将来，我们就会看到更多的图形声学类型的程序。

2334
01:45:55,830 --> 01:45:58,500
但现在，请允许我提出以下建议

2335
01:45:58,500 --> 01:46:00,720
试着只用 ASCII 艺术来实现 --

2336
01:46:00,720 --> 01:46:03,150
同样，ASCII 也是将数字映射成字母的代码

2337
01:46:03,150 --> 01:46:08,250
至少就英语而言，这些字母的文本版本可以用于提问

2338
01:46:08,250 --> 01:46:09,120
天空中的痕迹。

2339
01:46:09,120 --> 01:46:11,130
因此，让我转到 VS Code。

2340
01:46:11,130 --> 01:46:13,680
我将创建自己版本的 mario.c，它将

2341
01:46:13,680 --> 01:46:16,923
将与问题集 1 中的挑战不同。

2342
01:46:16,923 --> 01:46:18,840
事实上，在问题集 1 中，你将面临的挑战是

2343
01:46:18,840 --> 01:46:22,860
建立一个类似的小东西，尽管有标签

2344
01:46:22,860 --> 01:46:24,810
而不是图形。

2345
01:46:24,810 --> 01:46:28,120
在 mario.c 中，我想先解决这个简单的问题。

2346
01:46:28,120 --> 01:46:29,710
因此，这一切都涉及输出。

2347
01:46:29,710 --> 01:46:33,090
因此，我将包含 stdio.h，以便使用 printf。

2348
01:46:33,090 --> 01:46:37,043
我将做我的 int main(void)--更多关于为什么我们要继续这样做的内容将在今后几周内陆续介绍。

2349
01:46:37,043 --> 01:46:39,210
我打算先做一些简单的事情、

2350
01:46:39,210 --> 01:46:42,210
如 1、2、3、4，反斜线 n。

2351
01:46:42,210 --> 01:46:46,530
这是我能实现四个问题的最简单方法

2352
01:46:46,530 --> 01:46:50,410
像这样在天空中留下痕迹，像这样使用纯文本。

2353
01:46:50,410 --> 01:46:54,180
所以，让我继续制作马里奥，./马里奥，然后就可以了。

2354
01:46:54,180 --> 01:46:55,830
我们有这四个问号。

2355
01:46:55,830 --> 01:46:58,830
当然，我们也看到有更好的办法。

2356
01:46:58,830 --> 01:47:03,150
如果你想把它概括为五个问号，那就是六个、

2357
01:47:03,150 --> 01:47:06,450
60 个不同的问号，答案总是循环

2358
01:47:06,450 --> 01:47:08,100
因为我们没有重复。

2359
01:47:08,100 --> 01:47:12,570
所以，也许我应该把这段话改写得更灵活一些，说一些

2360
01:47:12,570 --> 01:47:17,100
像这样，在 i 中得到 0，i 小于 4，i++。

2361
01:47:17,100 --> 01:47:21,900
然后在 for 循环中，我可以只做一个问号、

2362
01:47:21,900 --> 01:47:25,800
但我不认为我刚才的做法是正确的。

2363
01:47:25,800 --> 01:47:29,280
有谁发现了美学上的错误？

2364
01:47:29,280 --> 01:47:34,200
是啊，如果我想打印同样的东西，为什么这样做不对？

2365
01:47:34,200 --> 01:47:34,710
是吗？

2366
01:47:34,710 --> 01:47:38,275
反斜杠 n反斜杠 n，你说要用到[INNAUDIBLE]. .

2367
01:47:38,275 --> 01:47:39,150
是的。

2368
01:47:39,150 --> 01:47:41,800
因此，我认为我不需要在每个问号后面都加上反斜杠 n

2369
01:47:41,800 --> 01:47:44,760
因为目标还是天空中的这一排问号。

2370
01:47:44,760 --> 01:47:50,700
因此，如果我现在重新编译这个程序，编译出 mario、./mario，OK，就差不多了。

2371
01:47:50,700 --> 01:47:54,820
但现在，我又回到了美元符号不在自己一行的情况。

2372
01:47:54,820 --> 01:47:58,265
因此，我想我需要一条新线路，但我不认为我需要它在这里

2373
01:47:58,265 --> 01:47:59,890
因为这不会有好结果。

2374
01:47:59,890 --> 01:48:01,015
我想去哪里？

2375
01:48:01,015 --> 01:48:03,310


2376
01:48:03,310 --> 01:48:03,960
有什么直觉吗？

2377
01:48:03,960 --> 01:48:05,610
是吗？

2378
01:48:05,610 --> 01:48:07,380
是啊，所以在外面循环。

2379
01:48:07,380 --> 01:48:11,640
因此，我可以在第 8 行的下方和第 9 行的上方新建一个。

2380
01:48:11,640 --> 01:48:15,273
现在完全可以像这样打印一行新的内容。

2381
01:48:15,273 --> 01:48:17,190
您不必用它打印任何其他东西。

2382
01:48:17,190 --> 01:48:18,970
它本身就是一个角色。

2383
01:48:18,970 --> 01:48:21,900
让我们最后再做一次马里奥，./马里奥。

2384
01:48:21,900 --> 01:48:24,010
好了，现在我们言归正传。

2385
01:48:24,010 --> 01:48:28,020
那么，如果我们想演绎《马里奥》中的其他场景呢，比如这个场景

2386
01:48:28,020 --> 01:48:31,380
这里有很多垂直障碍物，比如这些砖块？

2387
01:48:31,380 --> 01:48:34,410
如果我现在想打印出一列三个砖块 --

2388
01:48:34,410 --> 01:48:38,160
我会用标签来代替任何图形--好吧、

2389
01:48:38,160 --> 01:48:40,650
我想我们快到了，对吗？

2390
01:48:40,650 --> 01:48:42,240
我想我现在可以

2391
01:48:42,240 --> 01:48:44,080
这几乎可以说是易如反掌。

2392
01:48:44,080 --> 01:48:46,342
我可以回到这里，把问号改掉

2393
01:48:46,342 --> 01:48:49,050
变成更像砖块的东西，比如这个哈希符号。

2394
01:48:49,050 --> 01:48:52,890
我想现在我确实需要新的线条字符，因为当我现在制作

2395
01:48:52,890 --> 01:48:56,368
马里奥，./马里奥，好了，这就是我的四人墙。

2396
01:48:56,368 --> 01:48:56,910
哦，等等。

2397
01:48:56,910 --> 01:48:58,050
我不想要四个。

2398
01:48:58,050 --> 01:49:01,150
我只想在这个场景中保持一致、

2399
01:49:01,150 --> 01:49:02,320
所以我只想要三个。

2400
01:49:02,320 --> 01:49:04,780
因此，我仍然可以在一个地方进行更改。

2401
01:49:04,780 --> 01:49:06,330
而这里，又是这种范式。

2402
01:49:06,330 --> 01:49:08,970
即使您使用的是 4 或 3，如果您获得了

2403
01:49:08,970 --> 01:49:11,670
养成从 0 开始计数的习惯、

2404
01:49:11,670 --> 01:49:15,870
你可以一直数到但不会数完你想要数到的值。

2405
01:49:15,870 --> 01:49:20,055
这就是为什么我用 less than 而不是 less than 或 equal to 的原因。

2406
01:49:20,055 --> 01:49:22,680
因此，这将是常见的范例，尽管你可以把它算作

2407
01:49:22,680 --> 01:49:25,360
就像我们之前看到的那样，有不同的方式。

2408
01:49:25,360 --> 01:49:27,965
但如果事态进一步升级呢？

2409
01:49:27,965 --> 01:49:30,840
当你在地下版的 "超级马里奥兄弟 "中时

2410
01:49:30,840 --> 01:49:32,840
有很多这样的地下障碍物、

2411
01:49:32,840 --> 01:49:35,400
包括像这样的砖块网格。

2412
01:49:35,400 --> 01:49:38,400
让我猜测一下，如果把它切成小块，大概是 3

2413
01:49:38,400 --> 01:49:43,560
由 3 块砖组成的网格，漂亮地交错在一起，只给我们提供了一个

2414
01:49:43,560 --> 01:49:45,400
像这样的大砖块

2415
01:49:45,400 --> 01:49:50,160
因此，如果我想打印出一个 3 乘 3 的网格，现在事情就变得更复杂了。

2416
01:49:50,160 --> 01:49:54,510
有趣的是，到目前为止，我都是横向打印一行

2417
01:49:54,510 --> 01:49:56,580
或垂直一列。

2418
01:49:56,580 --> 01:49:58,380
但我们还没有看到任何代码可以

2419
01:49:58,380 --> 01:50:02,670
我是在打印，还是像游戏中暗示的那样生活在两个不同的维度中。

2420
01:50:02,670 --> 01:50:05,560
但我建议我们可以这样做。

2421
01:50:05,560 --> 01:50:08,640
让我继续说，好吧，假设我想打印一份 3

2422
01:50:08,640 --> 01:50:10,500
由 3 块砖组成的网格。

2423
01:50:10,500 --> 01:50:16,590
其实是我想打印三排砖块。

2424
01:50:16,590 --> 01:50:18,063
一个网格为三行。

2425
01:50:18,063 --> 01:50:19,980
因此，如果我把高层次的想法简化为

2426
01:50:19,980 --> 01:50:22,345
我怎么做？

2427
01:50:22,345 --> 01:50:24,720
好吧，让我先把 printf 去掉。

2428
01:50:24,720 --> 01:50:27,090
我只想说，这个 for 循环、

2429
01:50:27,090 --> 01:50:29,230
尽管它还没有做任何有用的事情、

2430
01:50:29,230 --> 01:50:33,390
设计会做多少次？

2431
01:50:33,390 --> 01:50:34,530
好的，三次

2432
01:50:34,530 --> 01:50:35,850
这个 for 循环就可以运行了。

2433
01:50:35,850 --> 01:50:39,390
只需使用 i 进行计数，它就能做三次。

2434
01:50:39,390 --> 01:50:44,070
好吧，如果我现在要打印出一排三块砖，全部都是

2435
01:50:44,070 --> 01:50:46,710
在同一条线路上，这与

2436
01:50:46,710 --> 01:50:49,170
当我只想打印出

2437
01:50:49,170 --> 01:50:51,090
天空中的四个问号

2438
01:50:51,090 --> 01:50:52,960
因此，我们已经看到了解决方案。

2439
01:50:52,960 --> 01:50:55,450
我敢说，我们可以把其中一个编入另一个。

2440
01:50:55,450 --> 01:50:58,590
因此，如果我想打印出一排砖块、

2441
01:50:58,590 --> 01:51:05,310
我可以这样做：在 i 得到 0 i 小于 3 i++、

2442
01:51:05,310 --> 01:51:08,310
然后进入内循环、

2443
01:51:08,310 --> 01:51:11,700
让我像这样打印出一块砖。

2444
01:51:11,700 --> 01:51:16,862
然后，我不喜欢这样下去，但我想我有两个想法

2445
01:51:16,862 --> 01:51:17,820
我将它们合并在一起。

2446
01:51:17,820 --> 01:51:23,080
但是，第 5 行和第 7 行目前可能存在什么问题呢？

2447
01:51:23,080 --> 01:51:24,700
这里有什么不好？

2448
01:51:24,700 --> 01:51:25,345
是啊，在后面？

2449
01:51:25,345 --> 01:51:27,665
听众：你用的是同一个整数 i。

2450
01:51:27,665 --> 01:51:30,040
戴维-J-马兰：是的，我使用的是同样的整数 i，也就是

2451
01:51:30,040 --> 01:51:32,080
我觉得这会给我带来麻烦。

2452
01:51:32,080 --> 01:51:34,480
如果我要算三件事的话、

2453
01:51:34,480 --> 01:51:38,470
但我劫持了这个变量，并在循环中使用它、

2454
01:51:38,470 --> 01:51:41,560
我觉得我应该避免这种名字的碰撞。

2455
01:51:41,560 --> 01:51:43,930
那么，除了 i 之外，还有什么好的替代品呢？

2456
01:51:43,930 --> 01:51:46,390
那么，程序员，如果以这种方式嵌套循环、

2457
01:51:46,390 --> 01:51:47,980
通常会选 j。

2458
01:51:47,980 --> 01:51:50,975
您当然可以将其改为行和列

2459
01:51:50,975 --> 01:51:52,600
如果您需要更多描述性变量，请使用

2460
01:51:52,600 --> 01:51:54,940
但 i 和 j 是非常典型的。

2461
01:51:54,940 --> 01:51:59,020
所以我要继续这样做，用 j++ 代替 i++。

2462
01:51:59,020 --> 01:52:00,280
让我试着编译一下。

2463
01:52:00,280 --> 01:52:04,330
因此，创建马里奥，回车，./马里奥。

2464
01:52:04,330 --> 01:52:06,560
好吧，这里有几处出错了。

2465
01:52:06,560 --> 01:52:08,480
这不是一个 3 乘 3 的网格。

2466
01:52:08,480 --> 01:52:12,855
但如果算上这些东西，我确实至少印了多少？

2467
01:52:12,855 --> 01:52:14,485
你或许可以从逻辑上猜一猜。

2468
01:52:14,485 --> 01:52:15,110
九

2469
01:52:15,110 --> 01:52:17,110
是的，这里有九个哈希值。

2470
01:52:17,110 --> 01:52:18,940
不幸的是，它们都在同一条线上

2471
01:52:18,940 --> 01:52:21,340
而不是三行。

2472
01:52:21,340 --> 01:52:24,910
那么，从逻辑上讲，我能从哪里解决这个问题呢？

2473
01:52:24,910 --> 01:52:26,535
我一定要把所有砖块都打印出来。

2474
01:52:26,535 --> 01:52:28,077
他们只是层次不对而已。

2475
01:52:28,077 --> 01:52:28,646
是吗？

2476
01:52:28,646 --> 01:52:31,078
听众：如果你在第一个循环处加一条新线、

2477
01:52:31,078 --> 01:52:32,620
则会出现三行不同的行。

2478
01:52:32,620 --> 01:52:33,495
是的。

2479
01:52:33,495 --> 01:52:36,580
因此，在第一个循环（也就是这个内循环）之后换一行、

2480
01:52:36,580 --> 01:52:38,000
嵌套循环。

2481
01:52:38,000 --> 01:52:41,030
所以，让我先在这里打印出一个反斜线 n。

2482
01:52:41,030 --> 01:52:42,073
这是在干什么？

2483
01:52:42,073 --> 01:52:43,990
我认为这样就能解决这个问题，只要

2484
01:52:43,990 --> 01:52:47,270
完成一行后，将光标移到下一行。

2485
01:52:47,270 --> 01:52:50,770
所以，让我继续做马里奥，回车，./马里奥、

2486
01:52:50,770 --> 01:52:52,070
现在我们开始做生意了

2487
01:52:52,070 --> 01:52:54,850
因此，这是同一个图形的一个非常简单的版本、

2488
01:52:54,850 --> 01:52:57,400
但我现在正在利用两种不同的想法 --

2489
01:52:57,400 --> 01:52:59,350
或同一想法两次，而不是现在。

2490
01:52:59,350 --> 01:53:03,970
我使用一个循环来控制光标一行一行地移动。

2491
01:53:03,970 --> 01:53:06,100
但在这个循环中，我从左到右进行操作、

2492
01:53:06,100 --> 01:53:08,290
点、点、点、点、点，并打印出来

2493
01:53:08,290 --> 01:53:10,960
每一块砖都是这样的

2494
01:53:10,960 --> 01:53:13,600
现在，这里还是有点马虎。

2495
01:53:13,600 --> 01:53:16,630
如果我想让它永远是正方形，只是因为这是

2496
01:53:16,630 --> 01:53:20,800
在游戏中是什么样子，嗯，我可以把它改成一个 4×4

2497
01:53:20,800 --> 01:53:24,430
或 5 乘 5 的方格 --

2498
01:53:24,430 --> 01:53:26,420
呜......通过这样做。

2499
01:53:26,420 --> 01:53:30,010
为什么在下列情况下，不断改变数字可能不是最好的设计呢？

2500
01:53:30,010 --> 01:53:33,330
我想改变尺寸？

2501
01:53:33,330 --> 01:53:34,440
哪里会出问题？

2502
01:53:34,440 --> 01:53:35,010
是吗？

2503
01:53:35,010 --> 01:53:38,255
如果是正方形，[听不清]

2504
01:53:38,255 --> 01:53:39,130
是的。

2505
01:53:39,130 --> 01:53:40,630
如果它总是一个正方形，高度

2506
01:53:40,630 --> 01:53:43,060
宽度一样，我这不是自找麻烦吗？

2507
01:53:43,060 --> 01:53:44,110
最终，我还是会搞砸的。

2508
01:53:44,110 --> 01:53:45,680
我打算换一个，但不换另一个。

2509
01:53:45,680 --> 01:53:48,070
那么它就会变成一个长方形，而不是正方形。

2510
01:53:48,070 --> 01:53:50,410
因此，我可能应该用不同的方法来解决这个问题。

2511
01:53:50,410 --> 01:53:51,160
那就让我来吧。

2512
01:53:51,160 --> 01:53:54,700
在我的主要职能中，让我先自我介绍一下

2513
01:53:54,700 --> 01:53:59,980
一个名为 "maybe n "的变量，表示我想要的横向砖块数量

2514
01:53:59,980 --> 01:54:01,000
和垂直方向。

2515
01:54:01,000 --> 01:54:03,550
我将初始化为 3。

2516
01:54:03,550 --> 01:54:06,610
这里不用 3，直接用 n。

2517
01:54:06,610 --> 01:54:09,100
但我会在两个地方都这样做，这样现在，从今以后、

2518
01:54:09,100 --> 01:54:13,000
如果我想更改，将其更改为 4、5 或其他、

2519
01:54:13,000 --> 01:54:13,845
我都做完了。

2520
01:54:13,845 --> 01:54:16,720
设计得更好是因为出错的概率更低。

2521
01:54:16,720 --> 01:54:19,840
但从技术上讲，我还是有可能搞砸的。

2522
01:54:19,840 --> 01:54:24,460
从技术上讲，我可能会不小心写出一行像 n++ 这样的代码、

2523
01:54:24,460 --> 01:54:28,360
或者我可以直接更改该变量的值，即使我并不想这样做

2524
01:54:28,360 --> 01:54:28,985
永远不会改变。

2525
01:54:28,985 --> 01:54:31,693
也许是因为我是个糟糕的程序员，我复制/粘贴错了、

2526
01:54:31,693 --> 01:54:34,240
我的同事不知道 n 代表什么、

2527
01:54:34,240 --> 01:54:38,440
我可以保护自己和代码，避免人为错误

2528
01:54:38,440 --> 01:54:41,020
请转到第 5 行。

2529
01:54:41,020 --> 01:54:44,170
而不是像在 Scratch 中那样，只声明一个简单的变量、

2530
01:54:44,170 --> 01:54:47,360
可以说，我可以进一步加固我的代码、

2531
01:54:47,360 --> 01:54:50,740
使用关键字 const 将其声明为常量。

2532
01:54:50,740 --> 01:54:53,980
现在，这只是 C 语言和其他一些语言的一个特点

2533
01:54:53,980 --> 01:54:57,220
通过积极主动地说

2534
01:54:57,220 --> 01:55:02,320
n 是一个常数，具体来说是数字 5 或以前的数字 3。

2535
01:55:02,320 --> 01:55:05,530
您不能意外地在其他地方编写代码来更改它。

2536
01:55:05,530 --> 01:55:08,420
计算机将抛出错误并捕捉该错误。

2537
01:55:08,420 --> 01:55:12,160
因此，这只是一种防御性更强的编程方式。

2538
01:55:12,160 --> 01:55:13,235
有些语言有这种功能。

2539
01:55:13,235 --> 01:55:14,110
有些语言则没有。

2540
01:55:14,110 --> 01:55:15,970
但总的来说，这是一种很好的做法。

2541
01:55:15,970 --> 01:55:18,790
它使你的代码设计得更好，因为它只是

2542
01:55:18,790 --> 01:55:22,570
不那么容易受到您、同事或其他人错误的影响

2543
01:55:22,570 --> 01:55:23,570
使用代码。

2544
01:55:23,570 --> 01:55:26,420
因此，让我把默认值改回 3。

2545
01:55:26,420 --> 01:55:28,580
但现在我在两个地方都用 n。

2546
01:55:28,580 --> 01:55:33,250
如果我做了马里奥，./马里奥，我们又回到了最初的起点。

2547
01:55:33,250 --> 01:55:35,560
但代码设计得更好一些。

2548
01:55:35,560 --> 01:55:37,330
让我也注意到这一点。

2549
01:55:37,330 --> 01:55:40,720
一直以来，我都在说正确性很重要。

2550
01:55:40,720 --> 01:55:41,740
设计很重要。

2551
01:55:41,740 --> 01:55:43,700
还有一个风格问题。

2552
01:55:43,700 --> 01:55:46,107
我一直在刻意编写漂亮的代码、

2553
01:55:46,107 --> 01:55:48,940
不只是语法高亮，它是自动的。

2554
01:55:48,940 --> 01:55:52,060
但请注意，我把所有内容都很好地缩进了。

2555
01:55:52,060 --> 01:55:55,450
任何时候我都要使用大括号，比如第 4 行和第 14 行、

2556
01:55:55,450 --> 01:55:57,400
所有内容都缩进一级。

2557
01:55:57,400 --> 01:56:01,420
当我在第 7 行和第 13 行增加了大括号时、

2558
01:56:01,420 --> 01:56:04,520
一切都缩进得很好。

2559
01:56:04,520 --> 01:56:09,250
从技术上讲，计算机并不关心这种空白、

2560
01:56:09,250 --> 01:56:10,090
可以这么说

2561
01:56:10,090 --> 01:56:12,280
你真的会把事情搞得一团糟

2562
01:56:12,280 --> 01:56:15,205
这样做是因为你的风格很奇怪

2563
01:56:15,205 --> 01:56:17,080
或者只是因为你有点马虎。

2564
01:56:17,080 --> 01:56:20,170
但实际上，这段代码仍然是正确的。

2565
01:56:20,170 --> 01:56:23,260
如果我重新编译 -- 让我打开终端窗口 --

2566
01:56:23,260 --> 01:56:28,270
制作马里奥，没有错误，./马里奥，运行完全正常。

2567
01:56:28,270 --> 01:56:30,910
但你可以想象，现在这有多烦人

2568
01:56:30,910 --> 01:56:34,693
是阅读，当然是为了 TA，但肯定是为了第二天的你、

2569
01:56:34,693 --> 01:56:36,860
当然，这是为必须阅读您代码的同事准备的。

2570
01:56:36,860 --> 01:56:38,020
这就是坏作风。

2571
01:56:38,020 --> 01:56:42,670
它仍然可以工作，而且设计得很好，因为你正在编写代码

2572
01:56:42,670 --> 01:56:44,230
从防御角度看，你使用的是常数。

2573
01:56:44,230 --> 01:56:46,420
但是，我的天哪，风格太糟糕了。

2574
01:56:46,420 --> 01:56:48,310
现在，你经常会发现有一些工具

2575
01:56:48,310 --> 01:56:50,440
可帮助您格式化代码

2576
01:56:50,440 --> 01:56:53,710
以符合课程或公司风格的方式。

2577
01:56:53,710 --> 01:56:57,220
但这种肌肉记忆也是需要长期培养的。

2578
01:56:57,220 --> 01:57:00,940
在 VS 代码为您输出代码行时，请采纳以下建议

2579
01:57:00,940 --> 01:57:03,565
因为它试图以可读的方式格式化你的代码。

2580
01:57:03,565 --> 01:57:06,940
而且，哦，我的天哪，如果你的代码中真的出现了错误

2581
01:57:06,940 --> 01:57:08,717
甚至没有正确缩进、

2582
01:57:08,717 --> 01:57:11,800
你们人类根本无法理解

2583
01:57:11,800 --> 01:57:13,690
发生了什么，在哪里。

2584
01:57:13,690 --> 01:57:16,060
你只是在给自己找麻烦。

2585
01:57:16,060 --> 01:57:21,190
因此，也要养成这种习惯，彰显良好的风格。

2586
01:57:21,190 --> 01:57:24,880
好吧，我建议我们不要只用 3 乘 3 的网格。

2587
01:57:24,880 --> 01:57:26,840
我们希望它更有活力一些。

2588
01:57:26,840 --> 01:57:32,020
因此，假设我们不再使用常数，而是使用一个名为 n 的整数。

2589
01:57:32,020 --> 01:57:35,230
让我们询问用户网格的大小

2590
01:57:35,230 --> 01:57:38,320
就像我们之前用 get_int 提示他们一样。

2591
01:57:38,320 --> 01:57:40,150
我把它放在这里。

2592
01:57:40,150 --> 01:57:42,880
然后，我就可以更动态地进行操作了、

2593
01:57:42,880 --> 01:57:46,450
运行 make mario 进行编译--哎呀。

2594
01:57:46,450 --> 01:57:49,930
哦，我不小心搞砸了。

2595
01:57:49,930 --> 01:57:53,785
它在暗示我做什么，尽管很隐晦？

2596
01:57:53,785 --> 01:57:56,660
听众：您必须包含 cs50.h。

2597
01:57:56,660 --> 01:57:59,930
戴维-J-马兰：是的，我忘了把 CS50 头文件放在最上面。

2598
01:57:59,930 --> 01:58:03,420
这就是为什么它不知道 get_int 实际上是有效的。

2599
01:58:03,420 --> 01:58:04,880
所以这很容易解决。

2600
01:58:04,880 --> 01:58:07,730
我要在这里加入 cs50.h。

2601
01:58:07,730 --> 01:58:10,790
现在我要清空我的终端，然后重新运行 make mario。

2602
01:58:10,790 --> 01:58:12,800
现在我们好了 - /马里奥。

2603
01:58:12,800 --> 01:58:14,550
现在请注意我的尺寸。

2604
01:58:14,550 --> 01:58:16,490
因此，如果我输入 3，情况就和以前一样了。

2605
01:58:16,490 --> 01:58:20,900
如果我输入 10，它就更大了，但现在都是自动发生的。

2606
01:58:20,900 --> 01:58:23,360
但有些东西我们没有检测到。

2607
01:58:23,360 --> 01:58:25,940
例如，假设我输入 cat。

2608
01:58:25,940 --> 01:58:28,770
正如我之前所说，get_int 函数可以处理这个问题。

2609
01:58:28,770 --> 01:58:30,687
这是使用图书馆的特点之一。

2610
01:58:30,687 --> 01:58:32,570
您不必处理错误的输入。

2611
01:58:32,570 --> 01:58:36,200
但我们只设计了一个名为 get_int 的函数来获取一个整数。

2612
01:58:36,200 --> 01:58:39,050
我们不知道你希望它是正数、负数还是零、

2613
01:58:39,050 --> 01:58:40,680
或它们的某种组合。

2614
01:58:40,680 --> 01:58:43,940
允许用户输入负 1 的做法有点奇怪

2615
01:58:43,940 --> 01:58:48,440
表示网格大小，负 3 表示网格大小。

2616
01:58:48,440 --> 01:58:51,230
事实上，你的代码什么也没做，所以至少不会崩溃。

2617
01:58:51,230 --> 01:58:52,730
但这有点愚蠢，对吗？

2618
01:58:52,730 --> 01:58:54,530
如果用户愿意，最好能强迫他们

2619
01:58:54,530 --> 01:58:57,150
网格，从而得出正值。

2620
01:58:57,150 --> 01:58:58,530
那么，我们怎样才能做到这一点呢？

2621
01:58:58,530 --> 01:59:03,920
好吧，我可以在这里说，如果 n 小于 1 --

2622
01:59:03,920 --> 01:59:08,190
那么，如果是 0 或负值（我不希望出现这种情况），我该怎么办？

2623
01:59:08,190 --> 01:59:12,380
好吧，我可以说，好吧，再次提示用户尺寸。

2624
01:59:12,380 --> 01:59:16,613
现在请注意，我没有再宣布 n，因为它曾经存在过、

2625
01:59:16,613 --> 01:59:18,530
就不必再提及数据类型了。

2626
01:59:18,530 --> 01:59:19,790
我们之前已经说过了。

2627
01:59:19,790 --> 01:59:21,510
但这有点愚蠢。

2628
01:59:21,510 --> 01:59:22,010
为什么？

2629
01:59:22,010 --> 01:59:25,190
因为现在你给了用户第二次机会，好了，现在也许

2630
01:59:25,190 --> 01:59:29,720
好吧，如果这个版本的 n 小于 1，好吧、

2631
01:59:29,720 --> 01:59:33,020
让我们第三次提示用户吧。

2632
01:59:33,020 --> 01:59:35,240
我的意思是，你可以看到这愚蠢的走向。

2633
01:59:35,240 --> 01:59:38,510
继续递归键入不可能是正确的解决方案

2634
01:59:38,510 --> 01:59:39,860
同样的事情一而再、再而三地发生。

2635
01:59:39,860 --> 01:59:40,790
它会在哪里停止？

2636
01:59:40,790 --> 01:59:42,873
你必须给他们有限的机会

2637
01:59:42,873 --> 01:59:44,810
或者把你的代码弄得一团糟。

2638
01:59:44,810 --> 01:59:48,170
那么，什么才是直观上更好的解决方案呢？

2639
01:59:48,170 --> 01:59:49,128
听众：一个 while 循环。

2640
01:59:49,128 --> 01:59:50,920
戴维-J-马兰：是的，所以是某种循环。

2641
01:59:50,920 --> 01:59:52,160
我们已经看到了一个 while 循环。

2642
01:59:52,160 --> 01:59:54,240
我们看到过 for 循环，所以可能是其中之一。

2643
01:59:54,240 --> 01:59:55,290
让我试试这个。

2644
01:59:55,290 --> 01:59:58,760
让我删掉这些乱七八糟的东西，回到第一个问题上来。

2645
01:59:58,760 --> 01:59:59,790
让我来吧

2646
01:59:59,790 --> 02:00:02,780
因此，当 n 小于 1

2647
02:00:02,780 --> 02:00:05,190
因此，虽然这个数字不是我们想要的 --

2648
02:00:05,190 --> 02:00:09,560
让我们在一个循环中再次提示用户尺寸。

2649
02:00:09,560 --> 02:00:15,470
现在，这里的情况也有所改善，因为只有两个信息请求。

2650
02:00:15,470 --> 02:00:19,640
但很明显，除了 int 之外，第 6 行和第 9 行基本相同。

2651
02:00:19,640 --> 02:00:23,120
如果我改变了尺寸，如果我

2652
02:00:23,120 --> 02:00:26,300
如果我修改这里的措辞，就把它改成另一种语言、

2653
02:00:26,300 --> 02:00:27,350
我必须在两个地方进行修改。

2654
02:00:27,350 --> 02:00:27,850
真糟糕

2655
02:00:27,850 --> 02:00:29,330
复制/粘贴，糟糕。

2656
02:00:29,330 --> 02:00:31,040
那么，怎样做会更好呢？

2657
02:00:31,040 --> 02:00:33,890
原来，在 C 语言中还有另一种范例

2658
02:00:33,890 --> 02:00:37,730
你可以用它来解决这个问题，即代码重复的问题。

2659
02:00:37,730 --> 02:00:41,210
如果我只写一次代码就好了。

2660
02:00:41,210 --> 02:00:45,510
我可以使用第三种名为 do while 循环的循环来做到这一点。

2661
02:00:45,510 --> 02:00:48,000
事实证明，在 C 语言中，你可以做到这一点。

2662
02:00:48,000 --> 02:00:50,210
如果您想获取一个变量（如 n）的值、

2663
02:00:50,210 --> 02:00:53,370
首先创建一个没有初始值的变量。

2664
02:00:53,370 --> 02:00:56,870
所以 int n 分号意味着我们不知道它的值是多少，没错。

2665
02:00:56,870 --> 02:00:57,590
不过没关系。

2666
02:00:57,590 --> 02:00:59,840
我们最终会为它增值。

2667
02:00:59,840 --> 02:01:02,870
那我就这么说了，照着字面意思做。

2668
02:01:02,870 --> 02:01:04,460
我要打开我的卷曲牙套。

2669
02:01:04,460 --> 02:01:05,930
我想做什么？

2670
02:01:05,930 --> 02:01:09,920
我想把 get_int 的返回值赋给 n、

2671
02:01:09,920 --> 02:01:11,750
提示用户尺寸。

2672
02:01:11,750 --> 02:01:14,040
那你想什么时候做？

2673
02:01:14,040 --> 02:01:17,900
我想在 n 小于 1 的情况下这样做。

2674
02:01:17,900 --> 02:01:21,410
而这段代码现在可以实现完全相同的目标、

2675
02:01:21,410 --> 02:01:23,570
但绝不重复自己。

2676
02:01:23,570 --> 02:01:24,230
为什么？

2677
02:01:24,230 --> 02:01:29,210
注意这些代码的第 6 行、

2678
02:01:29,210 --> 02:01:31,175
给我一个名为 n 的整型变量。

2679
02:01:31,175 --> 02:01:33,300
它最初没有价值，但没关系。

2680
02:01:33,300 --> 02:01:34,640
你可以做到这一点。

2681
02:01:34,640 --> 02:01:36,380
第 7 行说，请执行以下操作。

2682
02:01:36,380 --> 02:01:39,890
get_int，提示用户字的大小、

2683
02:01:39,890 --> 02:01:41,660
并将该值存储在 n 中。

2684
02:01:41,660 --> 02:01:45,210
但因为 C 代码从上到下、从左到右运行、

2685
02:01:45,210 --> 02:01:49,040
现在，在第 11 行提出这个问题是合理的，好吧，是

2686
02:01:49,040 --> 02:01:53,670
在第 8 行肯定得到的 n 的当前值是否小于 1？

2687
02:01:53,670 --> 02:01:56,420
如果用户不合作，他们就会输入 0 或负 1、

2688
02:01:56,420 --> 02:01:58,400
或者负 3 -- 会发生什么？

2689
02:01:58,400 --> 02:02:02,510
它将回到这里，重复、重复、重复一切

2690
02:02:02,510 --> 02:02:04,530
在 do while 循环中。

2691
02:02:04,530 --> 02:02:06,438
因此，C 语言中的 do while 循环

2692
02:02:06,438 --> 02:02:08,480
这是其他一些语言所不具备的。

2693
02:02:08,480 --> 02:02:10,730
Python 没有 do while 循环。

2694
02:02:10,730 --> 02:02:13,310
这也许是实现这一目标最简洁的方法、

2695
02:02:13,310 --> 02:02:16,790
尽管必须声明变量有点奇怪、

2696
02:02:16,790 --> 02:02:20,570
在上方创建变量，然后在下方查看。

2697
02:02:20,570 --> 02:02:22,980
除此之外，它与 while 循环类似。

2698
02:02:22,980 --> 02:02:26,150
它只是颠倒了你提问的顺序。

2699
02:02:26,150 --> 02:02:28,820
对这一结构有任何疑问？

2700
02:02:28,820 --> 02:02:30,827
一般来说，"边做边学 "在以下情况下非常有用

2701
02:02:30,827 --> 02:02:32,660
您希望从用户那里获得输入，并使

2702
02:02:32,660 --> 02:02:35,640
确保它符合某些要求。

2703
02:02:35,640 --> 02:02:39,530
好了，在刚才的插曲之后，我们有了这个基础。

2704
02:02:39,530 --> 02:02:41,750
如何清理这些代码？

2705
02:02:41,750 --> 02:02:45,230
最后，让我们来看看我们的代码无法做到的事情

2706
02:02:45,230 --> 02:02:47,720
或不能做得很好或很正确。

2707
02:02:47,720 --> 02:02:50,930
让我在马里奥的最终版本中提出这个建议、

2708
02:02:50,930 --> 02:02:53,520
请允许我补充一些所谓的意见。

2709
02:02:53,520 --> 02:02:56,880
原来，在 C 语言代码中，可以定义

2710
02:02:56,880 --> 02:02:59,173
所谓评论，就是自言自语。

2711
02:02:59,173 --> 02:03:00,840
有些人在 Scratch 中发现了这些。

2712
02:03:00,840 --> 02:03:02,590
有一些黄色的小便签，你可以

2713
02:03:02,590 --> 02:03:04,680
用于添加引文或解释。

2714
02:03:04,680 --> 02:03:07,020
在 C 语言中，有几种写注释的方法。

2715
02:03:07,020 --> 02:03:09,960
一般来说，评论是给自己、给 TA 的笔记、

2716
02:03:09,960 --> 02:03:13,860
为您的同事解答您的代码在做什么、为什么或如何做。

2717
02:03:13,860 --> 02:03:15,660
这是一个小小的英文解释性说明

2718
02:03:15,660 --> 02:03:17,860
或其他人类语言。

2719
02:03:17,860 --> 02:03:23,220
因此，举例来说，我在实现过程中可能会这样做

2720
02:03:23,220 --> 02:03:27,870
对于这个版本的马里奥，我可能首先会问自己这样一个问题 --

2721
02:03:27,870 --> 02:03:30,420
我可能会先在新的一行给自己写上这样的备注、

2722
02:03:30,420 --> 02:03:34,350
在第一段代码上方，获取网格大小。

2723
02:03:34,350 --> 02:03:38,100
这只是用任何简练的英语进行的解释性说明

2724
02:03:38,100 --> 02:03:41,820
这通常解释了接下来的六行左右，下一大块

2725
02:03:41,820 --> 02:03:43,560
或代码块。

2726
02:03:43,560 --> 02:03:46,500
如果对每一行都进行注释，就有点过分了。

2727
02:03:46,500 --> 02:03:49,680
在某些情况下，程序员应该知道每行代码的作用。

2728
02:03:49,680 --> 02:03:53,700
不过，能看一眼第 6 行的注释也不错

2729
02:03:53,700 --> 02:03:56,818
以两条斜线开头，它就会变灰

2730
02:03:56,818 --> 02:03:58,110
因为有语法高亮显示。

2731
02:03:58,110 --> 02:03:59,070
这不符合逻辑。

2732
02:03:59,070 --> 02:04:00,440
这只是一个自我提醒。

2733
02:04:00,440 --> 02:04:02,190
它通常会给我一个小抄

2734
02:04:02,190 --> 02:04:05,160
下面的代码行应该做什么和/或为什么。

2735
02:04:05,160 --> 02:04:07,910
下面还有第二个代码块

2736
02:04:07,910 --> 02:04:08,910
好多行啊

2737
02:04:08,910 --> 02:04:14,130
但合在一起，这只是砖块的打印网格。

2738
02:04:14,130 --> 02:04:16,350
因此，我又对自己说

2739
02:04:16,350 --> 02:04:18,540
只是让人更容易理解

2740
02:04:18,540 --> 02:04:20,880
这 20 多行代码通过添加

2741
02:04:20,880 --> 02:04:23,760
一些英文解释。

2742
02:04:23,760 --> 02:04:26,970
但现在我有了这些，岂不是很好

2743
02:04:26,970 --> 02:04:31,140
如果我能把这些功能抽象出来，这

2744
02:04:31,140 --> 02:04:33,600
如何确定网格的大小和打印方式？

2745
02:04:33,600 --> 02:04:37,590
换句话说，假设你不知道从哪里开始解决这个问题。

2746
02:04:37,590 --> 02:04:39,960
而眼下的问题就是如何实施

2747
02:04:39,960 --> 02:04:43,530
打印大小可变的砖块网格的程序

2748
02:04:43,530 --> 02:04:46,440
3，或 4，或 5，或人类输入的任何数字。

2749
02:04:46,440 --> 02:04:48,810
如果你真的不知道从哪里开始、

2750
02:04:48,810 --> 02:04:51,540
评论其实是获得

2751
02:04:51,540 --> 02:04:55,680
开始，因为评论可以近似于我们所说的上周

2752
02:04:55,680 --> 02:04:56,310
伪代码。

2753
02:04:56,310 --> 02:05:00,360
伪代码是简明扼要的英语，它能让你的观点一目了然，就像电话一样

2754
02:05:00,360 --> 02:05:02,080
像上次一样搜索书籍。

2755
02:05:02,080 --> 02:05:04,050
所以，如果你真的不知道从哪里开始、

2756
02:05:04,050 --> 02:05:06,910
你可以这样做

2757
02:05:06,910 --> 02:05:11,730
例如，我可以直接说，第一步是获取网格大小

2758
02:05:11,730 --> 02:05:14,610
第二步是打印网格砖。

2759
02:05:14,610 --> 02:05:16,410
到目前为止，我的计划就进行到这里。

2760
02:05:16,410 --> 02:05:18,690
现在用伪代码实现了这一点。

2761
02:05:18,690 --> 02:05:20,910
我有一些大型的占位符。

2762
02:05:20,910 --> 02:05:22,380
我还有工作要做。

2763
02:05:22,380 --> 02:05:26,050
不过，至少我在评论中有一个高层次的问题解决方案。

2764
02:05:26,050 --> 02:05:28,230
现在我甚至可以走到这一步。

2765
02:05:28,230 --> 02:05:32,010
我可以说，好吧，假设已经有了一个功能

2766
02:05:32,010 --> 02:05:34,650
存在，名为获取大小。

2767
02:05:34,650 --> 02:05:36,220
我可以这样做

2768
02:05:36,220 --> 02:05:38,790
我可以用 int n 等于 get_size。

2769
02:05:38,790 --> 02:05:41,010
现在我只能暂时假设

2770
02:05:41,010 --> 02:05:43,000
的抽象概念。

2771
02:05:43,000 --> 02:05:43,500
没有。

2772
02:05:43,500 --> 02:05:45,420
CS50 库不附带此功能。

2773
02:05:45,420 --> 02:05:47,520
但我可以发明它，我敢打赌。

2774
02:05:47,520 --> 02:05:49,110
我还能怎么做？

2775
02:05:49,110 --> 02:05:51,930
好吧，让我们暂时假设还有

2776
02:05:51,930 --> 02:05:57,060
一个名为 print_grid 的函数，该函数只打印一个大小为 n 的网格。

2777
02:05:57,060 --> 02:05:58,950
因此，这里也是一个抽象概念。

2778
02:05:58,950 --> 02:06:00,330
这些拼图并不存在。

2779
02:06:00,330 --> 02:06:01,800
这些功能尚不存在。

2780
02:06:01,800 --> 02:06:06,240
但在 C 语言中，就像在 Scratch 中一样，我可以创建自己的函数。

2781
02:06:06,240 --> 02:06:07,600
我该怎么做？

2782
02:06:07,600 --> 02:06:09,630
好吧，让我稍后再往下看。

2783
02:06:09,630 --> 02:06:12,810
按照惯例，您一般希望将 main 放在代码的顶部。

2784
02:06:12,810 --> 02:06:13,110
为什么？

2785
02:06:13,110 --> 02:06:15,235
因为它是主要功能，而且它只是

2786
02:06:15,235 --> 02:06:18,090
人眼会去看某个代码文件做了什么。

2787
02:06:18,090 --> 02:06:19,360
让我来吧

2788
02:06:19,360 --> 02:06:23,910
我想自己创建一个名为 get_size 的函数，它的作用是

2789
02:06:23,910 --> 02:06:26,010
就是获取用户想要的尺寸。

2790
02:06:26,010 --> 02:06:28,380
我希望这个函数返回一个整数。

2791
02:06:28,380 --> 02:06:30,420
这样做的语法是这样的，没错、

2792
02:06:30,420 --> 02:06:34,920
类似于变量，即该函数返回的数据类型。

2793
02:06:34,920 --> 02:06:37,450
我不需要这个函数接受任何输入。

2794
02:06:37,450 --> 02:06:40,500
因此，我要使用一个新的关键词，我们实际上一直在使用这个关键词。

2795
02:06:40,500 --> 02:06:42,292
远--下次再谈--刚打了电话

2796
02:06:42,292 --> 02:06:45,810
void 表示 get_size 函数不接受任何输入。

2797
02:06:45,810 --> 02:06:46,950
它确实有输出。

2798
02:06:46,950 --> 02:06:48,138
它会输出一个 int。

2799
02:06:48,138 --> 02:06:50,430
而这只是你写的奇怪顺序。

2800
02:06:50,430 --> 02:06:54,000
您需要写入输出格式、函数名称和输入、

2801
02:06:54,000 --> 02:06:55,920
如果有的话，放在括号内。

2802
02:06:55,920 --> 02:06:57,727
现在我可以实现 get_size。

2803
02:06:57,727 --> 02:06:59,310
但我已经实现了 get_size。

2804
02:06:59,310 --> 02:07:01,140
至少在故事的这个阶段是这样、

2805
02:07:01,140 --> 02:07:03,180
我至少知道该怎么做了。

2806
02:07:03,180 --> 02:07:05,730
经过反复试验，我最终发现

2807
02:07:05,730 --> 02:07:08,040
也许，好吧，如果我声明一个变量

2808
02:07:08,040 --> 02:07:12,270
我的操作如下 n 等于 get_int，提示用户输入大小、

2809
02:07:12,270 --> 02:07:17,910
当 n 小于 1 时，我继续这样做，一旦该代码块

2810
02:07:17,910 --> 02:07:22,830
完成后，这里有一个新的 C 语言关键字，可以返回值 n。

2811
02:07:22,830 --> 02:07:27,330
因此，我一直把某些函数返回的这些值称为返回值。

2812
02:07:27,330 --> 02:07:30,870
在 C 语言中，有一个关键字叫做 return

2813
02:07:30,870 --> 02:07:33,930
的任何函数，都会将

2814
02:07:33,930 --> 02:07:36,970
的功能。

2815
02:07:36,970 --> 02:07:41,220
因此，简而言之，就是现在的第 15 行和第 21 行之间、

2816
02:07:41,220 --> 02:07:45,270
下面是一些与我们之前的解决方案相同的代码，可以获取一个值

2817
02:07:45,270 --> 02:07:47,280
n 是正面的。

2818
02:07:47,280 --> 02:07:48,720
是 1，还是 2，或者更高。

2819
02:07:48,720 --> 02:07:51,180
不是 0，就是不小于 1。

2820
02:07:51,180 --> 02:07:56,360
一旦我们得到了这个值，我们就把它作为返回值交还给它。

2821
02:07:56,360 --> 02:07:58,990
注意我是如何在第 7 行使用这个函数的。

2822
02:07:58,990 --> 02:08:01,630
就像 get_int 和 get_string 一样、

2823
02:08:01,630 --> 02:08:04,650
我在调用函数--在这种情况下，括号里什么都没有。

2824
02:08:04,650 --> 02:08:06,400
但我使用的是赋值运算符

2825
02:08:06,400 --> 02:08:09,970
将其返回值复制到我的变量 n 中。

2826
02:08:09,970 --> 02:08:13,570
因此，现在我有了一个不使用

2827
02:08:13,570 --> 02:08:19,090
存在一个名为 get_size 的函数，无论如何都能得到一个正整数。

2828
02:08:19,090 --> 02:08:21,710
现在是网格问题，我该怎么做呢？

2829
02:08:21,710 --> 02:08:23,860
如何发明一个名为 print_grid 的函数？

2830
02:08:23,860 --> 02:08:27,160
只接受一个参数，即一个数字，并打印出该大小的网格？

2831
02:08:27,160 --> 02:08:29,180
好吧，让我们从这里下去。

2832
02:08:29,180 --> 02:08:32,050
我要写下 print_grid 这个函数的名称。

2833
02:08:32,050 --> 02:08:33,590
该功能只需打印即可。

2834
02:08:33,590 --> 02:08:35,440
正如我们一直说的那样，它有副作用。

2835
02:08:35,440 --> 02:08:38,230
所以我只能说它没有返回值。

2836
02:08:38,230 --> 02:08:39,040
就是无效。

2837
02:08:39,040 --> 02:08:40,820
它本身没有输出。

2838
02:08:40,820 --> 02:08:42,670
这只是美学上的副作用。

2839
02:08:42,670 --> 02:08:44,660
但这确实是一种争论。

2840
02:08:44,660 --> 02:08:47,830
参数就是输入，C 语言的语法是

2841
02:08:47,830 --> 02:08:52,337
就是命名输入的类型和变量的名称。

2842
02:08:52,337 --> 02:08:53,920
我想怎么说都行。

2843
02:08:53,920 --> 02:08:54,940
我称之为尺寸。

2844
02:08:54,940 --> 02:08:56,140
我可以称之为 n。

2845
02:08:56,140 --> 02:08:58,840
在不同的函数中使用同一个变量也是可以的、

2846
02:08:58,840 --> 02:09:01,030
但为了明确起见，我还是称之为 "尺寸"。

2847
02:09:01,030 --> 02:09:03,010
然后在这个函数中，我将

2848
02:09:03,010 --> 02:09:07,210
从内存中复制的代码与之前的相同、

2849
02:09:07,210 --> 02:09:09,250
i 小于尺寸--

2850
02:09:09,250 --> 02:09:18,790
而不是 3-- i++，在此内部，对于 int j 得到 0，j 小于 size j++、

2851
02:09:18,790 --> 02:09:23,500
并在其中用 printf 打印出一个哈希值、

2852
02:09:23,500 --> 02:09:28,660
在循环之后打印出一行新的内容，仅此而已。

2853
02:09:28,660 --> 02:09:30,370
诚然，我做得很快。

2854
02:09:30,370 --> 02:09:32,860
但这和我之前写的代码是一样的。

2855
02:09:32,860 --> 02:09:34,750
但现在，就像我用 Scratch 一样，让

2856
02:09:34,750 --> 02:09:36,910
我只是随意地敲了几下回车键

2857
02:09:36,910 --> 02:09:39,190
将代码移到看不见、摸不着的地方。

2858
02:09:39,190 --> 02:09:40,900
现在我有了抽象概念。

2859
02:09:40,900 --> 02:09:44,350
现在我有了名为 get_size 和 print_grid 的拼图、

2860
02:09:44,350 --> 02:09:48,160
语法需要适应一下，但现在它们就是存在的。

2861
02:09:48,160 --> 02:09:50,590
但我确实需要做一件事。

2862
02:09:50,590 --> 02:09:56,260
因为 C 有点天真，如果我现在尝试制作马里奥并按回车键、

2863
02:09:56,260 --> 02:09:59,500
函数 get_size 的隐式声明无效。

2864
02:09:59,500 --> 02:10:03,460
我们以前也看到过这种情况，当时我还没有加入文件。

2865
02:10:03,460 --> 02:10:06,362
当我没有包含 CS50 库时，get_int 无法工作。

2866
02:10:06,362 --> 02:10:09,070
但这不是问题所在，因为这不是从图书馆借来的。

2867
02:10:09,070 --> 02:10:10,270
这是我刚刚发明的。

2868
02:10:10,270 --> 02:10:12,580
C 从字面上理解你。

2869
02:10:12,580 --> 02:10:15,610
如果您在文件底部定义了这些功能，那么您就可以在文件中使用这些功能、

2870
02:10:15,610 --> 02:10:18,910
它们不存在于第 7 行或第 10 行。

2871
02:10:18,910 --> 02:10:20,690
所以我可以这样做。

2872
02:10:20,690 --> 02:10:23,590
我可以，好吧，好吧，让我来强调一下这一切、

2873
02:10:23,590 --> 02:10:26,342
剪切到我的剪贴板，然后粘贴到这里。

2874
02:10:26,342 --> 02:10:27,550
这样就能解决问题。

2875
02:10:27,550 --> 02:10:30,280
我可以把所有这些功能都移到文件的顶部。

2876
02:10:30,280 --> 02:10:33,380
这很烦人，因为现在 main 位于文件底部。

2877
02:10:33,380 --> 02:10:34,930
找到它需要更长的时间。

2878
02:10:34,930 --> 02:10:36,560
这不是一个干净的解决方案。

2879
02:10:36,560 --> 02:10:39,170
让我把它放回原来的位置。

2880
02:10:39,170 --> 02:10:40,730
让我来吧

2881
02:10:40,730 --> 02:10:44,110
这是 CS50 中唯一的一次，实际上也是 C 语言编程中唯一的一次

2882
02:10:44,110 --> 02:10:46,060
复制/粘贴是合理的。

2883
02:10:46,060 --> 02:10:50,320
如果复制并粘贴每个函数的第一行代码

2884
02:10:50,320 --> 02:10:55,000
然后以分号结束，就可以逗弄编译器了

2885
02:10:55,000 --> 02:10:58,270
在文件顶部给予足够的提示

2886
02:10:58,270 --> 02:11:01,010
好吧，这些功能以后才会存在。

2887
02:11:01,010 --> 02:11:03,190
但这里有一个提示，它们会存在。

2888
02:11:03,190 --> 02:11:07,660
这样才能让编译器相信你。

2889
02:11:07,660 --> 02:11:11,830
因此，这些其他函数仍然可以放在文件的下方，即 main 的下方。

2890
02:11:11,830 --> 02:11:14,440
但现在当我做马里奥

2891
02:11:14,440 --> 02:11:15,190
哦，该死

2892
02:11:15,190 --> 02:11:17,260
哦，我说的是 print 而不是 printf。

2893
02:11:17,260 --> 02:11:20,860
是我的错--printf。

2894
02:11:20,860 --> 02:11:26,665
因此，如果我制作马里奥，./马里奥，现在我可以输入 3、

2895
02:11:26,665 --> 02:11:27,790
我们就能恢复正常工作了。

2896
02:11:27,790 --> 02:11:30,190
现在，这是一种非常严厉的方式，从长远来看

2897
02:11:30,190 --> 02:11:32,800
以获得更复杂的解决方案。

2898
02:11:32,800 --> 02:11:35,240
但从某种意义上说，这种解决方案设计得更好。

2899
02:11:35,240 --> 02:11:35,740
为什么？

2900
02:11:35,740 --> 02:11:38,050
因为现在，尤其是在没有评论的情况下、

2901
02:11:38,050 --> 02:11:40,060
我的意思是，看看我的代码有多短。

2902
02:11:40,060 --> 02:11:42,430
我的主函数只有两行代码。

2903
02:11:42,430 --> 02:11:42,940
为什么？

2904
02:11:42,940 --> 02:11:46,338
好吧，我把多汁的内容归入了自己的函数中。

2905
02:11:46,338 --> 02:11:48,880
现在，尤其是当我与同事或其他人一起工作时、

2906
02:11:48,880 --> 02:11:52,297
你可以想象将大型程序拆分成更小的部分、

2907
02:11:52,297 --> 02:11:54,380
让不同的人执行不同的部分、

2908
02:11:54,380 --> 02:11:58,750
只要你们事先就输入和输出的内容达成一致意见

2909
02:11:58,750 --> 02:12:00,410
实际上是

2910
02:12:00,410 --> 02:12:04,300
好了，现在让我们来看看计算机能做什么，做得好和做得不好。

2911
02:12:04,300 --> 02:12:07,360
在数学上，C 语言确实支持一大堆运算符、

2912
02:12:07,360 --> 02:12:10,610
通过它，我们可以做加法、减法、乘法和除法、

2913
02:12:10,610 --> 02:12:14,025
甚至可以计算一个数除以另一个数的余数。

2914
02:12:14,025 --> 02:12:16,900
事实上，我们何不在一个非常简单的程序中使用它们呢？

2915
02:12:16,900 --> 02:12:19,130
并制作我们自己的计算器？

2916
02:12:19,130 --> 02:12:21,400
所以，让我来看看 VS 代码。

2917
02:12:21,400 --> 02:12:25,030
让我继续创建一个名为 calculator.c 的新文件。

2918
02:12:25,030 --> 02:12:27,550
在这个文件中，让我们先加入

2919
02:12:27,550 --> 02:12:33,670
几个现在已经耳熟能详的头文件--cs50.h 和 stdio.h。

2920
02:12:33,670 --> 02:12:37,540
那我们就用 int main(void) 来声明 main。

2921
02:12:37,540 --> 02:12:40,250
然后，让我们在 main 中做一些相对简单的事情。

2922
02:12:40,250 --> 02:12:42,790
让我们声明一个 int 并将其称为 x，然后设置

2923
02:12:42,790 --> 02:12:45,670
等于 get int 的返回值、

2924
02:12:45,670 --> 02:12:48,040
提示用户输入 x 值。

2925
02:12:48,040 --> 02:12:50,240
让我们再给自己一个变量。

2926
02:12:50,240 --> 02:12:51,490
我们称之为 y。

2927
02:12:51,490 --> 02:12:55,230
将其设置为另一次调用 get_int 的返回值、

2928
02:12:55,230 --> 02:12:57,780
提示用户输入该值 y。

2929
02:12:57,780 --> 02:13:00,360
最后，让我们非常简单地继续前进

2930
02:13:00,360 --> 02:13:05,080
并打印出 x 加 y 的总和，这是一个超级简单的计算器。

2931
02:13:05,080 --> 02:13:08,640
因此，我会使用 printf、quote/unquote、%i 来表示整数、

2932
02:13:08,640 --> 02:13:10,930
反斜杠 n 给我新的一行。

2933
02:13:10,930 --> 02:13:14,640
然后，我要继续做 x 加 y 的操作，打印出总和。

2934
02:13:14,640 --> 02:13:16,710
现在让我进入终端窗口。

2935
02:13:16,710 --> 02:13:20,340
让我做一个计算器，以便编译代码。

2936
02:13:20,340 --> 02:13:22,080
没有错误信息，这很好。

2937
02:13:22,080 --> 02:13:23,880
让我来做 ./calculator.

2938
02:13:23,880 --> 02:13:28,500
我们来做一个类似 2 加 2 的运算，当然应该等于 4。

2939
02:13:28,500 --> 02:13:29,340
确实如此。

2940
02:13:29,340 --> 02:13:33,660
但事实证明，有时还是会有限制的

2941
02:13:33,660 --> 02:13:34,677
我们遇到的问题。

2942
02:13:34,677 --> 02:13:36,510
让我在这里更有雄心壮志一点。

2943
02:13:36,510 --> 02:13:37,890
让我清空终端窗口。

2944
02:13:37,890 --> 02:13:39,990
让我再重新计算一遍。

2945
02:13:39,990 --> 02:13:47,280
这次，让我们输入 20 亿来表示 x，再输入同样的数字表示 y。

2946
02:13:47,280 --> 02:13:49,740
当然，现在的答案是 20 亿加 20 亿

2947
02:13:49,740 --> 02:13:52,560
当然，应该是 40 亿。

2948
02:13:52,560 --> 02:13:53,970
但事实并非如此。

2949
02:13:53,970 --> 02:13:56,790
奇怪的是，我们看到的却是一个负数

2950
02:13:56,790 --> 02:14:00,060
在这里，这表明加运算符在某种程度上并不完全

2951
02:14:00,060 --> 02:14:02,070
我们的工作不如人意。

2952
02:14:02,070 --> 02:14:04,240
为什么会这样呢？

2953
02:14:04,240 --> 02:14:07,770
原来，电脑内部当然是内存，也就是 RAM、

2954
02:14:07,770 --> 02:14:08,850
随机存取存储器

2955
02:14:08,850 --> 02:14:11,160
这取决于电脑的大小和电脑的类型、

2956
02:14:11,160 --> 02:14:13,410
很可能是这样的 --

2957
02:14:13,410 --> 02:14:15,930
一块小电路板，上面有一些黑色的小模块

2958
02:14:15,930 --> 02:14:19,320
实际上包含计算机内存的所有字节。

2959
02:14:19,320 --> 02:14:22,200
不幸的是，你和我的时间有限

2960
02:14:22,200 --> 02:14:25,080
我们电脑中的这种内存，它

2961
02:14:25,080 --> 02:14:27,250
意味着无论我们想数到多高、

2962
02:14:27,250 --> 02:14:29,670
最终会限制我们在多大程度上

2963
02:14:29,670 --> 02:14:32,790
可以计数，因为我们的内存是有限的。

2964
02:14:32,790 --> 02:14:35,800
我们没有无限多的 0 和 1 可以玩。

2965
02:14:35,800 --> 02:14:38,640
我们最终必须真正受到约束。

2966
02:14:38,640 --> 02:14:40,072
这意味着什么？

2967
02:14:40,072 --> 02:14:42,030
原来，计算机通常使用

2968
02:14:42,030 --> 02:14:46,110
用多达 32 位的 0 或 1 来表示事物

2969
02:14:46,110 --> 02:14:48,120
就像整数，或者在 C 语言中，就像 int。

2970
02:14:48,120 --> 02:14:50,010
因此，举例来说，我们能得到的最小数字是

2971
02:14:50,010 --> 02:14:53,830
当然是用 32 个 int 表示，当然是用 32 位表示、

2972
02:14:53,830 --> 02:14:55,020
将为零

2973
02:14:55,020 --> 02:14:56,970
像这样的 32 个零

2974
02:14:56,970 --> 02:14:59,100
我们能代表的最大数字

2975
02:14:59,100 --> 02:15:03,180
就是把所有的 0 改为 1，在本例中就是这样、

2976
02:15:03,180 --> 02:15:07,200
最好能得出一个总数约等于 40 亿的数字。

2977
02:15:07,200 --> 02:15:15,390
如果将所有 32 位都设置为 1，最大值实际上是 4,294,967,295

2978
02:15:15,390 --> 02:15:17,160
然后进行实际计算。

2979
02:15:17,160 --> 02:15:20,520
但问题是，我们人类和计算机

2980
02:15:20,520 --> 02:15:24,730
有时还希望并需要能够表示负数。

2981
02:15:24,730 --> 02:15:28,230
因此，如果您既想表示负数，又想表示正数

2982
02:15:28,230 --> 02:15:30,960
0 时，不能真的从 0 开始计数

2983
02:15:30,960 --> 02:15:33,360
一直到大约 40 亿。

2984
02:15:33,360 --> 02:15:35,280
你必须分担差额，也许

2985
02:15:35,280 --> 02:15:39,390
将其中一半的 0 和 1 分配给两个负数

2986
02:15:39,390 --> 02:15:41,890
而另一半大致为正数。

2987
02:15:41,890 --> 02:15:46,260
因此，实际上，当你使用甚至多达 32 位时、

2988
02:15:46,260 --> 02:15:49,740
大多数计算机能计算的最高值，当然，在这样一个用 C 语言编写的程序中

2989
02:15:49,740 --> 02:15:52,500
使用 int，大约为 20 亿。

2990
02:15:52,500 --> 02:15:57,180
即 2 147 483 647。

2991
02:15:57,180 --> 02:15:59,880
但反过来说，我们现在也可以、

2992
02:15:59,880 --> 02:16:03,420
使用不同的比特模式，将负数表示为低

2993
02:16:03,420 --> 02:16:06,630
为负 20 亿，或多或少。

2994
02:16:06,630 --> 02:16:09,240
当然，这意味着如果我们只是

2995
02:16:09,240 --> 02:16:13,530
位数是有限的，在某些时候只能数到这么多、

2996
02:16:13,530 --> 02:16:16,360
可以说，我们的位子就要用完了。

2997
02:16:16,360 --> 02:16:20,280
换句话说，我们遇到了通常所说的整数溢出

2998
02:16:20,280 --> 02:16:23,080
在这种情况下，您需要使用比现有位更多的位。

2999
02:16:23,080 --> 02:16:26,767
结果，你的可用空间被挤占。

3000
02:16:26,767 --> 02:16:28,600
这实际上意味着什么呢？

3001
02:16:28,600 --> 02:16:30,683
那么，假设你只有三个位、

3002
02:16:30,683 --> 02:16:32,910
但我要灰掉第四点，只是

3003
02:16:32,910 --> 02:16:37,080
以表达我们最终想在哪里多放一点。

3004
02:16:37,080 --> 02:16:40,230
当然，如果是 0，则按照第 0 周的讨论、

3005
02:16:40,230 --> 02:16:45,360
这是 1、2、3、4、5、6、7。

3006
02:16:45,360 --> 02:16:50,100
现在，理想情况下，在二进制中，如果您想在这个值 7 上再加一个、

3007
02:16:50,100 --> 02:16:53,070
从数学上讲，你必须背负 1、

3008
02:16:53,070 --> 02:16:56,250
这样最好能得到 1000。

3009
02:16:56,250 --> 02:17:00,420
但是，如果您没有四比特，而您的计算机又不够先进

3010
02:17:00,420 --> 02:17:03,270
要有三个位，甚至不是 32 位，而是三个位、

3011
02:17:03,270 --> 02:17:07,799
这意味着你实际上代表的不是 1000 人、

3012
02:17:07,799 --> 02:17:10,620
而是 000。

3013
02:17:10,620 --> 02:17:13,770
没有地方存放第四个位子了

3014
02:17:13,770 --> 02:17:17,850
我在这里把它涂成灰色，也就是说，你的整数可能会溢出。

3015
02:17:17,850 --> 02:17:21,540
而当你数到 7 时，下一个数字一旦加上 1

3016
02:17:21,540 --> 02:17:24,299
实际上将是 0，或者更糟，正如我们在这里看到的那样

3017
02:17:24,299 --> 02:17:27,129
在我的代码中，是一个负值。

3018
02:17:27,129 --> 02:17:30,209
那么，我们可以做些什么来消除这种担忧呢？

3019
02:17:30,209 --> 02:17:32,490
C 语言并不只有整数或 ints。

3020
02:17:32,490 --> 02:17:34,559
此外，它还有 "多头"，顾名思义，就是 "多头"、

3021
02:17:34,559 --> 02:17:38,469
只是更长的整数，这意味着它们有更多比特可用。

3022
02:17:38,469 --> 02:17:40,080
让我回到我的代码中。

3023
02:17:40,080 --> 02:17:41,430
我会清除终端窗口。

3024
02:17:41,430 --> 02:17:43,590
让我继续把整数改为

3025
02:17:43,590 --> 02:17:47,010
从字面上看，这里很长，这里很长。

3026
02:17:47,010 --> 02:17:51,600
我必须更改 CS50 库中的功能

3027
02:17:51,600 --> 02:17:53,228
不是 get_int，而是 get_long。

3028
02:17:53,228 --> 02:17:55,770
这的确是我们在图书馆中提供的另一项功能。

3029
02:17:55,770 --> 02:17:57,809
让我把 get_int 也改为 get_long。

3030
02:17:57,809 --> 02:18:01,480
我将保持变量名不变，但还需要做一个改动。

3031
02:18:01,480 --> 02:18:05,190
原来 printf 还支持其他格式代码

3032
02:18:05,190 --> 02:18:09,629
因此，不仅仅是整数的 %i 或字符串的 %s，还包括例如

3033
02:18:09,629 --> 02:18:15,780
%li表示长整数，%f表示浮点数值，并带有

3034
02:18:15,780 --> 02:18:16,379
小数。

3035
02:18:16,379 --> 02:18:20,280
既然如此，我们就把我的 printf 行改为 not %i、

3036
02:18:20,280 --> 02:18:21,690
但 %li.

3037
02:18:21,690 --> 02:18:26,219
现在让我再做一次计算，输入 --

3038
02:18:26,219 --> 02:18:29,160
现在没有明显的错误 -- ./calculator.

3039
02:18:29,160 --> 02:18:31,740
2 加 2 还是等于 4。

3040
02:18:31,740 --> 02:18:36,910
但现在如果我再做一次计算，让我们计算 20 亿次

3041
02:18:36,910 --> 02:18:41,170
以及 y 的 20 亿，以前，我们

3042
02:18:41,170 --> 02:18:44,629
溢出了一个整数的大小，得到了一个奇怪的负数

3043
02:18:44,629 --> 02:18:47,830
因为该模式被误解为负数

3044
02:18:47,830 --> 02:18:48,340
而不是

3045
02:18:48,340 --> 02:18:51,340
但是，一个长文本并没有使用传统的 32 位

3046
02:18:51,340 --> 02:18:55,240
使用 64 位，这意味着我们有足够多的备用位

3047
02:18:55,240 --> 02:18:57,850
加 20 亿的时候。

3048
02:18:57,850 --> 02:19:01,190
而现在，事实上我们得到了 40 亿的正确答案、

3049
02:19:01,190 --> 02:19:04,840
的大小。

3050
02:19:04,840 --> 02:19:07,459
现在，一个长条可以数到很高。

3051
02:19:07,459 --> 02:19:12,340
事实上，它可以数到这么多，9 万亿。

3052
02:19:12,340 --> 02:19:14,889
因此，这将给我们带来更多的机会。

3053
02:19:14,889 --> 02:19:17,837
当然，它最终也是有限的。

3054
02:19:17,837 --> 02:19:20,170
因此，如果您的数字需要比它更大、

3055
02:19:20,170 --> 02:19:22,930
你可能还是有问题。

3056
02:19:22,930 --> 02:19:25,430
现在，我们可能还会遇到另一个问题。

3057
02:19:25,430 --> 02:19:28,660
我们甚至可以从这个简单的计算器中看到这一点。

3058
02:19:28,660 --> 02:19:32,520
计算机也有可能出现所谓的截断现象、

3059
02:19:32,520 --> 02:19:35,770
尤其是在进行涉及浮点数值的数学运算时

3060
02:19:35,770 --> 02:19:40,420
是带小数点的数字--你可能会不小心在不知情的情况下截断了

3061
02:19:40,420 --> 02:19:43,610
值，即小数点后的所有内容都丢失。

3062
02:19:43,610 --> 02:19:45,549
事实上，让我回到《VS 代码》这里。

3063
02:19:45,549 --> 02:19:46,900
我会清除我的终端窗口。

3064
02:19:46,900 --> 02:19:49,630
我们仍然使用多头，但继续使用

3065
02:19:49,630 --> 02:19:52,520
这里用除法代替加法。

3066
02:19:52,520 --> 02:19:55,090
因此，让我把这个加号换成除号运算符。

3067
02:19:55,090 --> 02:19:59,020
让我用 make calculator 重新编译一下代码。

3068
02:19:59,020 --> 02:20:02,620
让我继续运行 ./计算器，让我继续做一些事情

3069
02:20:02,620 --> 02:20:06,370
比如 1 表示 x，3 表示 y。

3070
02:20:06,370 --> 02:20:07,547
我们会看到

3071
02:20:07,547 --> 02:20:08,380
等一下

3072
02:20:08,380 --> 02:20:11,500
我知道，1 除以 3 应该是 1/3。

3073
02:20:11,500 --> 02:20:18,348
但在浮点数值中，应该是 0.33333，也许是

3074
02:20:18,348 --> 02:20:20,140
在小学的时候，我就在上面画了一条小线、

3075
02:20:20,140 --> 02:20:21,890
但实际上，有无数个三。

3076
02:20:21,890 --> 02:20:26,140
然而，我们似乎连小数点后的三位数也失去了一位

3077
02:20:26,140 --> 02:20:30,040
因为答案返回时只有 0。

3078
02:20:30,040 --> 02:20:31,700
为什么会这样呢？

3079
02:20:31,700 --> 02:20:35,740
那么，如果我知道两个整数除以一个整数、

3080
02:20:35,740 --> 02:20:38,920
应该给我一个分数，一个浮点数值

3081
02:20:38,920 --> 02:20:42,640
我不能继续使用整数或偶数、

3082
02:20:42,640 --> 02:20:46,370
在这种情况下，多头不支持小数点。

3083
02:20:46,370 --> 02:20:51,040
因此，让我继续把这里的格式代码从 %li 改为 %f、

3084
02:20:51,040 --> 02:20:55,090
同样，它将表示浮点数值，而不是长

3085
02:20:55,090 --> 02:20:56,560
整数，甚至是一个整数。

3086
02:20:56,560 --> 02:21:03,400
让我再进一步，把第三个变量 z 定义为浮点数

3087
02:21:03,400 --> 02:21:04,100
它本身。

3088
02:21:04,100 --> 02:21:07,300
因此，我会给自己一个变量 z 等于 x 除以 y。

3089
02:21:07,300 --> 02:21:10,720
现在与其打印 x 除以 y，不如直接打印 z。

3090
02:21:10,720 --> 02:21:13,060
所以，我现在是在一个浮点数值的世界里工作

3091
02:21:13,060 --> 02:21:17,230
因为我主动将 long 或 int 分割为

3092
02:21:17,230 --> 02:21:20,260
用另一个这样的值来表示，如果要有一个分数的话、

3093
02:21:20,260 --> 02:21:24,710
需要存储为浮点数值，即带有小数点的数值。

3094
02:21:24,710 --> 02:21:27,730
好吧，让我进入终端窗口，重新运行 make

3095
02:21:27,730 --> 02:21:31,120
的计算器--似乎工作正常-- ./calculator、

3096
02:21:31,120 --> 02:21:34,180
再来一次 1 除以 3。

3097
02:21:34,180 --> 02:21:36,868
而在这里，我们看到的仍然都是零。

3098
02:21:36,868 --> 02:21:39,910
因此，我们至少看到了一个小数点，所以我们取得了一些进展 谢谢

3099
02:21:39,910 --> 02:21:41,350
到 %f 和 float。

3100
02:21:41,350 --> 02:21:46,570
但我们似乎已经截断了 1 除以 3 的值。

3101
02:21:46,570 --> 02:21:48,520
那么，我们究竟该如何解决这个问题呢？

3102
02:21:48,520 --> 02:21:50,050
那么，如果程序员知道自己

3103
02:21:50,050 --> 02:21:52,467
在一个会给你浮点数的世界里打交道

3104
02:21:52,467 --> 02:21:54,760
值带有小数点，您很可能

3105
02:21:54,760 --> 02:21:57,340
需要使用一种称为

3106
02:21:57,340 --> 02:22:02,050
类型转换--即通过明确的

3107
02:22:02,050 --> 02:22:04,390
告诉编译器您想这样做。

3108
02:22:04,390 --> 02:22:05,480
现在，我该怎么做呢？

3109
02:22:05,480 --> 02:22:07,100
好吧，让我们回到我的代码这里。

3110
02:22:07,100 --> 02:22:11,260
如果从根本上说，问题在于 C 仍然

3111
02:22:11,260 --> 02:22:14,920
将 x 和 y 视为整数--或者严格地说，将 x 和 y 视为整数、

3112
02:22:14,920 --> 02:22:18,310
没有小数点的长数，用一个除以另一个、

3113
02:22:18,310 --> 02:22:22,330
因此，可以说小数点后没有任何数字、

3114
02:22:22,330 --> 02:22:24,830
我为什么不主动这样做？

3115
02:22:24,830 --> 02:22:28,030
让我用一种略有新意的语法，加上括号、

3116
02:22:28,030 --> 02:22:33,910
指定我要主动将 x 从 long 转换为 float。

3117
02:22:33,910 --> 02:22:39,100
让我主动指定要将 y 从 long 转换为 float

3118
02:22:39,100 --> 02:22:39,950
也是如此。

3119
02:22:39,950 --> 02:22:42,910
现在让我继续相信 nz

3120
02:22:42,910 --> 02:22:46,870
应该是 long 除以 long 或 int 除以 int 的结果、

3121
02:22:46,870 --> 02:22:49,330
而是一个浮点的浮点。

3122
02:22:49,330 --> 02:22:52,630
让我清空终端窗口，再次运行 make calculator --

3123
02:22:52,630 --> 02:22:55,300
似乎工作正常-- ./calculator.

3124
02:22:55,300 --> 02:23:00,760
现在是 1 号、3 号，希望现在我们能真正看到

3125
02:23:00,760 --> 02:23:05,380
我的代码输出了 0.333333。

3126
02:23:05,380 --> 02:23:08,380
我想，如果我们继续在小数点后显示更多的数字、

3127
02:23:08,380 --> 02:23:11,710
理论上，我们想看到多少个三分球就能看到多少个三分球。

3128
02:23:11,710 --> 02:23:13,900
但还有一个问题。

3129
02:23:13,900 --> 02:23:16,240
尤其是当我们操作数字时

3130
02:23:16,240 --> 02:23:19,090
在使用有限内存的计算机中以这种方式运行、

3131
02:23:19,090 --> 02:23:22,180
我们可能会遇到的另一个挑战--除了整数

3132
02:23:22,180 --> 02:23:27,100
除了截断之外，溢出也被称为浮点不精确。

3133
02:23:27,100 --> 02:23:31,480
就像我们不能用 int 表示尽可能大的整数一样

3134
02:23:31,480 --> 02:23:34,060
或单独做多，因为会有一个上限、

3135
02:23:34,060 --> 02:23:39,220
同样，我们的数字精确度也会受到限制。

3136
02:23:39,220 --> 02:23:41,560
事实上，让我们回到《VS 代码》这里。

3137
02:23:41,560 --> 02:23:43,430
我将再次清除终端窗口。

3138
02:23:43,430 --> 02:23:46,900
这一次，让我用一些不太可能的语法来说明我

3139
02:23:46,900 --> 02:23:49,970
不想看到小数点后的默认数字、

3140
02:23:49,970 --> 02:23:52,250
%f 自动给出的。

3141
02:23:52,250 --> 02:23:57,520
让我们继续，在小数点后显示 20 个小数点。

3142
02:23:57,520 --> 02:24:00,700
其奇怪的语法是不要 %f、

3143
02:24:00,700 --> 02:24:05,950
但 %.20 表示我希望看到 20 位数字、

3144
02:24:05,950 --> 02:24:08,440
而不是小数点后的默认值。

3145
02:24:08,440 --> 02:24:10,390
让我重新计算一下。

3146
02:24:10,390 --> 02:24:12,550
让我再做一次 ./计算器。

3147
02:24:12,550 --> 02:24:14,890
我们先做 1，再做 3。

3148
02:24:14,890 --> 02:24:17,560
这下更奇怪了，对吧？

3149
02:24:17,560 --> 02:24:20,590
从小学开始，你大概就知道 1 除以 3

3150
02:24:20,590 --> 02:24:21,580
当然是 1/3。

3151
02:24:21,580 --> 02:24:26,890
但这应该是 0.33333，无限多次，或者说，在纸上、

3152
02:24:26,890 --> 02:24:28,180
上面有一条小线。

3153
02:24:28,180 --> 02:24:31,660
但计算机在这里做了一些奇怪的近似计算。

3154
02:24:31,660 --> 02:24:37,480
是一大堆 3，然后是 4326744079590。

3155
02:24:37,480 --> 02:24:39,380
那么，引擎盖下到底发生了什么呢？

3156
02:24:39,380 --> 02:24:42,100
那么，还是浮点不精确的问题。

3157
02:24:42,100 --> 02:24:45,220
如果你只有有限的比特数，反过来、

3158
02:24:45,220 --> 02:24:48,100
由于内存容量有限，计算机实际上只能

3159
02:24:48,100 --> 02:24:52,300
直观上如此精确。

3160
02:24:52,300 --> 02:24:55,000
等同于，计算机决定以某种方式

3161
02:24:55,000 --> 02:24:57,190
来表示浮点数值。

3162
02:24:57,190 --> 02:24:59,470
但问题是，根据小学数学，有

3163
02:24:59,470 --> 02:25:02,800
有无数个数字，也有无数个

3164
02:25:02,800 --> 02:25:06,460
浮点数值，因为如果您

3165
02:25:06,460 --> 02:25:07,040
因为

3166
02:25:07,040 --> 02:25:10,120
因此，计算机在执行这些浮点运算时

3167
02:25:10,120 --> 02:25:14,500
值，本质上是为我们提供最接近的近似值。

3168
02:25:14,500 --> 02:25:17,740
现在，我们该如何改善这种状况呢？

3169
02:25:17,740 --> 02:25:19,180
那么，还有一个选择。

3170
02:25:19,180 --> 02:25:21,115
与其使用浮点运算，我可以使用以下方法

3171
02:25:21,115 --> 02:25:22,990
顾名思义，它被称为 "替身"、

3172
02:25:22,990 --> 02:25:24,760
使用的位数是浮点数的两倍。

3173
02:25:24,760 --> 02:25:27,820
因此，它通常使用 64，而不是 32。

3174
02:25:27,820 --> 02:25:30,570
这就像 long 和 int 的区别一样、

3175
02:25:30,570 --> 02:25:31,570
这给了我们更多的机会。

3176
02:25:31,570 --> 02:25:34,480
但在本例中，这将用于提高精确度。

3177
02:25:34,480 --> 02:25:36,850
让我们继续将 x 改为 double。

3178
02:25:36,850 --> 02:25:38,740
让我们把 y 改为双数。

3179
02:25:38,740 --> 02:25:41,530
现在，让我们继续使用相同的格式代码--

3180
02:25:41,530 --> 02:25:45,220
对于双打来说，%.20f 还是没问题的。

3181
02:25:45,220 --> 02:25:46,990
让我来计算一下。

3182
02:25:46,990 --> 02:25:48,970
让我来做 ./calculator.

3183
02:25:48,970 --> 02:25:51,460
现在让我来做 1 除以 3。

3184
02:25:51,460 --> 02:25:53,770
我们仍然有一些不精确的地方。

3185
02:25:53,770 --> 02:25:56,590
如果我们关注的不仅仅是 20 位数，那就更多了。

3186
02:25:56,590 --> 02:25:59,900
不过，现在小数点后面的三位数更多了。

3187
02:25:59,900 --> 02:26:03,640
因此，它至少越来越精确，但并不完美。

3188
02:26:03,640 --> 02:26:06,520
但至少更加精确。

3189
02:26:06,520 --> 02:26:08,500
因此，这些问题将

3190
02:26:08,500 --> 02:26:10,360
任何时候您都有必要牢记

3191
02:26:10,360 --> 02:26:12,640
至少在数字上、科学上有所作为

3192
02:26:12,640 --> 02:26:14,980
在使用 C 语言时，你会碰到

3193
02:26:14,980 --> 02:26:18,910
这些现实世界中的硬件限制，反过来又限制了语言。

3194
02:26:18,910 --> 02:26:21,952
现在，在本学期的晚些时候，我们将过渡到一种名为 Python 的语言。

3195
02:26:21,952 --> 02:26:24,660
这实际上至少能解决其中一个问题

3196
02:26:24,660 --> 02:26:26,950
为我们自动提供更多的位、

3197
02:26:26,950 --> 02:26:29,470
可以说，我们需要它们，至少对整数而言。

3198
02:26:29,470 --> 02:26:33,140
但即使是浮点数不精确的问题也将继续存在。

3199
02:26:33,140 --> 02:26:35,170
现在，这些问题到底有多现实？

3200
02:26:35,170 --> 02:26:37,780
早在 1999 年，我们就领略到了

3201
02:26:37,780 --> 02:26:40,840
当全世界在这之前的几年里意识到这一点时

3202
02:26:40,840 --> 02:26:45,010
计算机可能不是最好的选择

3203
02:26:45,010 --> 02:26:48,910
只用两位数就能存储齿轮，从而使其中的齿轮和软件更易于使用。

3204
02:26:48,910 --> 02:26:53,440
比如，不用存储 1999 来表示 1999 年、

3205
02:26:53,440 --> 02:26:56,470
由于空间和成本的原因，很多计算机都是如此、

3206
02:26:56,470 --> 02:26:59,200
习惯于偷工减料，只使用

3207
02:26:59,200 --> 02:27:01,400
两位数来记录年份。

3208
02:27:01,400 --> 02:27:06,850
问题在于，如果系统在 1999 年之前没有更新

3209
02:27:06,850 --> 02:27:11,560
支持 2000 年、2001 年等年份，就像以前一样

3210
02:27:11,560 --> 02:27:14,290
整数溢出，有些计算机可能会

3211
02:27:14,290 --> 02:27:16,990
在他们记忆中的年份 "99 "后面加上 1。

3212
02:27:16,990 --> 02:27:19,540
应该是 2000 年，但如果他们只是

3213
02:27:19,540 --> 02:27:22,090
用两位数表示年份，他们

3214
02:27:22,090 --> 02:27:25,330
可能会弄错年份--有些系统很可能就是这样--

3215
02:27:25,330 --> 02:27:28,390
而不是 1900 年，从字面上理解为

3216
02:27:28,390 --> 02:27:30,740
可以说是倒退了一大步。

3217
02:27:30,740 --> 02:27:32,622
现在，你会认为这种问题

3218
02:27:32,622 --> 02:27:34,330
特别是当我们了解到

3219
02:27:34,330 --> 02:27:37,240
更加了解代码和计算的局限性。

3220
02:27:37,240 --> 02:27:40,390
但实际上，我们也会遇到同样的问题

3221
02:27:40,390 --> 02:27:42,160
在短短几年内再次出现。

3222
02:27:42,160 --> 02:27:48,850
2038 年 1 月 19 日，大多数计算机的比特将耗尽

3223
02:27:48,850 --> 02:27:50,800
现在就开始计时。

3224
02:27:50,800 --> 02:27:55,330
原来，多年前，人类决定使用 32 位整数

3225
02:27:55,330 --> 02:27:58,870
来记录时间过去了多少秒。

3226
02:27:58,870 --> 02:28:01,090
他们在过去选择了一个有点随意的日期--

3227
02:28:01,090 --> 02:28:03,350
1970 年 1 月 1 日

3228
02:28:03,350 --> 02:28:06,860
从那时起，他们就开始数秒了。

3229
02:28:06,860 --> 02:28:09,100
因此，如果计算机存储了一定数量的秒、

3230
02:28:09,100 --> 02:28:11,350
告诉计算机还有多少秒钟

3231
02:28:11,350 --> 02:28:14,710
自 1970 年 1 月 1 日这一特定日期以来，已经过去了很长时间。

3232
02:28:14,710 --> 02:28:17,380
遗憾的是，使用 32 位整数时，我们已经

3233
02:28:17,380 --> 02:28:20,480
看到的，你只能数到这么高，在这一点上、

3234
02:28:20,480 --> 02:28:23,470
就会溢出该变量的大小。

3235
02:28:23,470 --> 02:28:27,250
因此，作为人类，作为一个社会，如果我们不提前解决这个问题，就会有潜在的危险、

3236
02:28:27,250 --> 02:28:32,080
作为计算机科学家，2038 年 1 月 19 日、

3237
02:28:32,080 --> 02:28:36,910
该位可能会翻转，从而溢出这些整数的大小、

3238
02:28:36,910 --> 02:28:42,460
通过计算，我们回到了 1901 年 12 月 13 日。

3239
02:28:42,460 --> 02:28:45,970
这就是说，现在有了这些计算能力和代码

3240
02:28:45,970 --> 02:28:48,560
就有责任真正写出正确的代码。

3241
02:28:48,560 --> 02:28:50,560
下周，我们将剥开其中的几层。

3242
02:28:50,560 --> 02:28:54,550
但现在，这是第一周，祝你在第 1 组问题上好运。

3243
02:28:54,550 --> 02:28:57,850
[掌声]

3244
02:28:57,850 --> 02:29:01,500
[音乐响起]

3245
02:29:01,500 --> 02:29:33,000


