0
00:00:00,000 --> 00:00:04,645


1
00:00:04,645 --> 00:00:06,020
大家好。

2
00:00:06,020 --> 00:00:10,610
欢迎来到 CS50 第一周的第一个超级版块。

3
00:00:10,610 --> 00:00:12,005
我叫卡特-曾克

4
00:00:12,005 --> 00:00:13,130
我是这门课程的指导老师。

5
00:00:13,130 --> 00:00:14,990
与我一同前来的还有我们许多出色的工作人员

6
00:00:14,990 --> 00:00:16,698
要站起来打招呼。

7
00:00:16,698 --> 00:00:19,140
[掌声]

8
00:00:19,140 --> 00:00:21,680
是的，为这些人鼓掌。

9
00:00:21,680 --> 00:00:22,430
他们太棒了。

10
00:00:22,430 --> 00:00:25,650
他们将帮助您完成今天的超级部分。

11
00:00:25,650 --> 00:00:27,740
这是我们课程的第一个超级部分。

12
00:00:27,740 --> 00:00:29,990
在正常的一周，你实际上参加自己的部门

13
00:00:29,990 --> 00:00:31,310
由课程的首席教学研究员在线提供。

14
00:00:31,310 --> 00:00:32,509
你在哈佛在线注册了这些。

15
00:00:32,509 --> 00:00:34,290
从下周开始，你们将参加这些活动。

16
00:00:34,290 --> 00:00:35,998
但本周，考虑到日程安排的特殊性，我们

17
00:00:35,998 --> 00:00:38,940
我想，我们会在一起进行一个大的整体讨论。

18
00:00:38,940 --> 00:00:40,710
下面是这些细节。

19
00:00:40,710 --> 00:00:44,040
如有任何问题，请发送电子邮件至 heads@cs50.harvard.edu。

20
00:00:44,040 --> 00:00:46,880
我们今天的所有幻灯片和开场白都在这个网址上

21
00:00:46,880 --> 00:00:51,205
在课程网站的下面，进入超级部分页面。

22
00:00:51,205 --> 00:00:53,330
不过，作为开场白，我想我们应该

23
00:00:53,330 --> 00:00:57,208
请大家互相交流，思考这两个问题。

24
00:00:57,208 --> 00:00:59,750
所以，回想一下讲课内容，想想这第一个问题。

25
00:00:59,750 --> 00:01:02,180
你从讲座中发现了哪些令人兴奋的内容？

26
00:01:02,180 --> 00:01:04,610
你还在困惑什么？

27
00:01:04,610 --> 00:01:06,480
您还有哪些疑问？

28
00:01:06,480 --> 00:01:10,520
所以，找一个人，也许是你不认识的人，谈谈这两件事吧

29
00:01:10,520 --> 00:01:12,020
在这里提问 2 分钟。

30
00:01:12,020 --> 00:01:13,700
第一，你对什么感到兴奋？

31
00:01:13,700 --> 00:01:17,210
二、你还有什么问题？

32
00:01:17,210 --> 00:01:19,910
让我们从这些对话中回过神来。

33
00:01:19,910 --> 00:01:23,100
很高兴你们能在这里进行这样精彩的讨论。

34
00:01:23,100 --> 00:01:25,610
让我们听听几个不同群体的声音

35
00:01:25,610 --> 00:01:29,400
请在这里说明你对这些问题的想法。

36
00:01:29,400 --> 00:01:30,410
谢谢大家。

37
00:01:30,410 --> 00:01:33,455
让我们来看看左侧的部分。

38
00:01:33,455 --> 00:01:35,330
请这边的一个小组告诉我，你们

39
00:01:35,330 --> 00:01:37,997
本周令人兴奋的事情，以及你仍然想知道的一件事

40
00:01:37,997 --> 00:01:39,578
或您有任何疑问？

41
00:01:39,578 --> 00:01:41,120
房间这边有一个小组？

42
00:01:41,120 --> 00:01:46,960


43
00:01:46,960 --> 00:01:49,460
我能把范围缩小到前排的某个人吗？

44
00:01:49,460 --> 00:01:50,670
你对什么感兴趣？

45
00:01:50,670 --> 00:01:52,878
本周您还有哪些问题？

46
00:01:52,878 --> 00:01:59,620


47
00:01:59,620 --> 00:02:01,540
好，说吧

48
00:02:01,540 --> 00:02:06,850
学生：我觉得更多的是 -- 而不是代码，语法本身。

49
00:02:06,850 --> 00:02:10,580
因为这样，你可以很快上手。

50
00:02:10,580 --> 00:02:16,450
我认为最难的可能是如何构建高效的代码。

51
00:02:16,450 --> 00:02:18,988
有时，你必须换一种思维方式。

52
00:02:18,988 --> 00:02:19,780
很好

53
00:02:19,780 --> 00:02:23,550
学生：我想，我们会

54
00:02:23,550 --> 00:02:26,043
真的需要一些时间来适应。

55
00:02:26,043 --> 00:02:27,210
完全正确，是的。

56
00:02:27,210 --> 00:02:29,130
那么问题来了，如何编写高效代码？

57
00:02:29,130 --> 00:02:31,440
今天晚些时候，我们将实际操作课程的实验室、

58
00:02:31,440 --> 00:02:33,440
这道练习题可以帮助你了解我们如何

59
00:02:33,440 --> 00:02:35,130
在这种情况下，编写高效的代码。

60
00:02:35,130 --> 00:02:38,297
你们可以共同完成这道练习题，并相互交流想法

61
00:02:38,297 --> 00:02:39,150
当我们经过时。

62
00:02:39,150 --> 00:02:41,580
让我们再听听这边一个小组的意见、

63
00:02:41,580 --> 00:02:44,160
如果你不介意的话，也许后面第二排会有人。

64
00:02:44,160 --> 00:02:46,650
有一件事你感兴趣，好，说吧。

65
00:02:46,650 --> 00:02:49,830
学生：我对这种东西也很感兴趣、

66
00:02:49,830 --> 00:02:54,030
但也会创造一些东西，只是通过编码来获得最终产品。

67
00:02:54,030 --> 00:02:58,350
现在，我将有机会制作最终产品。

68
00:02:58,350 --> 00:03:00,570
还有人要考虑讲课的事、

69
00:03:00,570 --> 00:03:02,910
我觉得有太多的综合知识需要学习。

70
00:03:02,910 --> 00:03:05,820
这让我有些犹豫。

71
00:03:05,820 --> 00:03:08,750
我甚至不知道外面有什么。

72
00:03:08,750 --> 00:03:13,640
我想有人说过，其实是在迎新会上、

73
00:03:13,640 --> 00:03:15,860
有时像学生会去的东西

74
00:03:15,860 --> 00:03:18,110
因为他们甚至不知道有这样一个项目

75
00:03:18,110 --> 00:03:18,770
已经

76
00:03:18,770 --> 00:03:20,030
是的，没错。

77
00:03:20,030 --> 00:03:22,573
所以，你有这样一个想法，如何把你的这个想法

78
00:03:22,573 --> 00:03:24,740
以及您想要构建并转化为语法的内容、

79
00:03:24,740 --> 00:03:27,380
就像真正通过写作来让电脑做你想让它做的事，对吗？

80
00:03:27,380 --> 00:03:29,100
所以，这些都是好问题。

81
00:03:29,100 --> 00:03:31,740
以下是我们今天要深入探讨的几个问题。

82
00:03:31,740 --> 00:03:33,980
首先，我们为什么要使用 C 语言？

83
00:03:33,980 --> 00:03:37,280
为什么我们要使用这种古老的语言来开始编程？

84
00:03:37,280 --> 00:03:39,802
我们又该如何在这里学习和阅读它的语法呢？

85
00:03:39,802 --> 00:03:43,010
我们如何才能真正学会如何创建和读取这些变量、这些循环

86
00:03:43,010 --> 00:03:44,750
和条件等。

87
00:03:44,750 --> 00:03:48,260
下面我们就来讨论一下这个数据类型的特殊实例

88
00:03:48,260 --> 00:03:53,100
因为 C 语言要求我们说明每块数据的类型。

89
00:03:53,100 --> 00:03:56,150
我们还将讨论编译 C 程序，从源代码中提取程序

90
00:03:56,150 --> 00:03:57,140
到机器码。

91
00:03:57,140 --> 00:03:59,015
最后，在最后，我们将谈谈

92
00:03:59,015 --> 00:04:02,720
我们需要多少年才能将骆驼的数量增加一倍？

93
00:04:02,720 --> 00:04:04,087
我们在实验室里有

94
00:04:04,087 --> 00:04:06,920
因此，在这里，我们可以回到第零讲、

95
00:04:06,920 --> 00:04:09,510
我想，还是回到我们的联系申请上来吧。

96
00:04:09,510 --> 00:04:13,820
因此，在这个应用程序中，我们还存储了姓名、电话号码和其他信息。

97
00:04:13,820 --> 00:04:16,430
我们还能在联系人的应用程序中存储什么？

98
00:04:16,430 --> 00:04:19,430
能不能请第二排中间这一排的人过来？

99
00:04:19,430 --> 00:04:23,330
我们可以在联系人的应用程序中存储哪些内容？

100
00:04:23,330 --> 00:04:23,962
好，说吧

101
00:04:23,962 --> 00:04:24,920
电话号码

102
00:04:24,920 --> 00:04:27,128
电话号码，对，还有其他东西。

103
00:04:27,128 --> 00:04:29,142
也许现在有人在上面一排。

104
00:04:29,142 --> 00:04:30,238
学生：电子邮件。

105
00:04:30,238 --> 00:04:31,280
电子邮件，好的。

106
00:04:31,280 --> 00:04:31,880
其他事情？

107
00:04:31,880 --> 00:04:33,240
我们再往上一排。

108
00:04:33,240 --> 00:04:34,250
我们还能储存什么？

109
00:04:34,250 --> 00:04:35,120
地址

110
00:04:35,120 --> 00:04:35,990
地址，很好。

111
00:04:35,990 --> 00:04:38,390
因此，所有这些东西我们都可以存储在联系人的应用程序中。

112
00:04:38,390 --> 00:04:40,130
但假设您想存储

113
00:04:40,130 --> 00:04:43,040
我想在我的应用程序中，在我的手机上真正打过电话、

114
00:04:43,040 --> 00:04:43,540
对不对？

115
00:04:43,540 --> 00:04:47,180
在这里，我们有一个变量实例，一些数字或数值

116
00:04:47,180 --> 00:04:48,110
可以改变。

117
00:04:48,110 --> 00:04:50,870
我要给它取个名字，在这里就是 "电话"、

118
00:04:50,870 --> 00:04:52,522
我给这里的人打过多少次电话

119
00:04:52,522 --> 00:04:54,980
这就是我们对变量的心理表征。

120
00:04:54,980 --> 00:04:57,080
这是一个可以改变的值的名称。

121
00:04:57,080 --> 00:05:00,382
但在 C 语言中，我将使用一种特殊的语法来创建变量。

122
00:05:00,382 --> 00:05:02,840
在大家一起完成课程问题集的过程中、

123
00:05:02,840 --> 00:05:05,840
要编写自己的程序，就必须熟悉这些语法

124
00:05:05,840 --> 00:05:07,560
以及如何读取和书写。

125
00:05:07,560 --> 00:05:11,395
因此，我们使用 C 语言的语法来创建名为 calls 的变量。

126
00:05:11,395 --> 00:05:14,520
在这里，我们应该深入探讨其中的一些要素。

127
00:05:14,520 --> 00:05:16,910
因此，第一部分是变量的名称。

128
00:05:16,910 --> 00:05:18,530
这个名字就是电话。

129
00:05:18,530 --> 00:05:21,380
注意这句话的中间部分。

130
00:05:21,380 --> 00:05:25,010
我们还有变量类型，即 int 类型。

131
00:05:25,010 --> 00:05:27,577
这个 int 类型代表什么？

132
00:05:27,577 --> 00:05:29,660
我们要在这里存储什么样的数字？

133
00:05:29,660 --> 00:05:30,980
我能问问下面的人吗？

134
00:05:30,980 --> 00:05:31,580
好，说吧

135
00:05:31,580 --> 00:05:32,413
学生：一个整数。

136
00:05:32,413 --> 00:05:34,580
整数，所以是整数，对吗？

137
00:05:34,580 --> 00:05:37,310
然后，我们得到一个值，在本例中是 4，这个值我们要

138
00:05:37,310 --> 00:05:38,990
放入这个变量中。

139
00:05:38,990 --> 00:05:43,460
但我们还缺少一块，我们还没有讨论过。

140
00:05:43,460 --> 00:05:45,420
我们在这里还没有说出什么名字？

141
00:05:45,420 --> 00:05:47,670
我可以问一下房间这边的人吗？

142
00:05:47,670 --> 00:05:49,370
猜猜看？

143
00:05:49,370 --> 00:05:52,940
我们讨论了变量的名称、类型和值。

144
00:05:52,940 --> 00:05:55,430
我们还没有展示哪些句法？

145
00:05:55,430 --> 00:05:56,150
好，说吧

146
00:05:56,150 --> 00:05:58,040
学生：[不明]分号[不明]。

147
00:05:58,040 --> 00:05:59,498
分号，对吗？

148
00:05:59,498 --> 00:06:03,200
因此，这是 C 语言中的一个语句、

149
00:06:03,200 --> 00:06:05,130
我们要在这里加上一个分号。

150
00:06:05,130 --> 00:06:07,130
我们还没谈到的另一件事是

151
00:06:07,130 --> 00:06:08,390
我们在这里还没有谈及的部分，我能否

152
00:06:08,390 --> 00:06:10,220
现在就问这里的人吗？

153
00:06:10,220 --> 00:06:13,100
我们有分号、值、名称和数据类型。

154
00:06:13,100 --> 00:06:14,000
还有一件事

155
00:06:14,000 --> 00:06:14,660
学生：等号。

156
00:06:14,660 --> 00:06:17,810
卡尔特-曾克：等号，是等号吗？

157
00:06:17,810 --> 00:06:18,710
不，你在摇头。

158
00:06:18,710 --> 00:06:19,100
学生：这是作业。

159
00:06:19,100 --> 00:06:21,142
这是一个赋值运算符，对吗？

160
00:06:21,142 --> 00:06:24,290
因此，我们可以说，这将为我们的空间赋值 4。

161
00:06:24,290 --> 00:06:26,150
为名为 call 的变量创建。

162
00:06:26,150 --> 00:06:28,010
所以，如果你在这里用英语说，我们

163
00:06:28,010 --> 00:06:30,540
将创建一个整数变量。

164
00:06:30,540 --> 00:06:32,540
注意这个类型与这里的这个类型是如何一致的。

165
00:06:32,540 --> 00:06:34,820
命名呼叫，名称在此排成一行。

166
00:06:34,820 --> 00:06:39,240
在这个例子中，它可以获取或存储这个值 4。

167
00:06:39,240 --> 00:06:41,360
因此，让我们用另一个值再试一次。

168
00:06:41,360 --> 00:06:47,300
Int x 等于符号 50，如果可以的话，让我们一起来念这一句。

169
00:06:47,300 --> 00:06:49,430
如何说我们创造了什么？

170
00:06:49,430 --> 00:06:50,150
学生： 整数。

171
00:06:50,150 --> 00:06:52,025
CARTER ZENKE：（班级重复后）整数

172
00:06:52,025 --> 00:06:56,190
的值为 50。

173
00:06:56,190 --> 00:06:56,690
不错。

174
00:06:56,690 --> 00:06:58,470
这里的英语就是这个意思。

175
00:06:58,470 --> 00:06:58,970
太神奇了

176
00:06:58,970 --> 00:07:01,280
是啊，大家都来击掌吧。

177
00:07:01,280 --> 00:07:04,888
那么，为什么 C 语言如此关注数据类型呢？

178
00:07:04,888 --> 00:07:07,430
在这里，我们首先要说的不是错误的名称

179
00:07:07,430 --> 00:07:09,870
但实际上是数据类型。

180
00:07:09,870 --> 00:07:12,800
因此，我们在讲座中简单了解了这一观点，但让我们

181
00:07:12,800 --> 00:07:14,690
继续和你旁边的人说话。

182
00:07:14,690 --> 00:07:17,545
您认为 C 为什么如此关注这些数据类型？

183
00:07:17,545 --> 00:07:19,670
为什么我们告诉计算机的第一件事是

184
00:07:19,670 --> 00:07:20,795
我们在这里设置这个变量吗？

185
00:07:20,795 --> 00:07:22,940
我们马上回来。

186
00:07:22,940 --> 00:07:27,230
好了，让我们再来听听为什么 C

187
00:07:27,230 --> 00:07:29,240
如此关心数据类型？

188
00:07:29,240 --> 00:07:32,990
为什么我们在某一行代码中最先输入的是

189
00:07:32,990 --> 00:07:35,460
在这种情况下，是否需要一个变量？

190
00:07:35,460 --> 00:07:38,060
我们能不能回到房间这边来？

191
00:07:38,060 --> 00:07:40,430
有谁愿意分享一下

192
00:07:40,430 --> 00:07:44,580
你们小组讨论过，你们对这个问题有什么想法？

193
00:07:44,580 --> 00:07:45,900
好，说吧

194
00:07:45,900 --> 00:07:48,660
学生：基本上，我们说 C 想知道数据类型。

195
00:07:48,660 --> 00:07:51,670
这是为了限制我们输入的数值。

196
00:07:51,670 --> 00:07:54,685
例如，如果我们讨论的是 [INAUDIBLE] 输入

197
00:07:54,685 --> 00:07:56,610
3.5, so for [INAUDIBLE].

198
00:07:56,610 --> 00:07:58,257
因此，它限制了[INNAUDIBLE]。

199
00:07:58,257 --> 00:08:00,840
卡尔特-曾克：是的，有一些具体的价值，对吗？

200
00:08:00,840 --> 00:08:02,880
我希望能够确保我没有

201
00:08:02,880 --> 00:08:06,240
输入一些我无法存储在这个变量中的值，比如文本、

202
00:08:06,240 --> 00:08:07,620
例如

203
00:08:07,620 --> 00:08:08,610
还有其他原因。

204
00:08:08,610 --> 00:08:10,230
我们能去下面吗？

205
00:08:10,230 --> 00:08:11,085
是啊

206
00:08:11,085 --> 00:08:13,210
学生：计算机需要知道有多少内存

207
00:08:13,210 --> 00:08:15,940
分配给[INNAUDIBLE]。

208
00:08:15,940 --> 00:08:18,965
是啊，这有什么关系呢？

209
00:08:18,965 --> 00:08:20,590
我能问你，也深入一点吗？

210
00:08:20,590 --> 00:08:21,850
为什么这个尺寸很重要？

211
00:08:21,850 --> 00:08:27,160
学生：因为我认为整数的大小比

212
00:08:27,160 --> 00:08:29,800
少了很多[INNAUDIBLE]。

213
00:08:29,800 --> 00:08:31,180
完全正确，所以使用 --

214
00:08:31,180 --> 00:08:33,815
或存储不同的值会使该值被删除

215
00:08:33,815 --> 00:08:35,440
计算机内存中的不同空间。

216
00:08:35,440 --> 00:08:38,710
因此，整数可能占用 32 位，而字符

217
00:08:38,710 --> 00:08:40,115
可能只占 8 个比特。

218
00:08:40,115 --> 00:08:41,990
因此，它会告诉编译器有多少内存、

219
00:08:41,990 --> 00:08:44,200
还要预留多少空间？

220
00:08:44,200 --> 00:08:47,560
还有一个原因，我们在讲座中也看到了一点，那就是我们

221
00:08:47,560 --> 00:08:52,870
这里有一些二进制，这八个比特可以代表某个特定的，嗯、

222
00:08:52,870 --> 00:08:55,260
真的什么都有。

223
00:08:55,260 --> 00:08:56,580
这代表了什么？

224
00:08:56,580 --> 00:08:59,050
有人知道吗？

225
00:08:59,050 --> 00:08:59,670
是啊

226
00:08:59,670 --> 00:09:00,740
学生：不，对不起。

227
00:09:00,740 --> 00:09:02,085
哦，不，好吧。

228
00:09:02,085 --> 00:09:03,210
如果你这样做，我会很惊讶。

229
00:09:03,210 --> 00:09:08,822
但是，这代表的是数字或整数 65，对吗？

230
00:09:08,822 --> 00:09:10,530
但正如我们在讲座中看到的那样

231
00:09:10,530 --> 00:09:14,880
同样的二进制位也可以代表字母 A。

232
00:09:14,880 --> 00:09:18,150
因此，我们必须

233
00:09:18,150 --> 00:09:22,210
通过给出数据类型，告诉 C 语言我们在讨论什么。

234
00:09:22,210 --> 00:09:24,690
这就是我们在这里设置这些数据类型的原因。

235
00:09:24,690 --> 00:09:28,860
如果我们想进一步研究变量，可以更新它们。

236
00:09:28,860 --> 00:09:34,230
在这里，我们在第一行进行了声明和初始化

237
00:09:34,230 --> 00:09:35,610
该变量的调用。

238
00:09:35,610 --> 00:09:38,260
下面我们将更新该值。

239
00:09:38,260 --> 00:09:41,922
请注意，字体在最上面一行，但不在下一行。

240
00:09:41,922 --> 00:09:44,880
为什么会这样呢？

241
00:09:44,880 --> 00:09:45,510
现在？

242
00:09:45,510 --> 00:09:50,360
为什么它在第一行而不在第二行？

243
00:09:50,360 --> 00:09:52,225
好，说吧

244
00:09:52,225 --> 00:09:54,600
学生：在第一行，你启动了变量

245
00:09:54,600 --> 00:09:58,160
并告诉计算机数据类型是什么。

246
00:09:58,160 --> 00:10:01,160
在第二行，你要将它重新赋值给新值、

247
00:10:01,160 --> 00:10:03,458
它已经知道那个变量[INNAUDIBLE].

248
00:10:03,458 --> 00:10:06,500
是的，所以电脑很擅长记东西、

249
00:10:06,500 --> 00:10:07,000
对不对？

250
00:10:07,000 --> 00:10:10,010
一旦你告诉它这个变量具有某种类型，就不需要

251
00:10:10,010 --> 00:10:10,550
再讲一遍。

252
00:10:10,550 --> 00:10:11,540
它已经知道了。

253
00:10:11,540 --> 00:10:13,680
我们可以继续走下去。

254
00:10:13,680 --> 00:10:16,880
因此，我们要在这里初始化并声明变量调用。

255
00:10:16,880 --> 00:10:20,870
但是，当我们再次使用它时，我们就不必告诉它我们所经历的类型了。

256
00:10:20,870 --> 00:10:23,630
现在，如果我们想更改该值，可以这样做。

257
00:10:23,630 --> 00:10:25,730
我们还拥有一些操作人员。

258
00:10:25,730 --> 00:10:28,820
我们可以用这个加号把它加上 1。

259
00:10:28,820 --> 00:10:31,070
我们甚至可以减去一些数字。

260
00:10:31,070 --> 00:10:34,340
我们也许可以用星形运算符乘一些数字。

261
00:10:34,340 --> 00:10:36,360
我们甚至可以除以一些数字，等等。

262
00:10:36,360 --> 00:10:37,610
所以，你可以随便看看。

263
00:10:37,610 --> 00:10:40,360
如果你学习了这门课程，我相信这些内容会浮现在你的脑海中

264
00:10:40,360 --> 00:10:41,220
当我们经过时。

265
00:10:41,220 --> 00:10:47,240
但是，在给某个变量赋值时，它看起来像是一个函数、

266
00:10:47,240 --> 00:10:49,357
好吧，事情就变得有点奇怪了。

267
00:10:49,357 --> 00:10:52,190
我们在讲座中看到，我们正试图从用户那里获取一些输入信息，对吗？

268
00:10:52,190 --> 00:10:56,870
我们也没说字符串的名字就等于 "卡特"

269
00:10:56,870 --> 00:11:00,200
我们说它等于这个，也许，函数，得到字符串。

270
00:11:00,200 --> 00:11:03,290
或者在这里，如果我们想在调用中存储一个值，就得到 int。

271
00:11:03,290 --> 00:11:06,560
在这种情况下，在我们从左到右阅读之前。

272
00:11:06,560 --> 00:11:09,210
但在这种情况下，从右往左读其实更好

273
00:11:09,210 --> 00:11:12,120
当你看到右侧的函数调用时。

274
00:11:12,120 --> 00:11:14,120
因此，这里发生的情况是，当你有

275
00:11:14,120 --> 00:11:16,245
该函数的右侧，该函数

276
00:11:16,245 --> 00:11:19,370
是想逃跑，然后给我们一些回报

277
00:11:19,370 --> 00:11:23,100
将存储在左侧变量中的值。

278
00:11:23,100 --> 00:11:26,300
因此，在做其他事情之前，我们先在右侧运行这个函数

279
00:11:26,300 --> 00:11:29,720
的某些参数，该函数的某些输入

280
00:11:29,720 --> 00:11:31,550
告诉它具体该怎么做。

281
00:11:31,550 --> 00:11:32,840
该功能运行。

282
00:11:32,840 --> 00:11:35,760
也许它会在这里询问用户这个整数。

283
00:11:35,760 --> 00:11:40,110
然后，我们就在调用函数的地方存储该值。

284
00:11:40,110 --> 00:11:42,660
然后将其输入该变量。

285
00:11:42,660 --> 00:11:46,290
现在我们回到简单的变量赋值。

286
00:11:46,290 --> 00:11:50,682
因此，通常情况下，如果只是分配数字，可以从左到右读。

287
00:11:50,682 --> 00:11:53,390
但如果有这些函数调用，最好从右向左阅读、

288
00:11:53,390 --> 00:11:56,390
并知道您的函数会先运行，然后再赋值

289
00:11:56,390 --> 00:11:58,110
当我们经过时。

290
00:11:58,110 --> 00:12:00,335
在我们更深入地讨论之前，请提出问题。

291
00:12:00,335 --> 00:12:10,640


292
00:12:10,640 --> 00:12:12,510
没有。

293
00:12:12,510 --> 00:12:16,160
现在我们已经将这些值存储在这些变量中了、

294
00:12:16,160 --> 00:12:19,160
也许我们应该考虑一下如何将它们打印到屏幕上。

295
00:12:19,160 --> 00:12:21,590
这也是我们在讲座中看到的一点、

296
00:12:21,590 --> 00:12:26,340
这个 %，然后这个 i 在这里。

297
00:12:26,340 --> 00:12:28,310
这对我们有什么好处？

298
00:12:28,310 --> 00:12:30,695
能不能请中间这个区域的人发言？

299
00:12:30,695 --> 00:12:32,570
不介意的话，我们去第一排吧。

300
00:12:32,570 --> 00:12:33,070
是啊

301
00:12:33,070 --> 00:12:35,732
学生：这是我们变量调用的占位符。

302
00:12:35,732 --> 00:12:37,690
是的，您的电话占位符。

303
00:12:37,690 --> 00:12:39,120
为什么是 %i？

304
00:12:39,120 --> 00:12:39,620
你知道吗？

305
00:12:39,620 --> 00:12:41,968
学生：因为它是一个整数[听不清].

306
00:12:41,968 --> 00:12:42,760
是的

307
00:12:42,760 --> 00:12:44,630
学生：我代表[听不清]。

308
00:12:44,630 --> 00:12:46,010
对，所以是%i。

309
00:12:46,010 --> 00:12:48,440
这个 % 就像是在说，嘿，这只是一个占位符。

310
00:12:48,440 --> 00:12:50,810
我指定了哪种变量

311
00:12:50,810 --> 00:12:52,830
可以放在那个占位符里面。

312
00:12:52,830 --> 00:12:55,460
因为 call 是整数，所以是 %i。

313
00:12:55,460 --> 00:12:58,670
更确切地说，我们可能已经说过，这就是所谓的格式代码。

314
00:12:58,670 --> 00:13:01,520
我们可以在格式代码中存储这个值。

315
00:13:01,520 --> 00:13:04,817
我们可以有多个格式代码和多个值。

316
00:13:04,817 --> 00:13:06,150
我们只需用逗号将它们分开。

317
00:13:06,150 --> 00:13:11,060
因此，你可以想象一下，比如我这里有 %i，后面可能还有 %i。

318
00:13:11,060 --> 00:13:13,860
我可以调用，然后用逗号或其他变量。

319
00:13:13,860 --> 00:13:15,980
这些内容将放在占位符中

320
00:13:15,980 --> 00:13:21,020
一个接一个，按照我的顺序排列。

321
00:13:21,020 --> 00:13:24,590
现在，这些都不值得背诵、

322
00:13:24,590 --> 00:13:27,725
但不同的数据类型有大量的格式代码。

323
00:13:27,725 --> 00:13:29,600
当你处理各种数据类型时、

324
00:13:29,600 --> 00:13:31,640
最好能偶尔参考一下。

325
00:13:31,640 --> 00:13:33,110
因此，在左侧，我们有数字

326
00:13:33,110 --> 00:13:35,690
格式代码，如 ints 和 longs、floats 和 doubles、

327
00:13:35,690 --> 00:13:38,420
而右侧则是一些字符和字符串、

328
00:13:38,420 --> 00:13:40,100
其中 char 为单个字符。

329
00:13:40,100 --> 00:13:43,770
字符串是字符的集合。

330
00:13:43,770 --> 00:13:49,440
有一件事我们还没怎么见过，那就是这种长长的两倍。

331
00:13:49,440 --> 00:13:54,100
有人想猜猜这里可能是什么地方吗？

332
00:13:54,100 --> 00:13:56,620
我可以再请中间这排的人吗？

333
00:13:56,620 --> 00:13:59,145


334
00:13:59,145 --> 00:14:00,895
这么长的双倍时间对我们有什么好处？

335
00:14:00,895 --> 00:14:05,710


336
00:14:05,710 --> 00:14:06,400
好，说吧

337
00:14:06,400 --> 00:14:11,834
学生：长[听不清]的空间[听不清]更大吗？

338
00:14:11,834 --> 00:14:16,023
你必须有长到[INNAUDIBLE]？

339
00:14:16,023 --> 00:14:17,190
是的，没错。

340
00:14:17,190 --> 00:14:22,242
因此，我们这里有一个可以存储多达 40 亿个值的整数。

341
00:14:22,242 --> 00:14:23,950
但如果这还不够，我们可能会想

342
00:14:23,950 --> 00:14:27,150
的值更长，这里称为 long、

343
00:14:27,150 --> 00:14:29,410
这将为我们提供两倍的空间。

344
00:14:29,410 --> 00:14:32,322
我们可以存储两倍于我们所经历的不同组合。

345
00:14:32,322 --> 00:14:33,280
真的，不止如此。

346
00:14:33,280 --> 00:14:36,310
我们只是用两倍的比特来表示这些信息。

347
00:14:36,310 --> 00:14:39,330
同样，浮点数也是小数。

348
00:14:39,330 --> 00:14:43,030
但这个 double 被称为双精度浮点。

349
00:14:43,030 --> 00:14:46,260
因此，我们会有两倍的小数，两倍的二进制数

350
00:14:46,260 --> 00:14:48,630
为我们表示小数点后的数字

351
00:14:48,630 --> 00:14:52,610
这样，我们就有更多的空间可以利用了。

352
00:14:52,610 --> 00:14:54,740
现在，我们来做一个简单的练习

353
00:14:54,740 --> 00:15:01,107
并邀请您在自己的笔记本电脑上加载 code.cs50.io。

354
00:15:01,107 --> 00:15:03,440
你应该会看到类似这样的内容。

355
00:15:03,440 --> 00:15:06,125
也许你的左侧有一个文件资源管理器。

356
00:15:06,125 --> 00:15:11,083


357
00:15:11,083 --> 00:15:13,250
但你肯定应该在下面有一个终端。

358
00:15:13,250 --> 00:15:13,958
我看到一个问题。

359
00:15:13,958 --> 00:15:14,753
是啊

360
00:15:14,753 --> 00:15:17,200
学生：我不知道这是不是打错了，才会这样。

361
00:15:17,200 --> 00:15:18,778
但如果你回到幻灯片

362
00:15:18,778 --> 00:15:19,820
是的，是的。

363
00:15:19,820 --> 00:15:22,950


364
00:15:22,950 --> 00:15:26,514
学生：所以 double 表示 f，float 表示 f。

365
00:15:26,514 --> 00:15:27,450
是这样吗？

366
00:15:27,450 --> 00:15:28,700
CARTER ZENKE：没错。

367
00:15:28,700 --> 00:15:31,770
因此，浮点数和双倍数的格式代码是一样的。

368
00:15:31,770 --> 00:15:32,550
问得好。

369
00:15:32,550 --> 00:15:35,847
那么计算机是如何[听不清]

370
00:15:35,847 --> 00:15:38,508
在[INNAUDIBLE]之间识别？

371
00:15:38,508 --> 00:15:40,800
电脑是如何识别每一个人的？

372
00:15:40,800 --> 00:15:45,160
在这种情况下，这并不重要，因为在这种情况下、

373
00:15:45,160 --> 00:15:47,580
浮点数和双倍数都是十进制数。

374
00:15:47,580 --> 00:15:51,390
这样，当计算机看到 %f 时，就知道我打印的是一个十进制数。

375
00:15:51,390 --> 00:15:53,950
碰巧的是，双倍的长度是两倍。

376
00:15:53,950 --> 00:15:56,400
因此，它只是打印更多的 --

377
00:15:56,400 --> 00:15:59,310
好吧，它可以在小数点后多打印那么多空格

378
00:15:59,310 --> 00:16:01,230
如果你愿意的话。

379
00:16:01,230 --> 00:16:03,450
在我们继续之前，还有其他问题吗？

380
00:16:03,450 --> 00:16:08,070


381
00:16:08,070 --> 00:16:10,950
好了，我们来做一个简短的练习。

382
00:16:10,950 --> 00:16:15,260
一旦您在 code.cs50.io 中加载了集成开发环境，您就可以开始使用它了、

383
00:16:15,260 --> 00:16:18,380
创建一个名为 phonebook.c 的应用程序。

384
00:16:18,380 --> 00:16:21,800
我们的目标是提示用户以下三点

385
00:16:21,800 --> 00:16:24,680
然后打印出来给用户确认

386
00:16:24,680 --> 00:16:27,540
这些数据存储在您的程序中。

387
00:16:27,540 --> 00:16:32,810
因此，如果我想这样做，我会先去下面的终端。

388
00:16:32,810 --> 00:16:35,225
我会新建一个文件。

389
00:16:35,225 --> 00:16:37,100
要在这里新建一个文件，我该怎么做？

390
00:16:37,100 --> 00:16:40,730
能请右下方的人回答吗？

391
00:16:40,730 --> 00:16:44,720
如何在此程序中新建文件？

392
00:16:44,720 --> 00:16:45,290
是啊

393
00:16:45,290 --> 00:16:46,838
学生：代码和文件名。

394
00:16:46,838 --> 00:16:48,630
是的，代码和文件名。

395
00:16:48,630 --> 00:16:51,860
因此，如果能加载到这里，我可以写代码。

396
00:16:51,860 --> 00:16:54,510


397
00:16:54,510 --> 00:16:55,160
让我来复习一下。

398
00:16:55,160 --> 00:17:00,270
不过，你可以自己编写代码，并在这里输入文件名。

399
00:17:00,270 --> 00:17:04,520
为了我们的目的，我将在代码空间中编写 phonebook.c。

400
00:17:04,520 --> 00:17:09,123
不过，你也可以在这里给你的程序起其他任何名字。

401
00:17:09,123 --> 00:17:10,790
也许你的情况也是如此。

402
00:17:10,790 --> 00:17:12,290
我们马上回来。

403
00:17:12,290 --> 00:17:17,200


404
00:17:17,200 --> 00:17:22,008
现在，一旦你有了你的文件，什么往往会放在文件的最顶端？

405
00:17:22,008 --> 00:17:23,550
您首先要补充的是什么？

406
00:17:23,550 --> 00:17:25,560
我们在讲座中看到了这一点。

407
00:17:25,560 --> 00:17:26,280
好，说吧

408
00:17:26,280 --> 00:17:27,000
学生：标题。

409
00:17:27,000 --> 00:17:29,375
头文件或这些库，对吗？

410
00:17:29,375 --> 00:17:32,150
你还记得它的语法吗？

411
00:17:32,150 --> 00:17:37,330
学生：包括 Hashtag，然后是 caret。

412
00:17:37,330 --> 00:17:41,080
是的，hashtag 包括这个小标记。

413
00:17:41,080 --> 00:17:42,700
让我们看看这辆车是否已经装载完毕。

414
00:17:42,700 --> 00:17:46,030
不完全是这样，但这个标签包含的意思是、

415
00:17:46,030 --> 00:17:49,690
我将尝试在我的电脑内存中获取一些文件

416
00:17:49,690 --> 00:17:54,130
为我声明了这些函数，我将在自己的程序中使用这些函数

417
00:17:54,130 --> 00:17:54,830
这里。

418
00:17:54,830 --> 00:18:01,990
那么，您想在程序中包含哪两个头文件呢？

419
00:18:01,990 --> 00:18:02,590
是啊

420
00:18:02,590 --> 00:18:04,592
学生：Standardio.h。

421
00:18:04,592 --> 00:18:07,300
卡尔特-曾克：很好，那么有两个你经常要用到的词是

422
00:18:07,300 --> 00:18:11,440
是 standardio.h 或 stdio.h cs50.h。

423
00:18:11,440 --> 00:18:13,720
这两者都有一些共同的功能

424
00:18:13,720 --> 00:18:15,880
你在编写自己的程序时会用到。

425
00:18:15,880 --> 00:18:22,030


426
00:18:22,030 --> 00:18:26,770
我们将等待它继续连接，而我们实际上要做的是

427
00:18:26,770 --> 00:18:29,770
是，现在你也许有希望打开文件了、

428
00:18:29,770 --> 00:18:33,340
头文件，我们需要一些时间、

429
00:18:33,340 --> 00:18:35,670
比方说，也许 10 分钟，让我们自己解决这个问题。

430
00:18:35,670 --> 00:18:36,820
我把滑梯放回去

431
00:18:36,820 --> 00:18:39,070
我们将在这 10 分钟内回来分享

432
00:18:39,070 --> 00:18:40,510
你是如何解决这个问题的？

433
00:18:40,510 --> 00:18:43,000
也许工作人员愿意在你工作时跑来跑去帮助你。

434
00:18:43,000 --> 00:18:44,208
请随意举手。

435
00:18:44,208 --> 00:18:46,070
我们会过来帮你的。

436
00:18:46,070 --> 00:18:47,980
好吧，让我们回来。

437
00:18:47,980 --> 00:18:51,148
我们的工作环境略有不同

438
00:18:51,148 --> 00:18:53,690
只是因为互联网并不完全如我们所愿。

439
00:18:53,690 --> 00:18:56,773
但是，我们要在这里制作我们自己的电话簿文件，在这里我们可以真正

440
00:18:56,773 --> 00:18:58,310
存储我们想要存储的数据。

441
00:18:58,310 --> 00:19:00,545
所以，如果你还记得我们的幻灯片，我们

442
00:19:00,545 --> 00:19:02,170
想储存一些不同的东西。

443
00:19:02,170 --> 00:19:07,630
您想存储用户的姓名和电话号码、

444
00:19:07,630 --> 00:19:09,460
我想那是他们的地址。

445
00:19:09,460 --> 00:19:14,980
让我再看一遍幻灯片，如果我们回到这里。

446
00:19:14,980 --> 00:19:17,390
姓名、年龄和电话号码。

447
00:19:17,390 --> 00:19:21,550
因此，我们有了这个程序模板、

448
00:19:21,550 --> 00:19:23,650
但我们现在错过了什么？

449
00:19:23,650 --> 00:19:25,720
我们有头文件和这些库，其中

450
00:19:25,720 --> 00:19:27,220
我有我们要用的功能。

451
00:19:27,220 --> 00:19:29,665
在这个项目中，我们还缺少什么？

452
00:19:29,665 --> 00:19:30,790
请问

453
00:19:30,790 --> 00:19:31,450
是啊，在这里。

454
00:19:31,450 --> 00:19:32,350
学生： Int main void.

455
00:19:32,350 --> 00:19:33,808
是的，主要的空隙。

456
00:19:33,808 --> 00:19:37,330
所以我会在这里输入 int main 和 void。

457
00:19:37,330 --> 00:19:39,340
这只是象征--这是一种

458
00:19:39,340 --> 00:19:41,650
的标志块。

459
00:19:41,650 --> 00:19:43,900
这将是我们项目的主要部分。

460
00:19:43,900 --> 00:19:46,330
我们要定义一个名为 Main 的新函数，它的功能是

461
00:19:46,330 --> 00:19:49,160
将是我们计划的主要部分。

462
00:19:49,160 --> 00:19:51,340
现在，我们要做的第一件事可能是

463
00:19:51,340 --> 00:19:54,200
提示用户提供一些信息。

464
00:19:54,200 --> 00:20:00,100
那么，你们都使用了哪些函数来获取用户名或联系人姓名呢？

465
00:20:00,100 --> 00:20:01,420
我们想在这里讲故事？

466
00:20:01,420 --> 00:20:02,020
我能在这里问吗？

467
00:20:02,020 --> 00:20:02,650
好，说吧

468
00:20:02,650 --> 00:20:03,400
学生：获取字符串。

469
00:20:03,400 --> 00:20:04,442
获取字符串。

470
00:20:04,442 --> 00:20:07,855
在这种情况下，你是如何做出变数的？

471
00:20:07,855 --> 00:20:11,450
学生：因为我们的变量是字符串，所以我输入字符串。

472
00:20:11,450 --> 00:20:12,928
然后，我为我的变量命名。

473
00:20:12,928 --> 00:20:13,720
很好

474
00:20:13,720 --> 00:20:18,958
学生：然后我说等价交换，你叫什么名字？

475
00:20:18,958 --> 00:20:20,750
获取字符串，你叫什么名字。

476
00:20:20,750 --> 00:20:21,708
是这样吗？

477
00:20:21,708 --> 00:20:23,320
学生：名字后面有空格。

478
00:20:23,320 --> 00:20:25,820
是啊，为什么要在那里留出空间呢？

479
00:20:25,820 --> 00:20:26,540
学生：只是为了便于阅读。

480
00:20:26,540 --> 00:20:27,240
只是可读性，对吗？

481
00:20:27,240 --> 00:20:29,900
如果我们没有这个空间，也许可以把这个移走、

482
00:20:29,900 --> 00:20:31,970
用户将直接输入自己的名字

483
00:20:31,970 --> 00:20:33,887
对着那个问号，这不是

484
00:20:33,887 --> 00:20:36,000
我们希望在这里发生什么。

485
00:20:36,000 --> 00:20:39,080
因此，用字符串来表示名称似乎非常合理。

486
00:20:39,080 --> 00:20:40,873
但这里的年龄如何？

487
00:20:40,873 --> 00:20:42,540
我能去房间的这边吗？

488
00:20:42,540 --> 00:20:47,840
你们是如何让用户知道联系人的年龄的？

489
00:20:47,840 --> 00:20:48,440
是啊

490
00:20:48,440 --> 00:20:57,780
学生：我做了 int age equals 得到 int，然后在括号里我有--------------。

491
00:20:57,780 --> 00:21:00,450
你的年龄是多少？

492
00:21:00,450 --> 00:21:02,980
然后是分号。

493
00:21:02,980 --> 00:21:03,480
太完美了

494
00:21:03,480 --> 00:21:05,200
因此，本声明到此结束。

495
00:21:05,200 --> 00:21:07,800
同样，右侧的函数也会被调用。

496
00:21:07,800 --> 00:21:10,590
它将运行并返回一些返回值，这些返回值是

497
00:21:10,590 --> 00:21:15,900
用户输入的任何信息，并将其存储在名为 age 的变量中。

498
00:21:15,900 --> 00:21:17,460
然后是一个带着

499
00:21:17,460 --> 00:21:19,300
这里有问题吗？

500
00:21:19,300 --> 00:21:27,280
学生：我们还能写出字符串年龄吗？

501
00:21:27,280 --> 00:21:29,906
是的，你在这里试过了吗？

502
00:21:29,906 --> 00:21:34,283
学生：是啊，[听不清]是什么？

503
00:21:34,283 --> 00:21:35,450
CARTER ZENKE：问得好。

504
00:21:35,450 --> 00:21:38,330
因此，我们可以在这里做其中的任何一个。

505
00:21:38,330 --> 00:21:39,520
一个是整数。

506
00:21:39,520 --> 00:21:41,290
一个是字符串。

507
00:21:41,290 --> 00:21:45,140
但你可以想象，如果我以后想做这样的事情、

508
00:21:45,140 --> 00:21:49,780
比方说，我想把我手机里每个人的年龄都增加一个、

509
00:21:49,780 --> 00:21:51,520
也许明年就是他们的生日了。

510
00:21:51,520 --> 00:21:56,107
所以我说年龄等于年龄加 1。

511
00:21:56,107 --> 00:21:58,190
你认为这对字符串有用吗？

512
00:21:58,190 --> 00:21:58,930
学生：没有。

513
00:21:58,930 --> 00:22:04,750
CARTER ZENKE：不，因为我要在这个引号之外再加 1 个引号，也许是 40 个、

514
00:22:04,750 --> 00:22:05,650
例如

515
00:22:05,650 --> 00:22:07,713
我也无法在字符串中添加数字。

516
00:22:07,713 --> 00:22:09,130
这对我来说是不可能的。

517
00:22:09,130 --> 00:22:11,800
因此，制作时最好先想一下

518
00:22:11,800 --> 00:22:15,650
当你在这里开展项目时，你想用它们做些什么。

519
00:22:15,650 --> 00:22:18,340
因此，我想随着时间的推移改变我的年龄。

520
00:22:18,340 --> 00:22:24,550
因此，我可能会在这里把它变成一个整数，然后说 get int。

521
00:22:24,550 --> 00:22:25,830
现在是电话号码。

522
00:22:25,830 --> 00:22:28,560
如果你去中间这个部分，你们都是怎么

523
00:22:28,560 --> 00:22:32,090
选择代表电话号码？

524
00:22:32,090 --> 00:22:33,500
是啊

525
00:22:33,500 --> 00:22:36,670
学生：长数等于得长。

526
00:22:36,670 --> 00:22:39,610
卡尔特-曾克：长数等于变长。

527
00:22:39,610 --> 00:22:41,485
你可能会问，你的电话号码是多少？

528
00:22:41,485 --> 00:22:42,710
学生：是的。

529
00:22:42,710 --> 00:22:44,668
卡尔特-曾克：我觉得我最好奇的是

530
00:22:44,668 --> 00:22:46,840
为什么选择长。

531
00:22:46,840 --> 00:22:49,550
你为什么会有那个？

532
00:22:49,550 --> 00:22:50,540
是啊

533
00:22:50,540 --> 00:22:53,279
学生：因为不止 20 亿、

534
00:22:53,279 --> 00:22:56,703
所以，你需要额外的[INNAUDIBLE]。

535
00:22:56,703 --> 00:22:58,620
电话号码是什么？

536
00:22:58,620 --> 00:23:01,060
可能有 10 位数长。

537
00:23:01,060 --> 00:23:05,580
所以，如果我有任何电话号码开头超过2、

538
00:23:05,580 --> 00:23:07,447
会高于 20 亿、

539
00:23:07,447 --> 00:23:10,030
这是我能得到的最高正整数。

540
00:23:10,030 --> 00:23:11,760
所以，我想在这里待上很长时间。

541
00:23:11,760 --> 00:23:12,390
是啊，问题。

542
00:23:12,390 --> 00:23:14,360
学生：你能用字符串来

543
00:23:14,360 --> 00:23:16,360
CARTER ZENKE：你完全可以用绳子。

544
00:23:16,360 --> 00:23:20,983
你为什么主张使用字符串？

545
00:23:20,983 --> 00:23:24,280
学生：[听不清]

546
00:23:24,280 --> 00:23:26,140
很好，连字符。

547
00:23:26,140 --> 00:23:30,130
如果你们在不同的国家，还可以包括、

548
00:23:30,130 --> 00:23:34,510
该国家代码加 1，以及其他国家代码。

549
00:23:34,510 --> 00:23:37,990
如果您想把区号放在前面，还可以加上括号。

550
00:23:37,990 --> 00:23:39,070
是啊

551
00:23:39,070 --> 00:23:44,110
学生：另外，我认为如果使用整数或长、

552
00:23:44,110 --> 00:23:48,960
你应该能根据这个数字计算出一些东西。

553
00:23:48,960 --> 00:23:52,630
通常情况下，你不会添加内容或分割电话号码。

554
00:23:52,630 --> 00:23:58,008
因此，要求[INNAUDIBLE]没有实际目的。

555
00:23:58,008 --> 00:23:59,300
是的，当然。

556
00:23:59,300 --> 00:24:01,758
因此，我们倾向于不在电话号码上添加内容。

557
00:24:01,758 --> 00:24:04,550
那么，为什么要把它存储为我们可以加减的数字呢？

558
00:24:04,550 --> 00:24:06,500
或分割或任何我们想要的东西，对吗？

559
00:24:06,500 --> 00:24:08,990
问得好。

560
00:24:08,990 --> 00:24:10,760
因此，我们在这里把它作为一个字符串。

561
00:24:10,760 --> 00:24:14,120
字符串还保留了前导零等内容。

562
00:24:14,120 --> 00:24:17,388
也许有人有一个 000 号码、

563
00:24:17,388 --> 00:24:20,180
我们可以用字符串来存储，但不能用 long 来存储。

564
00:24:20,180 --> 00:24:23,750
在这种情况下，我们倾向于去掉这些前导零。

565
00:24:23,750 --> 00:24:24,770
是啊

566
00:24:24,770 --> 00:24:27,690
学生：但[听不清]使用长[听不清]一个

567
00:24:27,690 --> 00:24:29,520
真的不需要吗？

568
00:24:29,520 --> 00:24:31,860
CARTER ZENKE：如果我说这里的年龄可能很长？

569
00:24:31,860 --> 00:24:32,970
学生：是的。

570
00:24:32,970 --> 00:24:36,150
CARTER ZENKE：也许还能延长时间，实现均等。

571
00:24:36,150 --> 00:24:38,280
这里不会发生任何坏事。

572
00:24:38,280 --> 00:24:41,940
我使用的空间可能是我需要的空间的两倍。

573
00:24:41,940 --> 00:24:45,490
所以一般来说，我认为人们的年龄不会超过 20 亿。

574
00:24:45,490 --> 00:24:49,380
因此，我可能只想使用普通整数来存储该值。

575
00:24:49,380 --> 00:24:51,420
不错。

576
00:24:51,420 --> 00:24:55,230
关于这些信息的表述还有其他问题吗？

577
00:24:55,230 --> 00:24:58,700


578
00:24:58,700 --> 00:25:00,920
好吧，我们就用这个整数。

579
00:25:00,920 --> 00:25:03,392
然后，快速查看我们的格式代码、

580
00:25:03,392 --> 00:25:05,600
所以，假设我想打印出其中的一些数据。

581
00:25:05,600 --> 00:25:07,160
我可以说是 printf。

582
00:25:07,160 --> 00:25:11,100
比方说，也许年龄是 --

583
00:25:11,100 --> 00:25:14,090
那我该怎么说呢？

584
00:25:14,090 --> 00:25:15,590
也许只是把它叫出来。

585
00:25:15,590 --> 00:25:16,425
学生：%i。

586
00:25:16,425 --> 00:25:17,300
好的

587
00:25:17,300 --> 00:25:18,050
年龄是 %i。

588
00:25:18,050 --> 00:25:20,720
我要把句号放在这里。

589
00:25:20,720 --> 00:25:24,830
姓名是 %s。

590
00:25:24,830 --> 00:25:32,430
假设电话号码是 %s，好吗？

591
00:25:32,430 --> 00:25:34,500
现在，就像我们之前看到的那样，把它储存起来、

592
00:25:34,500 --> 00:25:37,587
我可以简单地将这些变量按照相同的顺序排列

593
00:25:37,587 --> 00:25:39,670
我希望它们显示在这里的占位符中。

594
00:25:39,670 --> 00:25:41,450
所以我可以说，好吧，年龄是第一位的。

595
00:25:41,450 --> 00:25:44,170
所以我先说年龄，再说名字。

596
00:25:44,170 --> 00:25:45,000
那我就说名字吧。

597
00:25:45,000 --> 00:25:47,880
最后是数字，所以我要说数字，把一切都结束了

598
00:25:47,880 --> 00:25:49,590
这里用分号。

599
00:25:49,590 --> 00:25:53,580
要制作这个，我只需输入制作电话簿并运行它。

600
00:25:53,580 --> 00:25:57,240
然后，我就会看到屏幕上打印出这些信息

601
00:25:57,240 --> 00:25:58,620
就像这样。

602
00:25:58,620 --> 00:26:00,945
所以，在我们继续之前，请提出问题。

603
00:26:00,945 --> 00:26:04,510


604
00:26:04,510 --> 00:26:10,590
好吧，那么其他构件之一

605
00:26:10,590 --> 00:26:12,990
除了这些变量和表征之外

606
00:26:12,990 --> 00:26:14,853
这里有这些条件和循环。

607
00:26:14,853 --> 00:26:16,770
我们在讲座中也看到了这些内容，但我们将

608
00:26:16,770 --> 00:26:19,780
现在就将这些内容用于课程的实验室，共同完成。

609
00:26:19,780 --> 00:26:24,180
首先是这个问题。

610
00:26:24,180 --> 00:26:27,600
我打电话的次数少于一次吗？

611
00:26:27,600 --> 00:26:32,280
如果我有，那我就会经常打电话。

612
00:26:32,280 --> 00:26:34,500
不过，我只是想在这里说一些词汇、

613
00:26:34,500 --> 00:26:38,880
这个条件的内部就是我们的布尔表达式。

614
00:26:38,880 --> 00:26:40,170
要么是，要么不是。

615
00:26:40,170 --> 00:26:43,750
我打电话的次数是否少于一次？

616
00:26:43,750 --> 00:26:46,100
这里的外侧就是条件本身。

617
00:26:46,100 --> 00:26:49,550
因此，条件式内部有布尔表达式。

618
00:26:49,550 --> 00:26:51,550
不过，我可以把它做得更先进一些、

619
00:26:51,550 --> 00:26:55,970
我还可以把这个放在中间。

620
00:26:55,970 --> 00:26:58,540
这对我有什么好处？

621
00:26:58,540 --> 00:27:02,260
我能同时做这两件事吗？

622
00:27:02,260 --> 00:27:03,930
我能在这里问吗？

623
00:27:03,930 --> 00:27:06,025
我能同时做这两件事吗？

624
00:27:06,025 --> 00:27:06,900
摇摇头说不。

625
00:27:06,900 --> 00:27:07,230
对

626
00:27:07,230 --> 00:27:09,170
因此，这两件事是相互排斥的。

627
00:27:09,170 --> 00:27:12,780
如果我这里还有这个，我就说不是这个就是那个。

628
00:27:12,780 --> 00:27:15,450
如果电话少于 1 个，我会第一时间拨打。

629
00:27:15,450 --> 00:27:18,420
如果不是，我会做第二件事。

630
00:27:18,420 --> 00:27:21,660
你甚至可以在 Scratch 中将这些语句串联起来。

631
00:27:21,660 --> 00:27:25,140
你可以说 "如果"，然后 "如果"，然后 "如果"、

632
00:27:25,140 --> 00:27:26,400
最后，它还很长。

633
00:27:26,400 --> 00:27:30,480
一般来说，我们会在这些 if 语句后面加上这些 else 语句

634
00:27:30,480 --> 00:27:33,870
if 语句，其次是如果你需要它们，那最后再说、

635
00:27:33,870 --> 00:27:37,815
就像一个包罗万象的地方，我们可能会在这里发生其他任何事情。

636
00:27:37,815 --> 00:27:40,440
对于循环，如果您想多次执行某项操作、

637
00:27:40,440 --> 00:27:43,300
我们有一个看起来有点像这样的东西，这个 while 循环。

638
00:27:43,300 --> 00:27:45,450
屏幕上会打印出什么？

639
00:27:45,450 --> 00:27:47,760
我可以问一下房间这边的人吗？

640
00:27:47,760 --> 00:27:49,968
你在屏幕上会看到什么？

641
00:27:49,968 --> 00:27:56,110


642
00:27:56,110 --> 00:27:56,740
好，说吧

643
00:27:56,740 --> 00:27:59,660
学生：0、1、2、3 至 9。

644
00:27:59,660 --> 00:28:01,410
最多 9 个，为什么不是 10 个？

645
00:28:01,410 --> 00:28:03,598
学生：因为当 i 小于 10 时。

646
00:28:03,598 --> 00:28:04,390
很好

647
00:28:04,390 --> 00:28:07,660
是啊，所以我们不会看到10 因为我们要停止，而 -

648
00:28:07,660 --> 00:28:11,840
如果这不是真的，我们就停止。

649
00:28:11,840 --> 00:28:14,650
因此，10 并不小于 10，所以我们将停止

650
00:28:14,650 --> 00:28:17,560
我们就不会在内部编写代码，对吗？

651
00:28:17,560 --> 00:28:21,500
因此，为了进一步细分，我们要对这个循环进行初始化。

652
00:28:21,500 --> 00:28:23,560
I 首先设置为 0。

653
00:28:23,560 --> 00:28:25,303
然后我们就有了布尔表达式，即

654
00:28:25,303 --> 00:28:27,220
我们要问的问题，要么是，要么不是。

655
00:28:27,220 --> 00:28:29,000
这个案例是真的还是假的？

656
00:28:29,000 --> 00:28:33,460
最后，在实施过程中，我们会改变该值。

657
00:28:33,460 --> 00:28:36,010
最后，当我们的布尔表达式不再为真时、

658
00:28:36,010 --> 00:28:38,865
我们将不会进入那个循环。

659
00:28:38,865 --> 00:28:39,740
这真的很方便。

660
00:28:39,740 --> 00:28:43,150
实际上，我们可以尝试让代码运行一定的次数。

661
00:28:43,150 --> 00:28:46,270
这非常方便，C 语言实际上有自己的语法

662
00:28:46,270 --> 00:28:48,950
甚至可以用简短的格式写出这种循环。

663
00:28:48,950 --> 00:28:53,770
因此，我们在这里调用了一个 for 循环，它包含所有这些相同的元素，但现在只有

664
00:28:53,770 --> 00:28:54,910
一目了然。

665
00:28:54,910 --> 00:28:58,670
我们有这个初始化，这个布尔表达式、

666
00:28:58,670 --> 00:29:00,910
然后在这里递增。

667
00:29:00,910 --> 00:29:03,160
我们要做的是，不管里面的代码是什么

668
00:29:03,160 --> 00:29:06,640
只要该布尔表达式为真。

669
00:29:06,640 --> 00:29:11,070
对这些循环的语法有疑问吗？

670
00:29:11,070 --> 00:29:12,775
相当不错。

671
00:29:12,775 --> 00:29:15,150
最后，我只想说点更高级的。

672
00:29:15,150 --> 00:29:16,440
我们有这个 - 是啊，请便。

673
00:29:16,440 --> 00:29:19,290
学生：我有一个问题。

674
00:29:19,290 --> 00:29:25,193
为什么要加括号？

675
00:29:25,193 --> 00:29:26,360
CARTER ZENKE：问得好。

676
00:29:26,360 --> 00:29:27,360
所以你在这里看到了 int？

677
00:29:27,360 --> 00:29:28,180
学生：是的。

678
00:29:28,180 --> 00:29:29,972
为什么会在那里？

679
00:29:29,972 --> 00:29:34,540
因为在此之前，我们的 int i 已经为我们完成了，对吗？

680
00:29:34,540 --> 00:29:37,280
因此，这实际上是两种不同的语境。

681
00:29:37,280 --> 00:29:41,230
因此，我在这里创建了名为 i 的变量、

682
00:29:41,230 --> 00:29:43,570
我将在这个循环中使用它。

683
00:29:43,570 --> 00:29:46,900
而这个变量 i，因为它在 while 循环之外、

684
00:29:46,900 --> 00:29:48,940
在我的教学计划中，这些问题会一直存在。

685
00:29:48,940 --> 00:29:51,430
因此，我可以再次使用这个变量 i。

686
00:29:51,430 --> 00:29:56,200
但在 for 循环中，如果我重新创建这个变量 i、

687
00:29:56,200 --> 00:29:58,900
我只能在这个 for 循环中使用它。

688
00:29:58,900 --> 00:30:01,340
我无法在 for 循环之外使用它。

689
00:30:01,340 --> 00:30:04,030
因此，只要是在 for 循环中，我就不能使用任何

690
00:30:04,030 --> 00:30:05,860
我在此之外创造的变量。

691
00:30:05,860 --> 00:30:09,040
必须限制在 for 循环内部。

692
00:30:09,040 --> 00:30:10,420
有帮助吗？

693
00:30:10,420 --> 00:30:11,433
好极了

694
00:30:11,433 --> 00:30:12,475
这里还有其他问题。

695
00:30:12,475 --> 00:30:15,810


696
00:30:15,810 --> 00:30:18,713
学生：我看到 for 循环末尾没有分号。

697
00:30:18,713 --> 00:30:20,630
为什么没有分号？

698
00:30:20,630 --> 00:30:24,680
那么，经验法则大概是这样的。

699
00:30:24,680 --> 00:30:27,770
分号位于完整语句之后。

700
00:30:27,770 --> 00:30:31,970
这个 for 循环正在设置一些语句。

701
00:30:31,970 --> 00:30:35,550
它在说，我最终会有自己想做的事情、

702
00:30:35,550 --> 00:30:36,750
但现在还没有。

703
00:30:36,750 --> 00:30:38,960
所以，我真的要戴上这些牙套了

704
00:30:38,960 --> 00:30:43,140
来告诉我想按顺序执行哪些语句。

705
00:30:43,140 --> 00:30:46,670
因此，当你编写更多代码时，你就会习惯这一点。

706
00:30:46,670 --> 00:30:49,250
但一般来说，语句以分号结束、

707
00:30:49,250 --> 00:30:51,530
但设置声明的东西一般不会。

708
00:30:51,530 --> 00:30:55,120
他们可能有牙套

709
00:30:55,120 --> 00:30:56,203
是啊

710
00:30:56,203 --> 00:30:59,584
学生：所以你提到了[听不清]变量

711
00:30:59,584 --> 00:31:02,010
i 只存在于参数中。

712
00:31:02,010 --> 00:31:03,270
没错。

713
00:31:03,270 --> 00:31:07,730
学生：这是否意味着当你连续执行多个 for 循环时

714
00:31:07,730 --> 00:31:09,592
不是[INNAUDIBLE]？

715
00:31:09,592 --> 00:31:11,300
是的，这是个好问题。

716
00:31:11,300 --> 00:31:17,570
因此，如果我回到实际的编程环境中、

717
00:31:17,570 --> 00:31:20,270
比方说，我有一个循环。

718
00:31:20,270 --> 00:31:25,040
我要说四个 int i 等于 0，i 小于 10。

719
00:31:25,040 --> 00:31:26,930
i++.

720
00:31:26,930 --> 00:31:31,370
现在，我可以访问这两个大括号内的 i。

721
00:31:31,370 --> 00:31:32,750
这就是所谓的范围。

722
00:31:32,750 --> 00:31:33,958
这是变量的作用域。

723
00:31:33,958 --> 00:31:35,900
它一直存在于这个空间里。

724
00:31:35,900 --> 00:31:38,310
我不能在这里用 i。

725
00:31:38,310 --> 00:31:42,577
因此，我不能在那里访问它，但我可以，例如，设置另一个 for 循环

726
00:31:42,577 --> 00:31:43,160
在里面。

727
00:31:43,160 --> 00:31:47,030
我可以说 j 等于 i。

728
00:31:47,030 --> 00:31:49,670
这是完全正确的，因为我就在这个循环里。

729
00:31:49,670 --> 00:31:53,420
在这种情况下，也许 j 小于 10，然后 j++。

730
00:31:53,420 --> 00:31:55,760
我在其中还做了别的事情。

731
00:31:55,760 --> 00:31:59,720
而实际上，J 在这里是无法访问的。

732
00:31:59,720 --> 00:32:03,560
我做不到，但在那个循环里是可以访问的。

733
00:32:03,560 --> 00:32:07,878


734
00:32:07,878 --> 00:32:08,920
这里还有其他问题吗？

735
00:32:08,920 --> 00:32:10,108
是啊

736
00:32:10,108 --> 00:32:11,400
学生：我有点困惑。

737
00:32:11,400 --> 00:32:15,910
我想，能感知 "我 "是什么的部分在哪里？

738
00:32:15,910 --> 00:32:19,600
它只是看起来[INNAUDIBLE]。

739
00:32:19,600 --> 00:32:23,380
你能告诉我你所说的 "感觉 "是什么意思吗？

740
00:32:23,380 --> 00:32:29,715
学生：对，因为它就像布尔表达式、

741
00:32:29,715 --> 00:32:36,540
对，i 是大于 1 还是小于 1，类似这样的问题。

742
00:32:36,540 --> 00:32:41,260
那么，输入的是 1 还是 i 的值呢？

743
00:32:41,260 --> 00:32:44,030
是啊，最好是这样想、

744
00:32:44,030 --> 00:32:46,630
从上到下读取我的代码。

745
00:32:46,630 --> 00:32:50,870
当它进入这个 for 循环时，会从左到右读取。

746
00:32:50,870 --> 00:32:55,330
因此，第一次进入 for 循环时，我将把这个变量 i

747
00:32:55,330 --> 00:32:57,190
并将其设置为 0。

748
00:32:57,190 --> 00:33:01,480
那我要问的问题是，i 小于 10 吗？

749
00:33:01,480 --> 00:33:04,930
好的，就是这样，所以我将进入这个 for 循环内部

750
00:33:04,930 --> 00:33:08,740
并在内部运行这些代码。

751
00:33:08,740 --> 00:33:15,880
一旦我到达 for 循环的底部，我就会转到顶部。

752
00:33:15,880 --> 00:33:16,660
我会这样做的。

753
00:33:16,660 --> 00:33:18,987
我将 i 增加 1。

754
00:33:18,987 --> 00:33:20,320
我再问一次。

755
00:33:20,320 --> 00:33:21,170
我小于 10 吗？

756
00:33:21,170 --> 00:33:21,670
就是这样。

757
00:33:21,670 --> 00:33:23,230
好吧，我再写一遍代码。

758
00:33:23,230 --> 00:33:26,635
完成后，我会再次将 i 增加 1，提出问题，继续、

759
00:33:26,635 --> 00:33:27,260
并继续前进。

760
00:33:27,260 --> 00:33:29,167
有帮助吗？

761
00:33:29,167 --> 00:33:30,000
学生：好的，明白了。

762
00:33:30,000 --> 00:33:34,240
因此，首先输入的是 i 等于 0，然后 [INNAUDIBLE]......。

763
00:33:34,240 --> 00:33:36,790
CARTER ZENKE：没错，这是我们的初始化。

764
00:33:36,790 --> 00:33:40,870
这是 for 循环第一次运行，将其设置为该值。

765
00:33:40,870 --> 00:33:44,860
每当内部代码运行完毕，就会问 --

766
00:33:44,860 --> 00:33:49,150
或者说，在我们开始运行这段代码之前，先问这个问题。

767
00:33:49,150 --> 00:33:51,810
如果为真，请运行此代码。

768
00:33:51,810 --> 00:33:55,380
然后我们到底部，将 i 增加 1，或者在这里做任何事情。

769
00:33:55,380 --> 00:33:56,880
学生：这应该能做 10 次吗？

770
00:33:56,880 --> 00:33:58,880
这应该能做10次，对吧？

771
00:33:58,880 --> 00:34:03,420
0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

772
00:34:03,420 --> 00:34:07,366
它不会做 10，因为它不会小于 10。

773
00:34:07,366 --> 00:34:09,570
学生：这叫 "做一会儿 "吗？

774
00:34:09,570 --> 00:34:13,050
CARTER ZENKE：之所以叫for loop，是因为4在右边。

775
00:34:13,050 --> 00:34:13,792
那里

776
00:34:13,792 --> 00:34:17,100
是的，但我们确实有 do while 循环，如果我们能快速进入该循环的话

777
00:34:17,100 --> 00:34:18,699
这里。

778
00:34:18,699 --> 00:34:22,560
do while 循环中有 do while 的字样，对吗？

779
00:34:22,560 --> 00:34:27,360
这样做的目的实际上不是先提问。

780
00:34:27,360 --> 00:34:32,010
只要无条件地运行这段代码，然后再提问。

781
00:34:32,010 --> 00:34:34,860
这对于从用户那里获取一些输入信息非常方便

782
00:34:34,860 --> 00:34:37,739
因为它会一直问用户这个问题。

783
00:34:37,739 --> 00:34:39,270
你想给我什么建议？

784
00:34:39,270 --> 00:34:43,230
然后可能会根据输入是否无效重新提示他们

785
00:34:43,230 --> 00:34:44,790
你希望它是什么，好吗？

786
00:34:44,790 --> 00:34:47,790
因此，在这里我们可以说，这是我们输入的条件。

787
00:34:47,790 --> 00:34:48,540
无效。

788
00:34:48,540 --> 00:34:52,620
我们应该回到上面，重新来过。

789
00:34:52,620 --> 00:34:55,520
因此，关于这类循环的问题依然存在。

790
00:34:55,520 --> 00:34:59,870


791
00:34:59,870 --> 00:35:00,870
是啊

792
00:35:00,870 --> 00:35:04,890
学生：这样好吗，do-while 循环，如果你要 --

793
00:35:04,890 --> 00:35:07,595
你是在提问

794
00:35:07,595 --> 00:35:10,383
你没说你在做什么？

795
00:35:10,383 --> 00:35:15,330
与 [INAUDIBLE] while 循环一样，给出一个给定的数字？

796
00:35:15,330 --> 00:35:18,840
是否有更简单的方法来终止函数，例如

797
00:35:18,840 --> 00:35:21,133
你的年龄不合适吗？

798
00:35:21,133 --> 00:35:23,175
你说的 "终止 "是指 --

799
00:35:23,175 --> 00:35:24,840
学生：终止功能

800
00:35:24,840 --> 00:35:26,100
就像它停了下来。

801
00:35:26,100 --> 00:35:30,580
如果您使用--比如说您要查找 25 岁到 30 岁之间的年龄段、

802
00:35:30,580 --> 00:35:35,360
如果它在里面，就进入 while 循环。

803
00:35:35,360 --> 00:35:37,640
这样，while 循环会不会

804
00:35:37,640 --> 00:35:42,210
是否有办法阻止 while 循环？

805
00:35:42,210 --> 00:35:43,960
卡尔特-曾克：那么，如果我的理解是

806
00:35:43,960 --> 00:35:47,140
如果你的要求是正确的，通常最好

807
00:35:47,140 --> 00:35:51,280
检查我们不希望发生的事情，而不是检查什么

808
00:35:51,280 --> 00:35:52,880
我们希望发生什么？

809
00:35:52,880 --> 00:35:55,370
例如，我可能不想这样做。

810
00:35:55,370 --> 00:36:00,160
在这里，我可能不想说 int age 就是 get int age。

811
00:36:00,160 --> 00:36:06,940
然后再问一个问题，如果，比方说，年龄在-- 你说什么来着？

812
00:36:06,940 --> 00:36:08,320
比如 15 岁和 20 岁？

813
00:36:08,320 --> 00:36:09,100
学生：是的。

814
00:36:09,100 --> 00:36:15,970
CARTER ZENKE：如果年龄在 15 岁到 20 岁之间，那就参加我节目的其他部分。

815
00:36:15,970 --> 00:36:19,420
因为我在这里做的是把我的程序与

816
00:36:19,420 --> 00:36:22,000
我缩进了很多，也许我有更多的条件。

817
00:36:22,000 --> 00:36:25,360
也许我还想说，如果名字以 A 开头、

818
00:36:25,360 --> 00:36:28,270
然后就会越来越缩进。

819
00:36:28,270 --> 00:36:31,040
因此，我可以这样做。

820
00:36:31,040 --> 00:36:34,730
我可以说，好吧，让我来吧。

821
00:36:34,730 --> 00:36:37,210
让我创建一个名为年龄的变量。

822
00:36:37,210 --> 00:36:40,690
让我得到一些价值。

823
00:36:40,690 --> 00:36:41,360
哎呀

824
00:36:41,360 --> 00:36:43,160
让我得到一些价值。

825
00:36:43,160 --> 00:36:47,740
虽然年龄不是我想要的，但请允许我继续重提。

826
00:36:47,740 --> 00:36:49,550
这算是回答了你的问题吗？

827
00:36:49,550 --> 00:36:50,800
学生：是的，我知道了，是的。

828
00:36:50,800 --> 00:36:57,000
好的，那么年龄是小于 15 岁，还是大于 20 岁。

829
00:36:57,000 --> 00:37:00,830
让我再提示一下，好吗？

830
00:37:00,830 --> 00:37:01,330
好的。

831
00:37:01,330 --> 00:37:02,366
是啊

832
00:37:02,366 --> 00:37:11,560
学生：是[听不清]写年龄小于、等于、介于两者之间吗？

833
00:37:11,560 --> 00:37:17,200
还是说年龄越小越好？

834
00:37:17,200 --> 00:37:19,430
CARTER ZENKE：可能要看具体情况。

835
00:37:19,430 --> 00:37:23,530
那么问题来了，是用这个 "小于 "好，还是用这个 "小于 "好呢？

836
00:37:23,530 --> 00:37:25,090
或等于？

837
00:37:25,090 --> 00:37:28,930
一般来说，在编写循环程序时，您只需要

838
00:37:28,930 --> 00:37:31,240
重复一定的次数，我们往往会

839
00:37:31,240 --> 00:37:34,330
使用小于，并始终从 0 开始。

840
00:37:34,330 --> 00:37:36,490
比方说，我想让某些内容重复五次。

841
00:37:36,490 --> 00:37:41,530
我会说 int i 等于 0，i 小于 5，i++。

842
00:37:41,530 --> 00:37:44,290
这样的数学运算也行得通，对吧？

843
00:37:44,290 --> 00:37:47,950
0、1、2、3、4，一共五次。

844
00:37:47,950 --> 00:37:52,210
如果我这样做，假设 int i 是 1、

845
00:37:52,210 --> 00:37:54,880
那么我就必须小于或等于 5。

846
00:37:54,880 --> 00:37:58,960
因为程序员是从 0 开始计数的，也就是说没有任何东西。

847
00:37:58,960 --> 00:38:00,610
从最基本的做起。

848
00:38:00,610 --> 00:38:03,527
实际上，我们不会在这里使用 "小于或等于 "符号。

849
00:38:03,527 --> 00:38:04,660
有帮助吗？

850
00:38:04,660 --> 00:38:06,330
是啊

851
00:38:06,330 --> 00:38:06,830
好的。

852
00:38:06,830 --> 00:38:10,860


853
00:38:10,860 --> 00:38:15,340
好了，有了这些循环的构件、

854
00:38:15,340 --> 00:38:19,240
接下来的 10 分钟左右，我们将在实验室工作。

855
00:38:19,240 --> 00:38:23,620
在我们的实验室 -- 如果我回到我的幻灯片这里 --

856
00:38:23,620 --> 00:38:26,680
我们要问的问题是，有多少只骆驼？

857
00:38:26,680 --> 00:38:28,030
我们目前有什么？

858
00:38:28,030 --> 00:38:31,600
我们需要多少年才能实现骆驼的理想数量？

859
00:38:31,600 --> 00:38:34,160
在这里为我们自己饲养一定数量的骆驼？

860
00:38:34,160 --> 00:38:37,675
因此，如果我们看一下这个，就可以在这个网址上找到实验室。

861
00:38:37,675 --> 00:38:38,800
课程网站上有。

862
00:38:38,800 --> 00:38:40,160
进入实验室页面。

863
00:38:40,160 --> 00:38:43,090
在实验室里，你会发现这些问题。

864
00:38:43,090 --> 00:38:44,080
事实上，对不起。

865
00:38:44,080 --> 00:38:48,040
在这个实验页面中，你们将一起解决这个问题。

866
00:38:48,040 --> 00:38:51,650
不过，我们会在前面就开始着手解决这个问题。

867
00:38:51,650 --> 00:38:53,530
因此，我们要为这个实验室做的第一件事就是

868
00:38:53,530 --> 00:38:56,710
就是想想我们自己要如何做一个榜样、

869
00:38:56,710 --> 00:38:59,740
然后再写代码。

870
00:38:59,740 --> 00:39:03,460
当你在处理问题时，经常想一想

871
00:39:03,460 --> 00:39:05,950
首先要考虑如何编写算法、

872
00:39:05,950 --> 00:39:07,840
然后编写代码。

873
00:39:07,840 --> 00:39:11,830
因此，无论你是在实验室工作，这七个步骤都能帮到你、

874
00:39:11,830 --> 00:39:13,640
等。

875
00:39:13,640 --> 00:39:16,810
请注意，其中一半以上是

876
00:39:16,810 --> 00:39:20,500
把事情写下来，想清楚，不一定

877
00:39:20,500 --> 00:39:22,120
编程

878
00:39:22,120 --> 00:39:26,630
但最后三个步骤都是要将这一想法转化为代码。

879
00:39:26,630 --> 00:39:28,450
所以，我们今天就在这里做这件事。

880
00:39:28,450 --> 00:39:31,112
看看我们的骆驼，我们有一定数量的骆驼。

881
00:39:31,112 --> 00:39:33,070
我们想知道这需要多少年的时间

882
00:39:33,070 --> 00:39:35,140
去找另一批骆驼。

883
00:39:35,140 --> 00:39:39,490
我们知道，每年可能有三分之一的骆驼出生、

884
00:39:39,490 --> 00:39:43,300
有 1/4 的骆驼不幸去世，对吗？

885
00:39:43,300 --> 00:39:46,640
让我们来看看这个特殊的例子。

886
00:39:46,640 --> 00:39:48,970
我们有 12 只骆驼。

887
00:39:48,970 --> 00:39:53,770
因此，在今年，将有 12 隻超过 3 隻的新骆驼诞生、

888
00:39:53,770 --> 00:39:56,480
超过 4 只骆驼的 12 只骆驼将离开人世。

889
00:39:56,480 --> 00:40:00,550
问题是，需要多少年才能达到 13 只骆驼？

890
00:40:00,550 --> 00:40:03,940
因此，在这个例子中，我们有 12 只骆驼。

891
00:40:03,940 --> 00:40:05,380
现在，我们该怎么办？

892
00:40:05,380 --> 00:40:08,290
我们想生下 1/3 只骆驼。

893
00:40:08,290 --> 00:40:09,760
那么，我们还要在这里增加多少人呢？

894
00:40:09,760 --> 00:40:10,605
学生：四个。

895
00:40:10,605 --> 00:40:12,105
四，好，加四。

896
00:40:12,105 --> 00:40:14,740


897
00:40:14,740 --> 00:40:16,330
又有多少人会离开人世？

898
00:40:16,330 --> 00:40:17,230
学生：三个。

899
00:40:17,230 --> 00:40:20,080
三个，所以我们要带走三个。

900
00:40:20,080 --> 00:40:22,900
我们现在有 13 只羊驼，对吗？

901
00:40:22,900 --> 00:40:24,760
而这只是一年的总体情况。

902
00:40:24,760 --> 00:40:27,730
我们又生下了四只骆驼，有三只骆驼去世了。

903
00:40:27,730 --> 00:40:30,230
现在，我们有 13 人。

904
00:40:30,230 --> 00:40:33,850
所以，在你编写这个程序的时候，我们马上就可以开始了。

905
00:40:33,850 --> 00:40:37,150
我们希望首先提示用户骆驼的起始数量、

906
00:40:37,150 --> 00:40:40,930
询问他们骆驼的目标数量，然后做一些计算，也许

907
00:40:40,930 --> 00:40:43,330
在一个循环中计算出多少年

908
00:40:43,330 --> 00:40:46,030
达到目标骆驼数量所需的时间、

909
00:40:46,030 --> 00:40:48,950
最后，打印出该年数。

910
00:40:48,950 --> 00:40:55,390
因此，如果你在自己的代码空间中，可以转到这里的环境。

911
00:40:55,390 --> 00:41:01,450
您可以输入代码 population.C 打开该文件。

912
00:41:01,450 --> 00:41:03,100
这是我的。

913
00:41:03,100 --> 00:41:07,060
然后，您可以键入 "包含 standardio.h "来打印一些内容

914
00:41:07,060 --> 00:41:08,470
稍后在屏幕上显示。

915
00:41:08,470 --> 00:41:13,730
你也可以在这里使用 cs50 库 cs50.h。

916
00:41:13,730 --> 00:41:16,890
我们还需要什么模板代码？

917
00:41:16,890 --> 00:41:17,662
学生

918
00:41:17,662 --> 00:41:19,120
Int main void, right?

919
00:41:19,120 --> 00:41:23,800
所以我会说 int main void。

920
00:41:23,800 --> 00:41:26,830
剩下的就交给你了 但你一定要问 --

921
00:41:26,830 --> 00:41:32,110
提示用户骆驼的起始数量、

922
00:41:32,110 --> 00:41:37,090
提示他们骆驼的终止数量，然后

923
00:41:37,090 --> 00:41:41,170
最后，也许可以使用某种循环来计算它需要多少年

924
00:41:41,170 --> 00:41:43,795
达到目标所需的时间。

925
00:41:43,795 --> 00:41:47,430


926
00:41:47,430 --> 00:41:56,220
请记住，我们现在的骆驼每年有 1/3 诞生

927
00:41:56,220 --> 00:42:00,080
和 1/4 的逝去。

928
00:42:00,080 --> 00:42:05,900
好吧，就这样做 10 分钟左右。

929
00:42:05,900 --> 00:42:08,960
我们会回来一起研究这个例子。

930
00:42:08,960 --> 00:42:12,410
好了，希望你们在这个实验室里取得了不错的进展。

931
00:42:12,410 --> 00:42:15,440
让我们回来一起做这个例子。

932
00:42:15,440 --> 00:42:18,980
我们有几个步骤需要完成，第一个步骤是提示用户

933
00:42:18,980 --> 00:42:21,740
骆驼的起始数量。

934
00:42:21,740 --> 00:42:26,000
我想请会议室这边的一个小组，也许

935
00:42:26,000 --> 00:42:30,350
如果你不介意的话，你是如何提示用户

936
00:42:30,350 --> 00:42:33,890
您的骆驼起始数量是多少？

937
00:42:33,890 --> 00:42:34,820
好，说吧

938
00:42:34,820 --> 00:42:40,220
学生：那么，第一个[听不清]开始。

939
00:42:40,220 --> 00:42:43,290
我们运行了一个 do-while 循环。

940
00:42:43,290 --> 00:42:48,000
所以它说开始等于获取 int，然后开始大小。

941
00:42:48,000 --> 00:42:51,360
然后，条件是起始点小于 9。

942
00:42:51,360 --> 00:42:54,780
明白了，所以起始点小于 9 点。

943
00:42:54,780 --> 00:42:57,810
你为什么选择小于 9 的情况？

944
00:42:57,810 --> 00:43:00,960
学生：因为实验室说，起始的最低数量是

945
00:43:00,960 --> 00:43:04,770
否则人口将无法增长。

946
00:43:04,770 --> 00:43:07,710
卡尔特-曾克：是的，所以如果用户给我们提供了

947
00:43:07,710 --> 00:43:10,262
小于 9 的数字，对吗？

948
00:43:10,262 --> 00:43:11,220
看起来不错。

949
00:43:11,220 --> 00:43:14,970
同样，我们怎样才能提示他们骆驼的终止数量呢？

950
00:43:14,970 --> 00:43:17,580
请问这次能不能在中间问？

951
00:43:17,580 --> 00:43:19,920
也许是后几排的某个人，如何

952
00:43:19,920 --> 00:43:22,935
您是否尝试在这里提示骆驼的尾数？

953
00:43:22,935 --> 00:43:26,900


954
00:43:26,900 --> 00:43:28,640
好，说吧

955
00:43:28,640 --> 00:43:31,768
学生：我创建了一个名为 n 的 int 变量。

956
00:43:31,768 --> 00:43:32,560
很好

957
00:43:32,560 --> 00:43:35,552
学生：然后我用了一个 do-while 循环。

958
00:43:35,552 --> 00:43:42,015
[n等于int，然后结束大小。

959
00:43:42,015 --> 00:43:48,647
然后，while 的条件是 end 小于 start。

960
00:43:48,647 --> 00:43:50,480
卡尔特-曾克：是的，然后我想问你

961
00:43:50,480 --> 00:43:53,380
你为什么要把它放在你的条件中？

962
00:43:53,380 --> 00:43:57,510
学生：因为在实验室里，它希望我们保持

963
00:43:57,510 --> 00:44:02,930
如果用户输入的结束尺寸小于起始尺寸，则提示

964
00:44:02,930 --> 00:44:03,523
点。

965
00:44:03,523 --> 00:44:04,690
是的，完全正确。

966
00:44:04,690 --> 00:44:07,923
因此，我们的骆驼数量不能少于最初的数量。

967
00:44:07,923 --> 00:44:10,090
因此，我只是想确认一下情况是否如此。

968
00:44:10,090 --> 00:44:13,260
如果没有，我们会重新提示用户。

969
00:44:13,260 --> 00:44:17,130
最后，我们还记录了有多少年

970
00:44:17,130 --> 00:44:20,310
要达到我们现在储存骆驼的目标数量

971
00:44:20,310 --> 00:44:22,440
在这个名为 end 的变量中。

972
00:44:22,440 --> 00:44:25,380
你们是如何选择代表年份的？

973
00:44:25,380 --> 00:44:30,090
或您的项目已经实施了多少年？

974
00:44:30,090 --> 00:44:33,230
我现在可以请这边的人发言吗？

975
00:44:33,230 --> 00:44:36,290
你用什么变量来计算这里的年数？

976
00:44:36,290 --> 00:44:39,250


977
00:44:39,250 --> 00:44:42,190
也许是前几排的某个人。

978
00:44:42,190 --> 00:44:42,910
好，说吧

979
00:44:42,910 --> 00:44:43,868
学生：整数。

980
00:44:43,868 --> 00:44:47,035
CARTER ZENKE：整数，你有没有给它起个特别的名字或别的什么？

981
00:44:47,035 --> 00:44:48,370
学生：我叫它 "Int years"。

982
00:44:48,370 --> 00:44:49,570
好几年了，好吧。

983
00:44:49,570 --> 00:44:51,880
你先设置了什么？

984
00:44:51,880 --> 00:44:52,720
学生：零。

985
00:44:52,720 --> 00:44:54,700
零，好的。

986
00:44:54,700 --> 00:44:57,550
现在我们要做一些计算。

987
00:44:57,550 --> 00:44:59,983
如果我们看一下

988
00:44:59,983 --> 00:45:01,150
这组 [听不清] 介意。

989
00:45:01,150 --> 00:45:03,730
你们是如何增加或减少骆驼的？

990
00:45:03,730 --> 00:45:07,060
随着时间的推移，您是如何调整骆驼数量的？

991
00:45:07,060 --> 00:45:12,910


992
00:45:12,910 --> 00:45:17,695
你有什么好办法，或者你是如何做到的？

993
00:45:17,695 --> 00:45:18,320
好，说吧

994
00:45:18,320 --> 00:45:20,392
学生：每年增加 112 只骆驼就可以了。

995
00:45:20,392 --> 00:45:22,100
每年新增 112 只骆驼。

996
00:45:22,100 --> 00:45:22,600
不错。

997
00:45:22,600 --> 00:45:25,322
那么，你能不能告诉我，如果我们在这里看看我们的计划、

998
00:45:25,322 --> 00:45:28,280
我们已经设定了骆驼的起始数量，在这里该如何调整？

999
00:45:28,280 --> 00:45:31,320


1000
00:45:31,320 --> 00:45:33,772
学生：你会去，就像你说的，在开始的时候 --

1001
00:45:33,772 --> 00:45:34,605
CARTER ZENKE：开始

1002
00:45:34,605 --> 00:45:37,450
学生：这将是开始等于 --

1003
00:45:37,450 --> 00:45:38,830
对不起，"加 "等于 "等于"。

1004
00:45:38,830 --> 00:45:40,163
CARTER ZENKE：开始加等于。

1005
00:45:40,163 --> 00:45:41,410
学生：开始除以 12。

1006
00:45:41,410 --> 00:45:43,930
CARTER ZENKE：起点除以 12。

1007
00:45:43,930 --> 00:45:46,150
你又是怎么开始除以 12 的？

1008
00:45:46,150 --> 00:45:48,820
你是怎么算出来的？

1009
00:45:48,820 --> 00:45:51,105
学生：1/3 和 1/4 的公分母。

1010
00:45:51,105 --> 00:45:53,530
然后加上 1/3，再减去 1/4。

1011
00:45:53,530 --> 00:45:55,655
卡尔特-曾克：很好，所以归根结底，每年我们都会

1012
00:45:55,655 --> 00:45:59,680
在增加 1/3 和减少 1/4 之后，再增加 1/12 只新骆驼。

1013
00:45:59,680 --> 00:46:03,430
这相当于每年新增骆驼的 1/12。

1014
00:46:03,430 --> 00:46:08,050
但我们需要某种循环来运行它。

1015
00:46:08,050 --> 00:46:10,300
有谁想帮我完成这最后一块？

1016
00:46:10,300 --> 00:46:13,520
我们怎样才能增加这个环路？

1017
00:46:13,520 --> 00:46:16,460
骆驼，也要懂得适可而止。

1018
00:46:16,460 --> 00:46:17,030
是啊

1019
00:46:17,030 --> 00:46:21,729
学生：我们可以在起点小于终点的时候[听不清]起点。

1020
00:46:21,729 --> 00:46:26,457
之后再加上[INNAUDIBLE]. .

1021
00:46:26,457 --> 00:46:28,165
CARTER ZENKE：是的，那么在年份后面加上 1？

1022
00:46:28,165 --> 00:46:28,870
学生：是的。

1023
00:46:28,870 --> 00:46:33,730
CARTER ZENKE：是的，所以我们可以说 years++ 增加 1 年。

1024
00:46:33,730 --> 00:46:37,940
最后，我们希望打印出年数。

1025
00:46:37,940 --> 00:46:40,840
所以我会说 printf %i。

1026
00:46:40,840 --> 00:46:44,410
也许只是为了澄清一下，百分比是几年，然后是几年

1027
00:46:44,410 --> 00:46:49,100
底部，末尾为反斜杠 n。

1028
00:46:49,100 --> 00:46:56,410
如果我让它制造人口，运行 ./population、

1029
00:46:56,410 --> 00:46:59,310
我可能会输入 12 和 13。

1030
00:46:59,310 --> 00:47:02,460
正如我们所期望的那样，我的任期为一年。

1031
00:47:02,460 --> 00:47:03,645
是的，问题或意见。

1032
00:47:03,645 --> 00:47:07,503
学生：什么是加等于[听不清]开始加等于开始？

1033
00:47:07,503 --> 00:47:08,670
CARTER ZENKE：问得好。

1034
00:47:08,670 --> 00:47:11,260
这基本上就是这样做的速记。

1035
00:47:11,260 --> 00:47:17,430
我可以说 "开始 "等于 "开始 "+"开始超过 12"，因为我正在尝试

1036
00:47:17,430 --> 00:47:19,750
在我们开始的时候添加。

1037
00:47:19,750 --> 00:47:22,620
因此，这个加法等式只是说，让

1038
00:47:22,620 --> 00:47:27,298
我在右侧的值上加上当前的起始值。

1039
00:47:27,298 --> 00:47:28,215
有道理吗？

1040
00:47:28,215 --> 00:47:28,870
学生：好的，谢谢。

1041
00:47:28,870 --> 00:47:29,745
知道了

1042
00:47:29,745 --> 00:47:34,460


1043
00:47:34,460 --> 00:47:39,120
现在，这里有一个问题 就是，比方说，我有 - 哦，是的、

1044
00:47:39,120 --> 00:47:40,370
去吧，就在这里

1045
00:47:40,370 --> 00:47:41,560
是啊

1046
00:47:41,560 --> 00:47:44,900
学生：我有一个关于第 12 行开头的问题。

1047
00:47:44,900 --> 00:47:49,370
我们有一部分是[听不清]表格

1048
00:47:49,370 --> 00:47:53,130
其中一部分是我们的时间。

1049
00:47:53,130 --> 00:47:58,790
因此，您需要将第一部分四舍五入，然后再将第二部分四舍五入

1050
00:47:58,790 --> 00:48:04,910
因为不可能有一半的骆驼死了，而三分之一还活着。

1051
00:48:04,910 --> 00:48:09,920
因此，在某些情况下，当一个数字可以被它的一部分整除时

1052
00:48:09,920 --> 00:48:13,040
而不能被另一个整除，可能会产生一些差异。

1053
00:48:13,040 --> 00:48:17,300
CARTER ZENKE：是的，所以也许我们最好重新开始 3

1054
00:48:17,300 --> 00:48:21,067
然后减去 4

1055
00:48:21,067 --> 00:48:22,400
是的，但如果你 --

1056
00:48:22,400 --> 00:48:23,150
继续前进。

1057
00:48:23,150 --> 00:48:24,950
学生：--这些数字是圆的吗？

1058
00:48:24,950 --> 00:48:30,050
我猜除以 3 [听不清] 或 3.3333。

1059
00:48:30,050 --> 00:48:34,080
因此，你需要四舍五入 3，否则、

1060
00:48:34,080 --> 00:48:36,678
你不能有1/3的骆驼[INNAUDIBLE]. .

1061
00:48:36,678 --> 00:48:38,970
是的，我们不想要三分之一的骆驼。

1062
00:48:38,970 --> 00:48:41,230
所以我们得想办法解决这个问题。

1063
00:48:41,230 --> 00:48:44,400
我认为，我们要做的永远是四舍五入、

1064
00:48:44,400 --> 00:48:48,720
这就给我们带来了 C 语言的一些特性，或者在某些情况下，一个错误--

1065
00:48:48,720 --> 00:48:51,210
你可能会遇到这种情况 -- 称为截断。

1066
00:48:51,210 --> 00:48:54,900
而我们在讲座中并没有看到这么多，所以在这里强调一下、

1067
00:48:54,900 --> 00:49:00,940
在 C 语言中，当您除以两个整数时，得到的总是一个整数。

1068
00:49:00,940 --> 00:49:07,050
因此，如果我除以 2 和 3，2 除以 3，都是整数、

1069
00:49:07,050 --> 00:49:08,760
我不会得到 2/3。

1070
00:49:08,760 --> 00:49:10,260
我会得到 0。

1071
00:49:10,260 --> 00:49:13,240
一定要向下舍入，切掉剩下的数据。

1072
00:49:13,240 --> 00:49:19,440
因此，为了举例说明这一点，我可能会编写代码 truncation.c。

1073
00:49:19,440 --> 00:49:25,480
我将使用相同的模板代码 standardio.h。

1074
00:49:25,480 --> 00:49:28,420
我将包含 cs50.h。

1075
00:49:28,420 --> 00:49:30,850
我会说 int main void。

1076
00:49:30,850 --> 00:49:35,680
我输入 int a 可能是 2。

1077
00:49:35,680 --> 00:49:37,540
Int b 为 3。

1078
00:49:37,540 --> 00:49:42,020
让我们把除法的结果打印出来。

1079
00:49:42,020 --> 00:49:46,210
比方说--实际上，对不起，int c 是 a 除以 b。

1080
00:49:46,210 --> 00:49:51,100
我想说的是，这样就能得到结果。

1081
00:49:51,100 --> 00:49:58,300
我会说进行截断并执行 ./truncation。

1082
00:49:58,300 --> 00:50:02,380
我会得到 0，而不是 2/3。

1083
00:50:02,380 --> 00:50:04,300
所以这里总是四舍五入。

1084
00:50:04,300 --> 00:50:07,150
如果我确实需要小数点，我可以这样做

1085
00:50:07,150 --> 00:50:12,170
我是否可以立即将其中一个转换成小数？

1086
00:50:12,170 --> 00:50:16,240
所以我可以说，实际上，我想让它成为一个浮筒

1087
00:50:16,240 --> 00:50:18,650
然后完成除法。

1088
00:50:18,650 --> 00:50:20,980
只要其中一个数字是浮点数、

1089
00:50:20,980 --> 00:50:22,940
最后你会得到一个漂浮物。

1090
00:50:22,940 --> 00:50:25,660
所以我说这里可能是 %f。

1091
00:50:25,660 --> 00:50:27,950
我会进行截断。

1092
00:50:27,950 --> 00:50:28,450
哎呀

1093
00:50:28,450 --> 00:50:32,980
我想说的是，现在这其实已经是浮云了。

1094
00:50:32,980 --> 00:50:41,440
进行截断，我说 ./截断，就能得到 0.6667。

1095
00:50:41,440 --> 00:50:52,270
如果我不这样做，如果我不这样做，我就会得 0 分。

1096
00:50:52,270 --> 00:50:55,000
因此，我们在进行这项工作时要牢记这一点。

1097
00:50:55,000 --> 00:50:58,337
我很乐意留下来回答大家的任何问题、

1098
00:50:58,337 --> 00:51:01,420
但这应该会让我们结束今天的实验室和我们的超级部分

1099
00:51:01,420 --> 00:51:01,850
也是如此。

1100
00:51:01,850 --> 00:51:02,540
感谢大家的光临。

1101
00:51:02,540 --> 00:51:03,832
很高兴在这里见到你。

1102
00:51:03,832 --> 00:51:06,060
希望下周能在分会场见到你们。

1103
00:51:06,060 --> 00:51:08,000


